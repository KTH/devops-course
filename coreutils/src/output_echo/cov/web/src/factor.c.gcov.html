<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - trace.lcov_info_final - src/factor.c</title>
  <link rel="stylesheet" type="text/css" href="../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../index.html">top level</a> - <a href="index.html">src</a> - factor.c<span style="font-size: 80%;"> (source / <a href="factor.c.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">trace.lcov_info_final</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">0</td>
            <td class="headerCovTableEntry">507</td>
            <td class="headerCovTableEntryLo">0.0 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2019-04-22 20:19:38</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">0</td>
            <td class="headerCovTableEntry">26</td>
            <td class="headerCovTableEntryLo">0.0 %</td>
          </tr>
          <tr><td><img src="../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : /* factor -- print prime factors of n.</a>
<span class="lineNum">       2 </span>            :    Copyright (C) 1986-2016 Free Software Foundation, Inc.
<span class="lineNum">       3 </span>            : 
<span class="lineNum">       4 </span>            :    This program is free software: you can redistribute it and/or modify
<span class="lineNum">       5 </span>            :    it under the terms of the GNU General Public License as published by
<span class="lineNum">       6 </span>            :    the Free Software Foundation, either version 3 of the License, or
<span class="lineNum">       7 </span>            :    (at your option) any later version.
<span class="lineNum">       8 </span>            : 
<span class="lineNum">       9 </span>            :    This program is distributed in the hope that it will be useful,
<span class="lineNum">      10 </span>            :    but WITHOUT ANY WARRANTY; without even the implied warranty of
<span class="lineNum">      11 </span>            :    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
<span class="lineNum">      12 </span>            :    GNU General Public License for more details.
<span class="lineNum">      13 </span>            : 
<span class="lineNum">      14 </span>            :    You should have received a copy of the GNU General Public License
<span class="lineNum">      15 </span>            :    along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.  */
<span class="lineNum">      16 </span>            : 
<span class="lineNum">      17 </span>            : /* Originally written by Paul Rubin &lt;phr@ocf.berkeley.edu&gt;.
<span class="lineNum">      18 </span>            :    Adapted for GNU, fixed to factor UINT_MAX by Jim Meyering.
<span class="lineNum">      19 </span>            :    Arbitrary-precision code adapted by James Youngman from Torbjörn
<span class="lineNum">      20 </span>            :    Granlund's factorize.c, from GNU MP version 4.2.2.
<span class="lineNum">      21 </span>            :    In 2012, the core was rewritten by Torbjörn Granlund and Niels Möller.
<span class="lineNum">      22 </span>            :    Contains code from GNU MP.  */
<span class="lineNum">      23 </span>            : 
<span class="lineNum">      24 </span>            : /* Efficiently factor numbers that fit in one or two words (word = uintmax_t),
<span class="lineNum">      25 </span>            :    or, with GMP, numbers of any size.
<span class="lineNum">      26 </span>            : 
<span class="lineNum">      27 </span>            :   Code organisation:
<span class="lineNum">      28 </span>            : 
<span class="lineNum">      29 </span>            :     There are several variants of many functions, for handling one word, two
<span class="lineNum">      30 </span>            :     words, and GMP's mpz_t type.  If the one-word variant is called foo, the
<span class="lineNum">      31 </span>            :     two-word variant will be foo2, and the one for mpz_t will be mp_foo.  In
<span class="lineNum">      32 </span>            :     some cases, the plain function variants will handle both one-word and
<span class="lineNum">      33 </span>            :     two-word numbers, evidenced by function arguments.
<span class="lineNum">      34 </span>            : 
<span class="lineNum">      35 </span>            :     The factoring code for two words will fall into the code for one word when
<span class="lineNum">      36 </span>            :     progress allows that.
<span class="lineNum">      37 </span>            : 
<span class="lineNum">      38 </span>            :     Using GMP is optional.  Define HAVE_GMP to make this code include GMP
<span class="lineNum">      39 </span>            :     factoring code.  The GMP factoring code is based on GMP's demos/factorize.c
<span class="lineNum">      40 </span>            :     (last synced 2012-09-07).  The GMP-based factoring code will stay in GMP
<span class="lineNum">      41 </span>            :     factoring code even if numbers get small enough for using the two-word
<span class="lineNum">      42 </span>            :     code.
<span class="lineNum">      43 </span>            : 
<span class="lineNum">      44 </span>            :   Algorithm:
<span class="lineNum">      45 </span>            : 
<span class="lineNum">      46 </span>            :     (1) Perform trial division using a small primes table, but without hardware
<span class="lineNum">      47 </span>            :         division since the primes table store inverses modulo the word base.
<span class="lineNum">      48 </span>            :         (The GMP variant of this code doesn't make use of the precomputed
<span class="lineNum">      49 </span>            :         inverses, but instead relies on GMP for fast divisibility testing.)
<span class="lineNum">      50 </span>            :     (2) Check the nature of any non-factored part using Miller-Rabin for
<span class="lineNum">      51 </span>            :         detecting composites, and Lucas for detecting primes.
<span class="lineNum">      52 </span>            :     (3) Factor any remaining composite part using the Pollard-Brent rho
<span class="lineNum">      53 </span>            :         algorithm or if USE_SQUFOF is defined to 1, try that first.
<span class="lineNum">      54 </span>            :         Status of found factors are checked again using Miller-Rabin and Lucas.
<span class="lineNum">      55 </span>            : 
<span class="lineNum">      56 </span>            :     We prefer using Hensel norm in the divisions, not the more familiar
<span class="lineNum">      57 </span>            :     Euclidian norm, since the former leads to much faster code.  In the
<span class="lineNum">      58 </span>            :     Pollard-Brent rho code and the prime testing code, we use Montgomery's
<span class="lineNum">      59 </span>            :     trick of multiplying all n-residues by the word base, allowing cheap Hensel
<span class="lineNum">      60 </span>            :     reductions mod n.
<span class="lineNum">      61 </span>            : 
<span class="lineNum">      62 </span>            :   Improvements:
<span class="lineNum">      63 </span>            : 
<span class="lineNum">      64 </span>            :     * Use modular inverses also for exact division in the Lucas code, and
<span class="lineNum">      65 </span>            :       elsewhere.  A problem is to locate the inverses not from an index, but
<span class="lineNum">      66 </span>            :       from a prime.  We might instead compute the inverse on-the-fly.
<span class="lineNum">      67 </span>            : 
<span class="lineNum">      68 </span>            :     * Tune trial division table size (not forgetting that this is a standalone
<span class="lineNum">      69 </span>            :       program where the table will be read from disk for each invocation).
<span class="lineNum">      70 </span>            : 
<span class="lineNum">      71 </span>            :     * Implement less naive powm, using k-ary exponentiation for k = 3 or
<span class="lineNum">      72 </span>            :       perhaps k = 4.
<span class="lineNum">      73 </span>            : 
<span class="lineNum">      74 </span>            :     * Try to speed trial division code for single uintmax_t numbers, i.e., the
<span class="lineNum">      75 </span>            :       code using DIVBLOCK.  It currently runs at 2 cycles per prime (Intel SBR,
<span class="lineNum">      76 </span>            :       IBR), 3 cycles per prime (AMD Stars) and 5 cycles per prime (AMD BD) when
<span class="lineNum">      77 </span>            :       using gcc 4.6 and 4.7.  Some software pipelining should help; 1, 2, and 4
<span class="lineNum">      78 </span>            :       respectively cycles ought to be possible.
<span class="lineNum">      79 </span>            : 
<span class="lineNum">      80 </span>            :     * The redcify function could be vastly improved by using (plain Euclidian)
<span class="lineNum">      81 </span>            :       pre-inversion (such as GMP's invert_limb) and udiv_qrnnd_preinv (from
<span class="lineNum">      82 </span>            :       GMP's gmp-impl.h).  The redcify2 function could be vastly improved using
<span class="lineNum">      83 </span>            :       similar methoods.  These functions currently dominate run time when using
<span class="lineNum">      84 </span>            :       the -w option.
<span class="lineNum">      85 </span>            : */
<span class="lineNum">      86 </span>            : 
<span class="lineNum">      87 </span>            : /* Whether to recursively factor to prove primality,
<span class="lineNum">      88 </span>            :    or run faster probabilistic tests.  */
<span class="lineNum">      89 </span>            : #ifndef PROVE_PRIMALITY
<span class="lineNum">      90 </span>            : # define PROVE_PRIMALITY 1
<span class="lineNum">      91 </span>            : #endif
<span class="lineNum">      92 </span>            : 
<span class="lineNum">      93 </span>            : /* Faster for certain ranges but less general.  */
<span class="lineNum">      94 </span>            : #ifndef USE_SQUFOF
<span class="lineNum">      95 </span>            : # define USE_SQUFOF 0
<span class="lineNum">      96 </span>            : #endif
<span class="lineNum">      97 </span>            : 
<span class="lineNum">      98 </span>            : /* Output SQUFOF statistics.  */
<span class="lineNum">      99 </span>            : #ifndef STAT_SQUFOF
<span class="lineNum">     100 </span>            : # define STAT_SQUFOF 0
<span class="lineNum">     101 </span>            : #endif
<span class="lineNum">     102 </span>            : 
<span class="lineNum">     103 </span>            : 
<span class="lineNum">     104 </span>            : #include &lt;config.h&gt;
<span class="lineNum">     105 </span>            : #include &lt;getopt.h&gt;
<span class="lineNum">     106 </span>            : #include &lt;stdio.h&gt;
<span class="lineNum">     107 </span>            : #if HAVE_GMP
<span class="lineNum">     108 </span>            : # include &lt;gmp.h&gt;
<span class="lineNum">     109 </span>            : # if !HAVE_DECL_MPZ_INITS
<span class="lineNum">     110 </span>            : #  include &lt;stdarg.h&gt;
<span class="lineNum">     111 </span>            : # endif
<span class="lineNum">     112 </span>            : #endif
<span class="lineNum">     113 </span>            : 
<span class="lineNum">     114 </span>            : #include &lt;assert.h&gt;
<span class="lineNum">     115 </span>            : 
<span class="lineNum">     116 </span>            : #include &quot;system.h&quot;
<span class="lineNum">     117 </span>            : #include &quot;error.h&quot;
<span class="lineNum">     118 </span>            : #include &quot;full-write.h&quot;
<span class="lineNum">     119 </span>            : #include &quot;quote.h&quot;
<span class="lineNum">     120 </span>            : #include &quot;readtokens.h&quot;
<span class="lineNum">     121 </span>            : #include &quot;xstrtol.h&quot;
<span class="lineNum">     122 </span>            : 
<span class="lineNum">     123 </span>            : /* The official name of this program (e.g., no 'g' prefix).  */
<span class="lineNum">     124 </span>            : #define PROGRAM_NAME &quot;factor&quot;
<span class="lineNum">     125 </span>            : 
<span class="lineNum">     126 </span>            : #define AUTHORS \
<span class="lineNum">     127 </span>            :   proper_name (&quot;Paul Rubin&quot;),                                           \
<span class="lineNum">     128 </span>            :   proper_name_utf8 (&quot;Torbjorn Granlund&quot;, &quot;Torbj\303\266rn Granlund&quot;),   \
<span class="lineNum">     129 </span>            :   proper_name_utf8 (&quot;Niels Moller&quot;, &quot;Niels M\303\266ller&quot;)
<span class="lineNum">     130 </span>            : 
<span class="lineNum">     131 </span>            : /* Token delimiters when reading from a file.  */
<span class="lineNum">     132 </span>            : #define DELIM &quot;\n\t &quot;
<span class="lineNum">     133 </span>            : 
<span class="lineNum">     134 </span>            : #ifndef USE_LONGLONG_H
<span class="lineNum">     135 </span>            : /* With the way we use longlong.h, it's only safe to use
<span class="lineNum">     136 </span>            :    when UWtype = UHWtype, as there were various cases
<span class="lineNum">     137 </span>            :    (as can be seen in the history for longlong.h) where
<span class="lineNum">     138 </span>            :    for example, _LP64 was required to enable W_TYPE_SIZE==64 code,
<span class="lineNum">     139 </span>            :    to avoid compile time or run time issues.  */
<span class="lineNum">     140 </span>            : # if LONG_MAX == INTMAX_MAX
<span class="lineNum">     141 </span>            : #  define USE_LONGLONG_H 1
<span class="lineNum">     142 </span>            : # endif
<span class="lineNum">     143 </span>            : #endif
<span class="lineNum">     144 </span>            : 
<span class="lineNum">     145 </span>            : #if USE_LONGLONG_H
<span class="lineNum">     146 </span>            : 
<span class="lineNum">     147 </span>            : /* Make definitions for longlong.h to make it do what it can do for us */
<span class="lineNum">     148 </span>            : 
<span class="lineNum">     149 </span>            : /* bitcount for uintmax_t */
<span class="lineNum">     150 </span>            : # if UINTMAX_MAX == UINT32_MAX
<span class="lineNum">     151 </span>            : #  define W_TYPE_SIZE 32
<span class="lineNum">     152 </span>            : # elif UINTMAX_MAX == UINT64_MAX
<span class="lineNum">     153 </span>            : #  define W_TYPE_SIZE 64
<span class="lineNum">     154 </span>            : # elif UINTMAX_MAX == UINT128_MAX
<span class="lineNum">     155 </span>            : #  define W_TYPE_SIZE 128
<span class="lineNum">     156 </span>            : # endif
<span class="lineNum">     157 </span>            : 
<span class="lineNum">     158 </span>            : # define UWtype  uintmax_t
<span class="lineNum">     159 </span>            : # define UHWtype unsigned long int
<span class="lineNum">     160 </span>            : # undef UDWtype
<span class="lineNum">     161 </span>            : # if HAVE_ATTRIBUTE_MODE
<span class="lineNum">     162 </span>            : typedef unsigned int UQItype    __attribute__ ((mode (QI)));
<span class="lineNum">     163 </span>            : typedef          int SItype     __attribute__ ((mode (SI)));
<span class="lineNum">     164 </span>            : typedef unsigned int USItype    __attribute__ ((mode (SI)));
<span class="lineNum">     165 </span>            : typedef          int DItype     __attribute__ ((mode (DI)));
<span class="lineNum">     166 </span>            : typedef unsigned int UDItype    __attribute__ ((mode (DI)));
<span class="lineNum">     167 </span>            : # else
<span class="lineNum">     168 </span>            : typedef unsigned char UQItype;
<span class="lineNum">     169 </span>            : typedef          long SItype;
<span class="lineNum">     170 </span>            : typedef unsigned long int USItype;
<span class="lineNum">     171 </span>            : #  if HAVE_LONG_LONG_INT
<span class="lineNum">     172 </span>            : typedef long long int DItype;
<span class="lineNum">     173 </span>            : typedef unsigned long long int UDItype;
<span class="lineNum">     174 </span>            : #  else /* Assume `long' gives us a wide enough type.  Needed for hppa2.0w.  */
<span class="lineNum">     175 </span>            : typedef long int DItype;
<span class="lineNum">     176 </span>            : typedef unsigned long int UDItype;
<span class="lineNum">     177 </span>            : #  endif
<span class="lineNum">     178 </span>            : # endif
<span class="lineNum">     179 </span>            : # define LONGLONG_STANDALONE     /* Don't require GMP's longlong.h mdep files */
<span class="lineNum">     180 </span>            : # define ASSERT(x)               /* FIXME make longlong.h really standalone */
<span class="lineNum">     181 </span>            : # define __GMP_DECLSPEC          /* FIXME make longlong.h really standalone */
<span class="lineNum">     182 </span>            : # define __clz_tab factor_clz_tab /* Rename to avoid glibc collision */
<span class="lineNum">     183 </span>            : # ifndef __GMP_GNUC_PREREQ
<span class="lineNum">     184 </span>            : #  define __GMP_GNUC_PREREQ(a,b) 1
<span class="lineNum">     185 </span>            : # endif
<span class="lineNum">     186 </span>            : 
<span class="lineNum">     187 </span>            : /* These stub macros are only used in longlong.h in certain system compiler
<span class="lineNum">     188 </span>            :    combinations, so ensure usage to avoid -Wunused-macros warnings.  */
<span class="lineNum">     189 </span>            : # if __GMP_GNUC_PREREQ (1,1) &amp;&amp; defined __clz_tab
<span class="lineNum">     190 </span>            : ASSERT (1)
<span class="lineNum">     191 </span>            : __GMP_DECLSPEC
<span class="lineNum">     192 </span>            : # endif
<span class="lineNum">     193 </span>            : 
<span class="lineNum">     194 </span>            : # if _ARCH_PPC
<span class="lineNum">     195 </span>            : #  define HAVE_HOST_CPU_FAMILY_powerpc 1
<span class="lineNum">     196 </span>            : # endif
<span class="lineNum">     197 </span>            : # include &quot;longlong.h&quot;
<span class="lineNum">     198 </span>            : # ifdef COUNT_LEADING_ZEROS_NEED_CLZ_TAB
<span class="lineNum">     199 </span>            : const unsigned char factor_clz_tab[129] =
<span class="lineNum">     200 </span>            : {
<span class="lineNum">     201 </span>            :   1,2,3,3,4,4,4,4,5,5,5,5,5,5,5,5,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,
<span class="lineNum">     202 </span>            :   7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,
<span class="lineNum">     203 </span>            :   8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,
<span class="lineNum">     204 </span>            :   8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,
<span class="lineNum">     205 </span>            :   9
<span class="lineNum">     206 </span>            : };
<span class="lineNum">     207 </span>            : # endif
<span class="lineNum">     208 </span>            : 
<span class="lineNum">     209 </span>            : #else /* not USE_LONGLONG_H */
<span class="lineNum">     210 </span>            : 
<span class="lineNum">     211 </span>            : # define W_TYPE_SIZE (8 * sizeof (uintmax_t))
<span class="lineNum">     212 </span>            : # define __ll_B ((uintmax_t) 1 &lt;&lt; (W_TYPE_SIZE / 2))
<span class="lineNum">     213 </span>            : # define __ll_lowpart(t)  ((uintmax_t) (t) &amp; (__ll_B - 1))
<span class="lineNum">     214 </span>            : # define __ll_highpart(t) ((uintmax_t) (t) &gt;&gt; (W_TYPE_SIZE / 2))
<span class="lineNum">     215 </span>            : 
<span class="lineNum">     216 </span>            : #endif
<span class="lineNum">     217 </span>            : 
<span class="lineNum">     218 </span>            : #if !defined __clz_tab &amp;&amp; !defined UHWtype
<span class="lineNum">     219 </span>            : /* Without this seemingly useless conditional, gcc -Wunused-macros
<span class="lineNum">     220 </span>            :    warns that each of the two tested macros is unused on Fedora 18.
<span class="lineNum">     221 </span>            :    FIXME: this is just an ugly band-aid.  Fix it properly.  */
<span class="lineNum">     222 </span>            : #endif
<span class="lineNum">     223 </span>            : 
<span class="lineNum">     224 </span>            : /* 2*3*5*7*11...*101 is 128 bits, and has 26 prime factors */
<span class="lineNum">     225 </span>            : #define MAX_NFACTS 26
<span class="lineNum">     226 </span>            : 
<span class="lineNum">     227 </span>            : enum
<span class="lineNum">     228 </span>            : {
<span class="lineNum">     229 </span>            :   DEV_DEBUG_OPTION = CHAR_MAX + 1
<span class="lineNum">     230 </span>            : };
<span class="lineNum">     231 </span>            : 
<span class="lineNum">     232 </span>            : static struct option const long_options[] =
<span class="lineNum">     233 </span>            : {
<span class="lineNum">     234 </span>            :   {&quot;-debug&quot;, no_argument, NULL, DEV_DEBUG_OPTION},
<span class="lineNum">     235 </span>            :   {GETOPT_HELP_OPTION_DECL},
<span class="lineNum">     236 </span>            :   {GETOPT_VERSION_OPTION_DECL},
<span class="lineNum">     237 </span>            :   {NULL, 0, NULL, 0}
<span class="lineNum">     238 </span>            : };
<span class="lineNum">     239 </span>            : 
<span class="lineNum">     240 </span>            : struct factors
<span class="lineNum">     241 </span>            : {
<span class="lineNum">     242 </span>            :   uintmax_t     plarge[2]; /* Can have a single large factor */
<span class="lineNum">     243 </span>            :   uintmax_t     p[MAX_NFACTS];
<span class="lineNum">     244 </span>            :   unsigned char e[MAX_NFACTS];
<span class="lineNum">     245 </span>            :   unsigned char nfactors;
<span class="lineNum">     246 </span>            : };
<span class="lineNum">     247 </span>            : 
<span class="lineNum">     248 </span>            : #if HAVE_GMP
<span class="lineNum">     249 </span>            : struct mp_factors
<span class="lineNum">     250 </span>            : {
<span class="lineNum">     251 </span>            :   mpz_t             *p;
<span class="lineNum">     252 </span>            :   unsigned long int *e;
<span class="lineNum">     253 </span>            :   unsigned long int nfactors;
<span class="lineNum">     254 </span>            : };
<span class="lineNum">     255 </span>            : #endif
<span class="lineNum">     256 </span>            : 
<span class="lineNum">     257 </span>            : static void factor (uintmax_t, uintmax_t, struct factors *);
<span class="lineNum">     258 </span>            : 
<span class="lineNum">     259 </span>            : #ifndef umul_ppmm
<span class="lineNum">     260 </span>            : # define umul_ppmm(w1, w0, u, v)                                        \
<span class="lineNum">     261 </span>            :   do {                                                                  \
<span class="lineNum">     262 </span>            :     uintmax_t __x0, __x1, __x2, __x3;                                   \
<span class="lineNum">     263 </span>            :     unsigned long int __ul, __vl, __uh, __vh;                           \
<span class="lineNum">     264 </span>            :     uintmax_t __u = (u), __v = (v);                                     \
<span class="lineNum">     265 </span>            :                                                                         \
<span class="lineNum">     266 </span>            :     __ul = __ll_lowpart (__u);                                          \
<span class="lineNum">     267 </span>            :     __uh = __ll_highpart (__u);                                         \
<span class="lineNum">     268 </span>            :     __vl = __ll_lowpart (__v);                                          \
<span class="lineNum">     269 </span>            :     __vh = __ll_highpart (__v);                                         \
<span class="lineNum">     270 </span>            :                                                                         \
<span class="lineNum">     271 </span>            :     __x0 = (uintmax_t) __ul * __vl;                                     \
<span class="lineNum">     272 </span>            :     __x1 = (uintmax_t) __ul * __vh;                                     \
<span class="lineNum">     273 </span>            :     __x2 = (uintmax_t) __uh * __vl;                                     \
<span class="lineNum">     274 </span>            :     __x3 = (uintmax_t) __uh * __vh;                                     \
<span class="lineNum">     275 </span>            :                                                                         \
<span class="lineNum">     276 </span>            :     __x1 += __ll_highpart (__x0);/* this can't give carry */            \
<span class="lineNum">     277 </span>            :     __x1 += __x2;               /* but this indeed can */               \
<span class="lineNum">     278 </span>            :     if (__x1 &lt; __x2)            /* did we get it? */                    \
<span class="lineNum">     279 </span>            :       __x3 += __ll_B;           /* yes, add it in the proper pos. */    \
<span class="lineNum">     280 </span>            :                                                                         \
<span class="lineNum">     281 </span>            :     (w1) = __x3 + __ll_highpart (__x1);                                 \
<span class="lineNum">     282 </span>            :     (w0) = (__x1 &lt;&lt; W_TYPE_SIZE / 2) + __ll_lowpart (__x0);             \
<span class="lineNum">     283 </span>            :   } while (0)
<span class="lineNum">     284 </span>            : #endif
<span class="lineNum">     285 </span>            : 
<span class="lineNum">     286 </span>            : #if !defined udiv_qrnnd || defined UDIV_NEEDS_NORMALIZATION
<span class="lineNum">     287 </span>            : /* Define our own, not needing normalization. This function is
<span class="lineNum">     288 </span>            :    currently not performance critical, so keep it simple. Similar to
<span class="lineNum">     289 </span>            :    the mod macro below. */
<span class="lineNum">     290 </span>            : # undef udiv_qrnnd
<span class="lineNum">     291 </span>            : # define udiv_qrnnd(q, r, n1, n0, d)                                    \
<span class="lineNum">     292 </span>            :   do {                                                                  \
<span class="lineNum">     293 </span>            :     uintmax_t __d1, __d0, __q, __r1, __r0;                              \
<span class="lineNum">     294 </span>            :                                                                         \
<span class="lineNum">     295 </span>            :     assert ((n1) &lt; (d));                                                \
<span class="lineNum">     296 </span>            :     __d1 = (d); __d0 = 0;                                               \
<span class="lineNum">     297 </span>            :     __r1 = (n1); __r0 = (n0);                                           \
<span class="lineNum">     298 </span>            :     __q = 0;                                                            \
<span class="lineNum">     299 </span>            :     for (unsigned int __i = W_TYPE_SIZE; __i &gt; 0; __i--)                \
<span class="lineNum">     300 </span>            :       {                                                                 \
<span class="lineNum">     301 </span>            :         rsh2 (__d1, __d0, __d1, __d0, 1);                               \
<span class="lineNum">     302 </span>            :         __q &lt;&lt;= 1;                                                      \
<span class="lineNum">     303 </span>            :         if (ge2 (__r1, __r0, __d1, __d0))                               \
<span class="lineNum">     304 </span>            :           {                                                             \
<span class="lineNum">     305 </span>            :             __q++;                                                      \
<span class="lineNum">     306 </span>            :             sub_ddmmss (__r1, __r0, __r1, __r0, __d1, __d0);            \
<span class="lineNum">     307 </span>            :           }                                                             \
<span class="lineNum">     308 </span>            :       }                                                                 \
<span class="lineNum">     309 </span>            :     (r) = __r0;                                                         \
<span class="lineNum">     310 </span>            :     (q) = __q;                                                          \
<span class="lineNum">     311 </span>            :   } while (0)
<span class="lineNum">     312 </span>            : #endif
<span class="lineNum">     313 </span>            : 
<span class="lineNum">     314 </span>            : #if !defined add_ssaaaa
<span class="lineNum">     315 </span>            : # define add_ssaaaa(sh, sl, ah, al, bh, bl)                             \
<span class="lineNum">     316 </span>            :   do {                                                                  \
<span class="lineNum">     317 </span>            :     uintmax_t _add_x;                                                   \
<span class="lineNum">     318 </span>            :     _add_x = (al) + (bl);                                               \
<span class="lineNum">     319 </span>            :     (sh) = (ah) + (bh) + (_add_x &lt; (al));                               \
<span class="lineNum">     320 </span>            :     (sl) = _add_x;                                                      \
<span class="lineNum">     321 </span>            :   } while (0)
<span class="lineNum">     322 </span>            : #endif
<span class="lineNum">     323 </span>            : 
<span class="lineNum">     324 </span>            : #define rsh2(rh, rl, ah, al, cnt)                                       \
<span class="lineNum">     325 </span>            :   do {                                                                  \
<span class="lineNum">     326 </span>            :     (rl) = ((ah) &lt;&lt; (W_TYPE_SIZE - (cnt))) | ((al) &gt;&gt; (cnt));           \
<span class="lineNum">     327 </span>            :     (rh) = (ah) &gt;&gt; (cnt);                                               \
<span class="lineNum">     328 </span>            :   } while (0)
<span class="lineNum">     329 </span>            : 
<span class="lineNum">     330 </span>            : #define lsh2(rh, rl, ah, al, cnt)                                       \
<span class="lineNum">     331 </span>            :   do {                                                                  \
<span class="lineNum">     332 </span>            :     (rh) = ((ah) &lt;&lt; cnt) | ((al) &gt;&gt; (W_TYPE_SIZE - (cnt)));             \
<span class="lineNum">     333 </span>            :     (rl) = (al) &lt;&lt; (cnt);                                               \
<span class="lineNum">     334 </span>            :   } while (0)
<span class="lineNum">     335 </span>            : 
<span class="lineNum">     336 </span>            : #define ge2(ah, al, bh, bl)                                             \
<span class="lineNum">     337 </span>            :   ((ah) &gt; (bh) || ((ah) == (bh) &amp;&amp; (al) &gt;= (bl)))
<span class="lineNum">     338 </span>            : 
<span class="lineNum">     339 </span>            : #define gt2(ah, al, bh, bl)                                             \
<span class="lineNum">     340 </span>            :   ((ah) &gt; (bh) || ((ah) == (bh) &amp;&amp; (al) &gt; (bl)))
<span class="lineNum">     341 </span>            : 
<span class="lineNum">     342 </span>            : #ifndef sub_ddmmss
<span class="lineNum">     343 </span>            : # define sub_ddmmss(rh, rl, ah, al, bh, bl)                             \
<span class="lineNum">     344 </span>            :   do {                                                                  \
<span class="lineNum">     345 </span>            :     uintmax_t _cy;                                                      \
<span class="lineNum">     346 </span>            :     _cy = (al) &lt; (bl);                                                  \
<span class="lineNum">     347 </span>            :     (rl) = (al) - (bl);                                                 \
<span class="lineNum">     348 </span>            :     (rh) = (ah) - (bh) - _cy;                                           \
<span class="lineNum">     349 </span>            :   } while (0)
<span class="lineNum">     350 </span>            : #endif
<span class="lineNum">     351 </span>            : 
<span class="lineNum">     352 </span>            : #ifndef count_leading_zeros
<span class="lineNum">     353 </span>            : # define count_leading_zeros(count, x) do {                             \
<span class="lineNum">     354 </span>            :     uintmax_t __clz_x = (x);                                            \
<span class="lineNum">     355 </span>            :     unsigned int __clz_c;                                               \
<span class="lineNum">     356 </span>            :     for (__clz_c = 0;                                                   \
<span class="lineNum">     357 </span>            :          (__clz_x &amp; ((uintmax_t) 0xff &lt;&lt; (W_TYPE_SIZE - 8))) == 0;      \
<span class="lineNum">     358 </span>            :          __clz_c += 8)                                                  \
<span class="lineNum">     359 </span>            :       __clz_x &lt;&lt;= 8;                                                    \
<span class="lineNum">     360 </span>            :     for (; (intmax_t)__clz_x &gt;= 0; __clz_c++)                           \
<span class="lineNum">     361 </span>            :       __clz_x &lt;&lt;= 1;                                                    \
<span class="lineNum">     362 </span>            :     (count) = __clz_c;                                                  \
<span class="lineNum">     363 </span>            :   } while (0)
<span class="lineNum">     364 </span>            : #endif
<span class="lineNum">     365 </span>            : 
<span class="lineNum">     366 </span>            : #ifndef count_trailing_zeros
<span class="lineNum">     367 </span>            : # define count_trailing_zeros(count, x) do {                            \
<span class="lineNum">     368 </span>            :     uintmax_t __ctz_x = (x);                                            \
<span class="lineNum">     369 </span>            :     unsigned int __ctz_c = 0;                                           \
<span class="lineNum">     370 </span>            :     while ((__ctz_x &amp; 1) == 0)                                          \
<span class="lineNum">     371 </span>            :       {                                                                 \
<span class="lineNum">     372 </span>            :         __ctz_x &gt;&gt;= 1;                                                  \
<span class="lineNum">     373 </span>            :         __ctz_c++;                                                      \
<span class="lineNum">     374 </span>            :       }                                                                 \
<span class="lineNum">     375 </span>            :     (count) = __ctz_c;                                                  \
<span class="lineNum">     376 </span>            :   } while (0)
<span class="lineNum">     377 </span>            : #endif
<span class="lineNum">     378 </span>            : 
<span class="lineNum">     379 </span>            : /* Requires that a &lt; n and b &lt;= n */
<span class="lineNum">     380 </span>            : #define submod(r,a,b,n)                                                 \
<span class="lineNum">     381 </span>            :   do {                                                                  \
<span class="lineNum">     382 </span>            :     uintmax_t _t = - (uintmax_t) (a &lt; b);                               \
<span class="lineNum">     383 </span>            :     (r) = ((n) &amp; _t) + (a) - (b);                                       \
<span class="lineNum">     384 </span>            :   } while (0)
<span class="lineNum">     385 </span>            : 
<span class="lineNum">     386 </span>            : #define addmod(r,a,b,n)                                                 \
<span class="lineNum">     387 </span>            :   submod ((r), (a), ((n) - (b)), (n))
<span class="lineNum">     388 </span>            : 
<span class="lineNum">     389 </span>            : /* Modular two-word addition and subtraction.  For performance reasons, the
<span class="lineNum">     390 </span>            :    most significant bit of n1 must be clear.  The destination variables must be
<span class="lineNum">     391 </span>            :    distinct from the mod operand.  */
<span class="lineNum">     392 </span>            : #define addmod2(r1, r0, a1, a0, b1, b0, n1, n0)                         \
<span class="lineNum">     393 </span>            :   do {                                                                  \
<span class="lineNum">     394 </span>            :     add_ssaaaa ((r1), (r0), (a1), (a0), (b1), (b0));                    \
<span class="lineNum">     395 </span>            :     if (ge2 ((r1), (r0), (n1), (n0)))                                   \
<span class="lineNum">     396 </span>            :       sub_ddmmss ((r1), (r0), (r1), (r0), (n1), (n0));                  \
<span class="lineNum">     397 </span>            :   } while (0)
<span class="lineNum">     398 </span>            : #define submod2(r1, r0, a1, a0, b1, b0, n1, n0)                         \
<span class="lineNum">     399 </span>            :   do {                                                                  \
<span class="lineNum">     400 </span>            :     sub_ddmmss ((r1), (r0), (a1), (a0), (b1), (b0));                    \
<span class="lineNum">     401 </span>            :     if ((intmax_t) (r1) &lt; 0)                                            \
<span class="lineNum">     402 </span>            :       add_ssaaaa ((r1), (r0), (r1), (r0), (n1), (n0));                  \
<span class="lineNum">     403 </span>            :   } while (0)
<span class="lineNum">     404 </span>            : 
<span class="lineNum">     405 </span>            : #define HIGHBIT_TO_MASK(x)                                              \
<span class="lineNum">     406 </span>            :   (((intmax_t)-1 &gt;&gt; 1) &lt; 0                                              \
<span class="lineNum">     407 </span>            :    ? (uintmax_t)((intmax_t)(x) &gt;&gt; (W_TYPE_SIZE - 1))                    \
<span class="lineNum">     408 </span>            :    : ((x) &amp; ((uintmax_t) 1 &lt;&lt; (W_TYPE_SIZE - 1))                        \
<span class="lineNum">     409 </span>            :       ? UINTMAX_MAX : (uintmax_t) 0))
<span class="lineNum">     410 </span>            : 
<span class="lineNum">     411 </span>            : /* Compute r = a mod d, where r = &lt;*t1,retval&gt;, a = &lt;a1,a0&gt;, d = &lt;d1,d0&gt;.
<a name="412"><span class="lineNum">     412 </span>            :    Requires that d1 != 0.  */</a>
<span class="lineNum">     413 </span>            : static uintmax_t
<span class="lineNum">     414 </span><span class="lineNoCov">          0 : mod2 (uintmax_t *r1, uintmax_t a1, uintmax_t a0, uintmax_t d1, uintmax_t d0)</span>
<span class="lineNum">     415 </span>            : {
<span class="lineNum">     416 </span>            :   int cntd, cnta;
<span class="lineNum">     417 </span>            : 
<span class="lineNum">     418 </span><span class="lineNoCov">          0 :   assert (d1 != 0);</span>
<span class="lineNum">     419 </span>            : 
<span class="lineNum">     420 </span><span class="lineNoCov">          0 :   if (a1 == 0)</span>
<span class="lineNum">     421 </span>            :     {
<span class="lineNum">     422 </span><span class="lineNoCov">          0 :       *r1 = 0;</span>
<span class="lineNum">     423 </span><span class="lineNoCov">          0 :       return a0;</span>
<span class="lineNum">     424 </span>            :     }
<span class="lineNum">     425 </span>            : 
<span class="lineNum">     426 </span><span class="lineNoCov">          0 :   count_leading_zeros (cntd, d1);</span>
<span class="lineNum">     427 </span><span class="lineNoCov">          0 :   count_leading_zeros (cnta, a1);</span>
<span class="lineNum">     428 </span><span class="lineNoCov">          0 :   int cnt = cntd - cnta;</span>
<span class="lineNum">     429 </span><span class="lineNoCov">          0 :   lsh2 (d1, d0, d1, d0, cnt);</span>
<span class="lineNum">     430 </span><span class="lineNoCov">          0 :   for (int i = 0; i &lt; cnt; i++)</span>
<span class="lineNum">     431 </span>            :     {
<span class="lineNum">     432 </span><span class="lineNoCov">          0 :       if (ge2 (a1, a0, d1, d0))</span>
<span class="lineNum">     433 </span><span class="lineNoCov">          0 :         sub_ddmmss (a1, a0, a1, a0, d1, d0);</span>
<span class="lineNum">     434 </span><span class="lineNoCov">          0 :       rsh2 (d1, d0, d1, d0, 1);</span>
<span class="lineNum">     435 </span>            :     }
<span class="lineNum">     436 </span>            : 
<span class="lineNum">     437 </span><span class="lineNoCov">          0 :   *r1 = a1;</span>
<span class="lineNum">     438 </span><span class="lineNoCov">          0 :   return a0;</span>
<span class="lineNum">     439 </span>            : }
<a name="440"><span class="lineNum">     440 </span>            : </a>
<span class="lineNum">     441 </span>            : static uintmax_t _GL_ATTRIBUTE_CONST
<span class="lineNum">     442 </span><span class="lineNoCov">          0 : gcd_odd (uintmax_t a, uintmax_t b)</span>
<span class="lineNum">     443 </span>            : {
<span class="lineNum">     444 </span><span class="lineNoCov">          0 :   if ( (b &amp; 1) == 0)</span>
<span class="lineNum">     445 </span>            :     {
<span class="lineNum">     446 </span><span class="lineNoCov">          0 :       uintmax_t t = b;</span>
<span class="lineNum">     447 </span><span class="lineNoCov">          0 :       b = a;</span>
<span class="lineNum">     448 </span><span class="lineNoCov">          0 :       a = t;</span>
<span class="lineNum">     449 </span>            :     }
<span class="lineNum">     450 </span><span class="lineNoCov">          0 :   if (a == 0)</span>
<span class="lineNum">     451 </span>            :     return b;
<span class="lineNum">     452 </span>            : 
<span class="lineNum">     453 </span>            :   /* Take out least significant one bit, to make room for sign */
<span class="lineNum">     454 </span><span class="lineNoCov">          0 :   b &gt;&gt;= 1;</span>
<span class="lineNum">     455 </span>            : 
<span class="lineNum">     456 </span>            :   for (;;)
<span class="lineNum">     457 </span>            :     {
<span class="lineNum">     458 </span>            :       uintmax_t t;
<span class="lineNum">     459 </span>            :       uintmax_t bgta;
<span class="lineNum">     460 </span>            : 
<span class="lineNum">     461 </span><span class="lineNoCov">          0 :       while ((a &amp; 1) == 0)</span>
<span class="lineNum">     462 </span><span class="lineNoCov">          0 :         a &gt;&gt;= 1;</span>
<span class="lineNum">     463 </span><span class="lineNoCov">          0 :       a &gt;&gt;= 1;</span>
<span class="lineNum">     464 </span>            : 
<span class="lineNum">     465 </span><span class="lineNoCov">          0 :       t = a - b;</span>
<span class="lineNum">     466 </span><span class="lineNoCov">          0 :       if (t == 0)</span>
<span class="lineNum">     467 </span><span class="lineNoCov">          0 :         return (a &lt;&lt; 1) + 1;</span>
<span class="lineNum">     468 </span>            : 
<span class="lineNum">     469 </span><span class="lineNoCov">          0 :       bgta = HIGHBIT_TO_MASK (t);</span>
<span class="lineNum">     470 </span>            : 
<span class="lineNum">     471 </span>            :       /* b &lt;-- min (a, b) */
<span class="lineNum">     472 </span><span class="lineNoCov">          0 :       b += (bgta &amp; t);</span>
<span class="lineNum">     473 </span>            : 
<span class="lineNum">     474 </span>            :       /* a &lt;-- |a - b| */
<span class="lineNum">     475 </span><span class="lineNoCov">          0 :       a = (t ^ bgta) - bgta;</span>
<span class="lineNum">     476 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">     477 </span>            : }
<a name="478"><span class="lineNum">     478 </span>            : </a>
<span class="lineNum">     479 </span>            : static uintmax_t
<span class="lineNum">     480 </span><span class="lineNoCov">          0 : gcd2_odd (uintmax_t *r1, uintmax_t a1, uintmax_t a0, uintmax_t b1, uintmax_t b0)</span>
<span class="lineNum">     481 </span>            : {
<span class="lineNum">     482 </span><span class="lineNoCov">          0 :   while ((a0 &amp; 1) == 0)</span>
<span class="lineNum">     483 </span><span class="lineNoCov">          0 :     rsh2 (a1, a0, a1, a0, 1);</span>
<span class="lineNum">     484 </span><span class="lineNoCov">          0 :   while ((b0 &amp; 1) == 0)</span>
<span class="lineNum">     485 </span><span class="lineNoCov">          0 :     rsh2 (b1, b0, b1, b0, 1);</span>
<span class="lineNum">     486 </span>            : 
<span class="lineNum">     487 </span>            :   for (;;)
<span class="lineNum">     488 </span>            :     {
<span class="lineNum">     489 </span><span class="lineNoCov">          0 :       if ((b1 | a1) == 0)</span>
<span class="lineNum">     490 </span>            :         {
<span class="lineNum">     491 </span><span class="lineNoCov">          0 :           *r1 = 0;</span>
<span class="lineNum">     492 </span><span class="lineNoCov">          0 :           return gcd_odd (b0, a0);</span>
<span class="lineNum">     493 </span>            :         }
<span class="lineNum">     494 </span>            : 
<span class="lineNum">     495 </span><span class="lineNoCov">          0 :       if (gt2 (a1, a0, b1, b0))</span>
<span class="lineNum">     496 </span>            :         {
<span class="lineNum">     497 </span><span class="lineNoCov">          0 :           sub_ddmmss (a1, a0, a1, a0, b1, b0);</span>
<span class="lineNum">     498 </span>            :           do
<span class="lineNum">     499 </span><span class="lineNoCov">          0 :             rsh2 (a1, a0, a1, a0, 1);</span>
<span class="lineNum">     500 </span><span class="lineNoCov">          0 :           while ((a0 &amp; 1) == 0);</span>
<span class="lineNum">     501 </span>            :         }
<span class="lineNum">     502 </span><span class="lineNoCov">          0 :       else if (gt2 (b1, b0, a1, a0))</span>
<span class="lineNum">     503 </span>            :         {
<span class="lineNum">     504 </span><span class="lineNoCov">          0 :           sub_ddmmss (b1, b0, b1, b0, a1, a0);</span>
<span class="lineNum">     505 </span>            :           do
<span class="lineNum">     506 </span><span class="lineNoCov">          0 :             rsh2 (b1, b0, b1, b0, 1);</span>
<span class="lineNum">     507 </span><span class="lineNoCov">          0 :           while ((b0 &amp; 1) == 0);</span>
<span class="lineNum">     508 </span>            :         }
<span class="lineNum">     509 </span>            :       else
<span class="lineNum">     510 </span>            :         break;
<span class="lineNum">     511 </span>            :     }
<span class="lineNum">     512 </span>            : 
<span class="lineNum">     513 </span><span class="lineNoCov">          0 :   *r1 = a1;</span>
<span class="lineNum">     514 </span><span class="lineNoCov">          0 :   return a0;</span>
<span class="lineNum">     515 </span>            : }
<a name="516"><span class="lineNum">     516 </span>            : </a>
<span class="lineNum">     517 </span>            : static void
<span class="lineNum">     518 </span><span class="lineNoCov">          0 : factor_insert_multiplicity (struct factors *factors,</span>
<span class="lineNum">     519 </span>            :                             uintmax_t prime, unsigned int m)
<span class="lineNum">     520 </span>            : {
<span class="lineNum">     521 </span><span class="lineNoCov">          0 :   unsigned int nfactors = factors-&gt;nfactors;</span>
<span class="lineNum">     522 </span><span class="lineNoCov">          0 :   uintmax_t *p = factors-&gt;p;</span>
<span class="lineNum">     523 </span><span class="lineNoCov">          0 :   unsigned char *e = factors-&gt;e;</span>
<span class="lineNum">     524 </span>            : 
<span class="lineNum">     525 </span>            :   /* Locate position for insert new or increment e.  */
<span class="lineNum">     526 </span>            :   int i;
<span class="lineNum">     527 </span><span class="lineNoCov">          0 :   for (i = nfactors - 1; i &gt;= 0; i--)</span>
<span class="lineNum">     528 </span>            :     {
<span class="lineNum">     529 </span><span class="lineNoCov">          0 :       if (p[i] &lt;= prime)</span>
<span class="lineNum">     530 </span>            :         break;
<span class="lineNum">     531 </span>            :     }
<span class="lineNum">     532 </span>            : 
<span class="lineNum">     533 </span><span class="lineNoCov">          0 :   if (i &lt; 0 || p[i] != prime)</span>
<span class="lineNum">     534 </span>            :     {
<span class="lineNum">     535 </span><span class="lineNoCov">          0 :       for (int j = nfactors - 1; j &gt; i; j--)</span>
<span class="lineNum">     536 </span>            :         {
<span class="lineNum">     537 </span><span class="lineNoCov">          0 :           p[j + 1] = p[j];</span>
<span class="lineNum">     538 </span><span class="lineNoCov">          0 :           e[j + 1] = e[j];</span>
<span class="lineNum">     539 </span>            :         }
<span class="lineNum">     540 </span><span class="lineNoCov">          0 :       p[i + 1] = prime;</span>
<span class="lineNum">     541 </span><span class="lineNoCov">          0 :       e[i + 1] = m;</span>
<span class="lineNum">     542 </span><span class="lineNoCov">          0 :       factors-&gt;nfactors = nfactors + 1;</span>
<span class="lineNum">     543 </span>            :     }
<span class="lineNum">     544 </span>            :   else
<span class="lineNum">     545 </span>            :     {
<span class="lineNum">     546 </span><span class="lineNoCov">          0 :       e[i] += m;</span>
<span class="lineNum">     547 </span>            :     }
<span class="lineNum">     548 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     549 </span>            : 
<span class="lineNum">     550 </span>            : #define factor_insert(f, p) factor_insert_multiplicity (f, p, 1)
<a name="551"><span class="lineNum">     551 </span>            : </a>
<span class="lineNum">     552 </span>            : static void
<span class="lineNum">     553 </span><span class="lineNoCov">          0 : factor_insert_large (struct factors *factors,</span>
<span class="lineNum">     554 </span>            :                      uintmax_t p1, uintmax_t p0)
<span class="lineNum">     555 </span>            : {
<span class="lineNum">     556 </span><span class="lineNoCov">          0 :   if (p1 &gt; 0)</span>
<span class="lineNum">     557 </span>            :     {
<span class="lineNum">     558 </span><span class="lineNoCov">          0 :       assert (factors-&gt;plarge[1] == 0);</span>
<span class="lineNum">     559 </span><span class="lineNoCov">          0 :       factors-&gt;plarge[0] = p0;</span>
<span class="lineNum">     560 </span><span class="lineNoCov">          0 :       factors-&gt;plarge[1] = p1;</span>
<span class="lineNum">     561 </span>            :     }
<span class="lineNum">     562 </span>            :   else
<span class="lineNum">     563 </span><span class="lineNoCov">          0 :     factor_insert (factors, p0);</span>
<span class="lineNum">     564 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     565 </span>            : 
<span class="lineNum">     566 </span>            : #if HAVE_GMP
<span class="lineNum">     567 </span>            : 
<span class="lineNum">     568 </span>            : # if !HAVE_DECL_MPZ_INITS
<span class="lineNum">     569 </span>            : 
<span class="lineNum">     570 </span>            : #  define mpz_inits(...) mpz_va_init (mpz_init, __VA_ARGS__)
<span class="lineNum">     571 </span>            : #  define mpz_clears(...) mpz_va_init (mpz_clear, __VA_ARGS__)
<span class="lineNum">     572 </span>            : 
<span class="lineNum">     573 </span>            : static void
<span class="lineNum">     574 </span>            : mpz_va_init (void (*mpz_single_init)(mpz_t), ...)
<span class="lineNum">     575 </span>            : {
<span class="lineNum">     576 </span>            :   va_list ap;
<span class="lineNum">     577 </span>            : 
<span class="lineNum">     578 </span>            :   va_start (ap, mpz_single_init);
<span class="lineNum">     579 </span>            : 
<span class="lineNum">     580 </span>            :   mpz_t *mpz;
<span class="lineNum">     581 </span>            :   while ((mpz = va_arg (ap, mpz_t *)))
<span class="lineNum">     582 </span>            :     mpz_single_init (*mpz);
<span class="lineNum">     583 </span>            : 
<span class="lineNum">     584 </span>            :   va_end (ap);
<span class="lineNum">     585 </span>            : }
<span class="lineNum">     586 </span>            : # endif
<span class="lineNum">     587 </span>            : 
<span class="lineNum">     588 </span>            : static void mp_factor (mpz_t, struct mp_factors *);
<span class="lineNum">     589 </span>            : 
<span class="lineNum">     590 </span>            : static void
<span class="lineNum">     591 </span>            : mp_factor_init (struct mp_factors *factors)
<span class="lineNum">     592 </span>            : {
<span class="lineNum">     593 </span>            :   factors-&gt;p = NULL;
<span class="lineNum">     594 </span>            :   factors-&gt;e = NULL;
<span class="lineNum">     595 </span>            :   factors-&gt;nfactors = 0;
<span class="lineNum">     596 </span>            : }
<span class="lineNum">     597 </span>            : 
<span class="lineNum">     598 </span>            : static void
<span class="lineNum">     599 </span>            : mp_factor_clear (struct mp_factors *factors)
<span class="lineNum">     600 </span>            : {
<span class="lineNum">     601 </span>            :   for (unsigned int i = 0; i &lt; factors-&gt;nfactors; i++)
<span class="lineNum">     602 </span>            :     mpz_clear (factors-&gt;p[i]);
<span class="lineNum">     603 </span>            : 
<span class="lineNum">     604 </span>            :   free (factors-&gt;p);
<span class="lineNum">     605 </span>            :   free (factors-&gt;e);
<span class="lineNum">     606 </span>            : }
<span class="lineNum">     607 </span>            : 
<span class="lineNum">     608 </span>            : static void
<span class="lineNum">     609 </span>            : mp_factor_insert (struct mp_factors *factors, mpz_t prime)
<span class="lineNum">     610 </span>            : {
<span class="lineNum">     611 </span>            :   unsigned long int nfactors = factors-&gt;nfactors;
<span class="lineNum">     612 </span>            :   mpz_t         *p  = factors-&gt;p;
<span class="lineNum">     613 </span>            :   unsigned long int *e  = factors-&gt;e;
<span class="lineNum">     614 </span>            :   long i;
<span class="lineNum">     615 </span>            : 
<span class="lineNum">     616 </span>            :   /* Locate position for insert new or increment e.  */
<span class="lineNum">     617 </span>            :   for (i = nfactors - 1; i &gt;= 0; i--)
<span class="lineNum">     618 </span>            :     {
<span class="lineNum">     619 </span>            :       if (mpz_cmp (p[i], prime) &lt;= 0)
<span class="lineNum">     620 </span>            :         break;
<span class="lineNum">     621 </span>            :     }
<span class="lineNum">     622 </span>            : 
<span class="lineNum">     623 </span>            :   if (i &lt; 0 || mpz_cmp (p[i], prime) != 0)
<span class="lineNum">     624 </span>            :     {
<span class="lineNum">     625 </span>            :       p = xrealloc (p, (nfactors + 1) * sizeof p[0]);
<span class="lineNum">     626 </span>            :       e = xrealloc (e, (nfactors + 1) * sizeof e[0]);
<span class="lineNum">     627 </span>            : 
<span class="lineNum">     628 </span>            :       mpz_init (p[nfactors]);
<span class="lineNum">     629 </span>            :       for (long j = nfactors - 1; j &gt; i; j--)
<span class="lineNum">     630 </span>            :         {
<span class="lineNum">     631 </span>            :           mpz_set (p[j + 1], p[j]);
<span class="lineNum">     632 </span>            :           e[j + 1] = e[j];
<span class="lineNum">     633 </span>            :         }
<span class="lineNum">     634 </span>            :       mpz_set (p[i + 1], prime);
<span class="lineNum">     635 </span>            :       e[i + 1] = 1;
<span class="lineNum">     636 </span>            : 
<span class="lineNum">     637 </span>            :       factors-&gt;p = p;
<span class="lineNum">     638 </span>            :       factors-&gt;e = e;
<span class="lineNum">     639 </span>            :       factors-&gt;nfactors = nfactors + 1;
<span class="lineNum">     640 </span>            :     }
<span class="lineNum">     641 </span>            :   else
<span class="lineNum">     642 </span>            :     {
<span class="lineNum">     643 </span>            :       e[i] += 1;
<span class="lineNum">     644 </span>            :     }
<span class="lineNum">     645 </span>            : }
<span class="lineNum">     646 </span>            : 
<span class="lineNum">     647 </span>            : static void
<span class="lineNum">     648 </span>            : mp_factor_insert_ui (struct mp_factors *factors, unsigned long int prime)
<span class="lineNum">     649 </span>            : {
<span class="lineNum">     650 </span>            :   mpz_t pz;
<span class="lineNum">     651 </span>            : 
<span class="lineNum">     652 </span>            :   mpz_init_set_ui (pz, prime);
<span class="lineNum">     653 </span>            :   mp_factor_insert (factors, pz);
<span class="lineNum">     654 </span>            :   mpz_clear (pz);
<span class="lineNum">     655 </span>            : }
<span class="lineNum">     656 </span>            : #endif /* HAVE_GMP */
<span class="lineNum">     657 </span>            : 
<span class="lineNum">     658 </span>            : 
<span class="lineNum">     659 </span>            : /* Number of bits in an uintmax_t.  */
<span class="lineNum">     660 </span>            : enum { W = sizeof (uintmax_t) * CHAR_BIT };
<span class="lineNum">     661 </span>            : 
<span class="lineNum">     662 </span>            : /* Verify that uintmax_t does not have holes in its representation.  */
<span class="lineNum">     663 </span>            : verify (UINTMAX_MAX &gt;&gt; (W - 1) == 1);
<span class="lineNum">     664 </span>            : 
<span class="lineNum">     665 </span>            : #define P(a,b,c,d) a,
<span class="lineNum">     666 </span>            : static const unsigned char primes_diff[] = {
<span class="lineNum">     667 </span>            : #include &quot;primes.h&quot;
<span class="lineNum">     668 </span>            : 0,0,0,0,0,0,0                           /* 7 sentinels for 8-way loop */
<span class="lineNum">     669 </span>            : };
<span class="lineNum">     670 </span>            : #undef P
<span class="lineNum">     671 </span>            : 
<span class="lineNum">     672 </span>            : #define PRIMES_PTAB_ENTRIES \
<span class="lineNum">     673 </span>            :   (sizeof (primes_diff) / sizeof (primes_diff[0]) - 8 + 1)
<span class="lineNum">     674 </span>            : 
<span class="lineNum">     675 </span>            : #define P(a,b,c,d) b,
<span class="lineNum">     676 </span>            : static const unsigned char primes_diff8[] = {
<span class="lineNum">     677 </span>            : #include &quot;primes.h&quot;
<span class="lineNum">     678 </span>            : 0,0,0,0,0,0,0                           /* 7 sentinels for 8-way loop */
<span class="lineNum">     679 </span>            : };
<span class="lineNum">     680 </span>            : #undef P
<span class="lineNum">     681 </span>            : 
<span class="lineNum">     682 </span>            : struct primes_dtab
<span class="lineNum">     683 </span>            : {
<span class="lineNum">     684 </span>            :   uintmax_t binv, lim;
<span class="lineNum">     685 </span>            : };
<span class="lineNum">     686 </span>            : 
<span class="lineNum">     687 </span>            : #define P(a,b,c,d) {c,d},
<span class="lineNum">     688 </span>            : static const struct primes_dtab primes_dtab[] = {
<span class="lineNum">     689 </span>            : #include &quot;primes.h&quot;
<span class="lineNum">     690 </span>            : {1,0},{1,0},{1,0},{1,0},{1,0},{1,0},{1,0} /* 7 sentinels for 8-way loop */
<span class="lineNum">     691 </span>            : };
<span class="lineNum">     692 </span>            : #undef P
<span class="lineNum">     693 </span>            : 
<span class="lineNum">     694 </span>            : /* Verify that uintmax_t is not wider than
<span class="lineNum">     695 </span>            :    the integers used to generate primes.h.  */
<span class="lineNum">     696 </span>            : verify (W &lt;= WIDE_UINT_BITS);
<span class="lineNum">     697 </span>            : 
<span class="lineNum">     698 </span>            : /* debugging for developers.  Enables devmsg().
<span class="lineNum">     699 </span>            :    This flag is used only in the GMP code.  */
<span class="lineNum">     700 </span>            : static bool dev_debug = false;
<span class="lineNum">     701 </span>            : 
<span class="lineNum">     702 </span>            : /* Prove primality or run probabilistic tests.  */
<span class="lineNum">     703 </span>            : static bool flag_prove_primality = PROVE_PRIMALITY;
<span class="lineNum">     704 </span>            : 
<span class="lineNum">     705 </span>            : /* Number of Miller-Rabin tests to run when not proving primality. */
<span class="lineNum">     706 </span>            : #define MR_REPS 25
<span class="lineNum">     707 </span>            : 
<span class="lineNum">     708 </span>            : static void
<span class="lineNum">     709 </span>            : factor_insert_refind (struct factors *factors, uintmax_t p, unsigned int i,
<span class="lineNum">     710 </span>            :                       unsigned int off)
<span class="lineNum">     711 </span>            : {
<span class="lineNum">     712 </span><span class="lineNoCov">          0 :   for (unsigned int j = 0; j &lt; off; j++)</span>
<span class="lineNum">     713 </span><span class="lineNoCov">          0 :     p += primes_diff[i + j];</span>
<span class="lineNum">     714 </span><span class="lineNoCov">          0 :   factor_insert (factors, p);</span>
<span class="lineNum">     715 </span>            : }
<span class="lineNum">     716 </span>            : 
<span class="lineNum">     717 </span>            : /* Trial division with odd primes uses the following trick.
<span class="lineNum">     718 </span>            : 
<span class="lineNum">     719 </span>            :    Let p be an odd prime, and B = 2^{W_TYPE_SIZE}. For simplicity,
<span class="lineNum">     720 </span>            :    consider the case t &lt; B (this is the second loop below).
<span class="lineNum">     721 </span>            : 
<span class="lineNum">     722 </span>            :    From our tables we get
<span class="lineNum">     723 </span>            : 
<span class="lineNum">     724 </span>            :      binv = p^{-1} (mod B)
<span class="lineNum">     725 </span>            :      lim = floor ( (B-1) / p ).
<span class="lineNum">     726 </span>            : 
<span class="lineNum">     727 </span>            :    First assume that t is a multiple of p, t = q * p. Then 0 &lt;= q &lt;= lim
<span class="lineNum">     728 </span>            :    (and all quotients in this range occur for some t).
<span class="lineNum">     729 </span>            : 
<span class="lineNum">     730 </span>            :    Then t = q * p is true also (mod B), and p is invertible we get
<span class="lineNum">     731 </span>            : 
<span class="lineNum">     732 </span>            :      q = t * binv (mod B).
<span class="lineNum">     733 </span>            : 
<span class="lineNum">     734 </span>            :    Next, assume that t is *not* divisible by p. Since multiplication
<span class="lineNum">     735 </span>            :    by binv (mod B) is a one-to-one mapping,
<span class="lineNum">     736 </span>            : 
<span class="lineNum">     737 </span>            :      t * binv (mod B) &gt; lim,
<span class="lineNum">     738 </span>            : 
<span class="lineNum">     739 </span>            :    because all the smaller values are already taken.
<span class="lineNum">     740 </span>            : 
<span class="lineNum">     741 </span>            :    This can be summed up by saying that the function
<span class="lineNum">     742 </span>            : 
<span class="lineNum">     743 </span>            :      q(t) = binv * t (mod B)
<span class="lineNum">     744 </span>            : 
<span class="lineNum">     745 </span>            :    is a permutation of the range 0 &lt;= t &lt; B, with the curious property
<span class="lineNum">     746 </span>            :    that it maps the multiples of p onto the range 0 &lt;= q &lt;= lim, in
<span class="lineNum">     747 </span>            :    order, and the non-multiples of p onto the range lim &lt; q &lt; B.
<span class="lineNum">     748 </span>            :  */
<a name="749"><span class="lineNum">     749 </span>            : </a>
<span class="lineNum">     750 </span>            : static uintmax_t
<span class="lineNum">     751 </span><span class="lineNoCov">          0 : factor_using_division (uintmax_t *t1p, uintmax_t t1, uintmax_t t0,</span>
<span class="lineNum">     752 </span>            :                        struct factors *factors)
<span class="lineNum">     753 </span>            : {
<span class="lineNum">     754 </span><span class="lineNoCov">          0 :   if (t0 % 2 == 0)</span>
<span class="lineNum">     755 </span>            :     {
<span class="lineNum">     756 </span>            :       unsigned int cnt;
<span class="lineNum">     757 </span>            : 
<span class="lineNum">     758 </span><span class="lineNoCov">          0 :       if (t0 == 0)</span>
<span class="lineNum">     759 </span>            :         {
<span class="lineNum">     760 </span><span class="lineNoCov">          0 :           count_trailing_zeros (cnt, t1);</span>
<span class="lineNum">     761 </span><span class="lineNoCov">          0 :           t0 = t1 &gt;&gt; cnt;</span>
<span class="lineNum">     762 </span><span class="lineNoCov">          0 :           t1 = 0;</span>
<span class="lineNum">     763 </span><span class="lineNoCov">          0 :           cnt += W_TYPE_SIZE;</span>
<span class="lineNum">     764 </span>            :         }
<span class="lineNum">     765 </span>            :       else
<span class="lineNum">     766 </span>            :         {
<span class="lineNum">     767 </span><span class="lineNoCov">          0 :           count_trailing_zeros (cnt, t0);</span>
<span class="lineNum">     768 </span><span class="lineNoCov">          0 :           rsh2 (t1, t0, t1, t0, cnt);</span>
<span class="lineNum">     769 </span>            :         }
<span class="lineNum">     770 </span>            : 
<span class="lineNum">     771 </span><span class="lineNoCov">          0 :       factor_insert_multiplicity (factors, 2, cnt);</span>
<span class="lineNum">     772 </span>            :     }
<span class="lineNum">     773 </span>            : 
<span class="lineNum">     774 </span>            :   uintmax_t p = 3;
<span class="lineNum">     775 </span>            :   unsigned int i;
<span class="lineNum">     776 </span><span class="lineNoCov">          0 :   for (i = 0; t1 &gt; 0 &amp;&amp; i &lt; PRIMES_PTAB_ENTRIES; i++)</span>
<span class="lineNum">     777 </span>            :     {
<span class="lineNum">     778 </span>            :       for (;;)
<span class="lineNum">     779 </span>            :         {
<span class="lineNum">     780 </span>            :           uintmax_t q1, q0, hi, lo _GL_UNUSED;
<span class="lineNum">     781 </span>            : 
<span class="lineNum">     782 </span><span class="lineNoCov">          0 :           q0 = t0 * primes_dtab[i].binv;</span>
<span class="lineNum">     783 </span><span class="lineNoCov">          0 :           umul_ppmm (hi, lo, q0, p);</span>
<span class="lineNum">     784 </span><span class="lineNoCov">          0 :           if (hi &gt; t1)</span>
<span class="lineNum">     785 </span>            :             break;
<span class="lineNum">     786 </span><span class="lineNoCov">          0 :           hi = t1 - hi;</span>
<span class="lineNum">     787 </span><span class="lineNoCov">          0 :           q1 = hi * primes_dtab[i].binv;</span>
<span class="lineNum">     788 </span><span class="lineNoCov">          0 :           if (LIKELY (q1 &gt; primes_dtab[i].lim))</span>
<span class="lineNum">     789 </span>            :             break;
<span class="lineNum">     790 </span><span class="lineNoCov">          0 :           t1 = q1; t0 = q0;</span>
<span class="lineNum">     791 </span><span class="lineNoCov">          0 :           factor_insert (factors, p);</span>
<span class="lineNum">     792 </span><span class="lineNoCov">          0 :         }</span>
<span class="lineNum">     793 </span><span class="lineNoCov">          0 :       p += primes_diff[i + 1];</span>
<span class="lineNum">     794 </span>            :     }
<span class="lineNum">     795 </span><span class="lineNoCov">          0 :   if (t1p)</span>
<span class="lineNum">     796 </span><span class="lineNoCov">          0 :     *t1p = t1;</span>
<span class="lineNum">     797 </span>            : 
<span class="lineNum">     798 </span>            : #define DIVBLOCK(I)                                                     \
<span class="lineNum">     799 </span>            :   do {                                                                  \
<span class="lineNum">     800 </span>            :     for (;;)                                                            \
<span class="lineNum">     801 </span>            :       {                                                                 \
<span class="lineNum">     802 </span>            :         q = t0 * pd[I].binv;                                            \
<span class="lineNum">     803 </span>            :         if (LIKELY (q &gt; pd[I].lim))                                     \
<span class="lineNum">     804 </span>            :           break;                                                        \
<span class="lineNum">     805 </span>            :         t0 = q;                                                         \
<span class="lineNum">     806 </span>            :         factor_insert_refind (factors, p, i + 1, I);                    \
<span class="lineNum">     807 </span>            :       }                                                                 \
<span class="lineNum">     808 </span>            :   } while (0)
<span class="lineNum">     809 </span>            : 
<span class="lineNum">     810 </span><span class="lineNoCov">          0 :   for (; i &lt; PRIMES_PTAB_ENTRIES; i += 8)</span>
<span class="lineNum">     811 </span>            :     {
<span class="lineNum">     812 </span>            :       uintmax_t q;
<span class="lineNum">     813 </span><span class="lineNoCov">          0 :       const struct primes_dtab *pd = &amp;primes_dtab[i];</span>
<span class="lineNum">     814 </span><span class="lineNoCov">          0 :       DIVBLOCK (0);</span>
<span class="lineNum">     815 </span><span class="lineNoCov">          0 :       DIVBLOCK (1);</span>
<span class="lineNum">     816 </span><span class="lineNoCov">          0 :       DIVBLOCK (2);</span>
<span class="lineNum">     817 </span><span class="lineNoCov">          0 :       DIVBLOCK (3);</span>
<span class="lineNum">     818 </span><span class="lineNoCov">          0 :       DIVBLOCK (4);</span>
<span class="lineNum">     819 </span><span class="lineNoCov">          0 :       DIVBLOCK (5);</span>
<span class="lineNum">     820 </span><span class="lineNoCov">          0 :       DIVBLOCK (6);</span>
<span class="lineNum">     821 </span><span class="lineNoCov">          0 :       DIVBLOCK (7);</span>
<span class="lineNum">     822 </span>            : 
<span class="lineNum">     823 </span><span class="lineNoCov">          0 :       p += primes_diff8[i];</span>
<span class="lineNum">     824 </span><span class="lineNoCov">          0 :       if (p * p &gt; t0)</span>
<span class="lineNum">     825 </span>            :         break;
<span class="lineNum">     826 </span>            :     }
<span class="lineNum">     827 </span>            : 
<span class="lineNum">     828 </span><span class="lineNoCov">          0 :   return t0;</span>
<span class="lineNum">     829 </span>            : }
<span class="lineNum">     830 </span>            : 
<span class="lineNum">     831 </span>            : #if HAVE_GMP
<span class="lineNum">     832 </span>            : static void
<span class="lineNum">     833 </span>            : mp_factor_using_division (mpz_t t, struct mp_factors *factors)
<span class="lineNum">     834 </span>            : {
<span class="lineNum">     835 </span>            :   mpz_t q;
<span class="lineNum">     836 </span>            :   unsigned long int p;
<span class="lineNum">     837 </span>            : 
<span class="lineNum">     838 </span>            :   devmsg (&quot;[trial division] &quot;);
<span class="lineNum">     839 </span>            : 
<span class="lineNum">     840 </span>            :   mpz_init (q);
<span class="lineNum">     841 </span>            : 
<span class="lineNum">     842 </span>            :   p = mpz_scan1 (t, 0);
<span class="lineNum">     843 </span>            :   mpz_div_2exp (t, t, p);
<span class="lineNum">     844 </span>            :   while (p)
<span class="lineNum">     845 </span>            :     {
<span class="lineNum">     846 </span>            :       mp_factor_insert_ui (factors, 2);
<span class="lineNum">     847 </span>            :       --p;
<span class="lineNum">     848 </span>            :     }
<span class="lineNum">     849 </span>            : 
<span class="lineNum">     850 </span>            :   p = 3;
<span class="lineNum">     851 </span>            :   for (unsigned int i = 1; i &lt;= PRIMES_PTAB_ENTRIES;)
<span class="lineNum">     852 </span>            :     {
<span class="lineNum">     853 </span>            :       if (! mpz_divisible_ui_p (t, p))
<span class="lineNum">     854 </span>            :         {
<span class="lineNum">     855 </span>            :           p += primes_diff[i++];
<span class="lineNum">     856 </span>            :           if (mpz_cmp_ui (t, p * p) &lt; 0)
<span class="lineNum">     857 </span>            :             break;
<span class="lineNum">     858 </span>            :         }
<span class="lineNum">     859 </span>            :       else
<span class="lineNum">     860 </span>            :         {
<span class="lineNum">     861 </span>            :           mpz_tdiv_q_ui (t, t, p);
<span class="lineNum">     862 </span>            :           mp_factor_insert_ui (factors, p);
<span class="lineNum">     863 </span>            :         }
<span class="lineNum">     864 </span>            :     }
<span class="lineNum">     865 </span>            : 
<span class="lineNum">     866 </span>            :   mpz_clear (q);
<span class="lineNum">     867 </span>            : }
<span class="lineNum">     868 </span>            : #endif
<span class="lineNum">     869 </span>            : 
<span class="lineNum">     870 </span>            : /* Entry i contains (2i+1)^(-1) mod 2^8.  */
<span class="lineNum">     871 </span>            : static const unsigned char  binvert_table[128] =
<span class="lineNum">     872 </span>            : {
<span class="lineNum">     873 </span>            :   0x01, 0xAB, 0xCD, 0xB7, 0x39, 0xA3, 0xC5, 0xEF,
<span class="lineNum">     874 </span>            :   0xF1, 0x1B, 0x3D, 0xA7, 0x29, 0x13, 0x35, 0xDF,
<span class="lineNum">     875 </span>            :   0xE1, 0x8B, 0xAD, 0x97, 0x19, 0x83, 0xA5, 0xCF,
<span class="lineNum">     876 </span>            :   0xD1, 0xFB, 0x1D, 0x87, 0x09, 0xF3, 0x15, 0xBF,
<span class="lineNum">     877 </span>            :   0xC1, 0x6B, 0x8D, 0x77, 0xF9, 0x63, 0x85, 0xAF,
<span class="lineNum">     878 </span>            :   0xB1, 0xDB, 0xFD, 0x67, 0xE9, 0xD3, 0xF5, 0x9F,
<span class="lineNum">     879 </span>            :   0xA1, 0x4B, 0x6D, 0x57, 0xD9, 0x43, 0x65, 0x8F,
<span class="lineNum">     880 </span>            :   0x91, 0xBB, 0xDD, 0x47, 0xC9, 0xB3, 0xD5, 0x7F,
<span class="lineNum">     881 </span>            :   0x81, 0x2B, 0x4D, 0x37, 0xB9, 0x23, 0x45, 0x6F,
<span class="lineNum">     882 </span>            :   0x71, 0x9B, 0xBD, 0x27, 0xA9, 0x93, 0xB5, 0x5F,
<span class="lineNum">     883 </span>            :   0x61, 0x0B, 0x2D, 0x17, 0x99, 0x03, 0x25, 0x4F,
<span class="lineNum">     884 </span>            :   0x51, 0x7B, 0x9D, 0x07, 0x89, 0x73, 0x95, 0x3F,
<span class="lineNum">     885 </span>            :   0x41, 0xEB, 0x0D, 0xF7, 0x79, 0xE3, 0x05, 0x2F,
<span class="lineNum">     886 </span>            :   0x31, 0x5B, 0x7D, 0xE7, 0x69, 0x53, 0x75, 0x1F,
<span class="lineNum">     887 </span>            :   0x21, 0xCB, 0xED, 0xD7, 0x59, 0xC3, 0xE5, 0x0F,
<span class="lineNum">     888 </span>            :   0x11, 0x3B, 0x5D, 0xC7, 0x49, 0x33, 0x55, 0xFF
<span class="lineNum">     889 </span>            : };
<span class="lineNum">     890 </span>            : 
<span class="lineNum">     891 </span>            : /* Compute n^(-1) mod B, using a Newton iteration.  */
<span class="lineNum">     892 </span>            : #define binv(inv,n)                                                     \
<span class="lineNum">     893 </span>            :   do {                                                                  \
<span class="lineNum">     894 </span>            :     uintmax_t  __n = (n);                                               \
<span class="lineNum">     895 </span>            :     uintmax_t  __inv;                                                   \
<span class="lineNum">     896 </span>            :                                                                         \
<span class="lineNum">     897 </span>            :     __inv = binvert_table[(__n / 2) &amp; 0x7F]; /*  8 */                   \
<span class="lineNum">     898 </span>            :     if (W_TYPE_SIZE &gt; 8)   __inv = 2 * __inv - __inv * __inv * __n;     \
<span class="lineNum">     899 </span>            :     if (W_TYPE_SIZE &gt; 16)  __inv = 2 * __inv - __inv * __inv * __n;     \
<span class="lineNum">     900 </span>            :     if (W_TYPE_SIZE &gt; 32)  __inv = 2 * __inv - __inv * __inv * __n;     \
<span class="lineNum">     901 </span>            :                                                                         \
<span class="lineNum">     902 </span>            :     if (W_TYPE_SIZE &gt; 64)                                               \
<span class="lineNum">     903 </span>            :       {                                                                 \
<span class="lineNum">     904 </span>            :         int  __invbits = 64;                                            \
<span class="lineNum">     905 </span>            :         do {                                                            \
<span class="lineNum">     906 </span>            :           __inv = 2 * __inv - __inv * __inv * __n;                      \
<span class="lineNum">     907 </span>            :           __invbits *= 2;                                               \
<span class="lineNum">     908 </span>            :         } while (__invbits &lt; W_TYPE_SIZE);                              \
<span class="lineNum">     909 </span>            :       }                                                                 \
<span class="lineNum">     910 </span>            :                                                                         \
<span class="lineNum">     911 </span>            :     (inv) = __inv;                                                      \
<span class="lineNum">     912 </span>            :   } while (0)
<span class="lineNum">     913 </span>            : 
<span class="lineNum">     914 </span>            : /* q = u / d, assuming d|u.  */
<span class="lineNum">     915 </span>            : #define divexact_21(q1, q0, u1, u0, d)                                  \
<span class="lineNum">     916 </span>            :   do {                                                                  \
<span class="lineNum">     917 </span>            :     uintmax_t _di, _q0;                                                 \
<span class="lineNum">     918 </span>            :     binv (_di, (d));                                                    \
<span class="lineNum">     919 </span>            :     _q0 = (u0) * _di;                                                   \
<span class="lineNum">     920 </span>            :     if ((u1) &gt;= (d))                                                    \
<span class="lineNum">     921 </span>            :       {                                                                 \
<span class="lineNum">     922 </span>            :         uintmax_t _p1, _p0 _GL_UNUSED;                            \
<span class="lineNum">     923 </span>            :         umul_ppmm (_p1, _p0, _q0, d);                                   \
<span class="lineNum">     924 </span>            :         (q1) = ((u1) - _p1) * _di;                                      \
<span class="lineNum">     925 </span>            :         (q0) = _q0;                                                     \
<span class="lineNum">     926 </span>            :       }                                                                 \
<span class="lineNum">     927 </span>            :     else                                                                \
<span class="lineNum">     928 </span>            :       {                                                                 \
<span class="lineNum">     929 </span>            :         (q0) = _q0;                                                     \
<span class="lineNum">     930 </span>            :         (q1) = 0;                                                       \
<span class="lineNum">     931 </span>            :       }                                                                 \
<span class="lineNum">     932 </span>            :   } while (0)
<span class="lineNum">     933 </span>            : 
<span class="lineNum">     934 </span>            : /* x B (mod n). */
<span class="lineNum">     935 </span>            : #define redcify(r_prim, r, n)                                           \
<span class="lineNum">     936 </span>            :   do {                                                                  \
<span class="lineNum">     937 </span>            :     uintmax_t _redcify_q _GL_UNUSED;                              \
<span class="lineNum">     938 </span>            :     udiv_qrnnd (_redcify_q, r_prim, r, 0, n);                           \
<span class="lineNum">     939 </span>            :   } while (0)
<span class="lineNum">     940 </span>            : 
<span class="lineNum">     941 </span>            : /* x B^2 (mod n). Requires x &gt; 0, n1 &lt; B/2 */
<span class="lineNum">     942 </span>            : #define redcify2(r1, r0, x, n1, n0)                                     \
<span class="lineNum">     943 </span>            :   do {                                                                  \
<span class="lineNum">     944 </span>            :     uintmax_t _r1, _r0, _i;                                             \
<span class="lineNum">     945 </span>            :     if ((x) &lt; (n1))                                                     \
<span class="lineNum">     946 </span>            :       {                                                                 \
<span class="lineNum">     947 </span>            :         _r1 = (x); _r0 = 0;                                             \
<span class="lineNum">     948 </span>            :         _i = W_TYPE_SIZE;                                               \
<span class="lineNum">     949 </span>            :       }                                                                 \
<span class="lineNum">     950 </span>            :     else                                                                \
<span class="lineNum">     951 </span>            :       {                                                                 \
<span class="lineNum">     952 </span>            :         _r1 = 0; _r0 = (x);                                             \
<span class="lineNum">     953 </span>            :         _i = 2*W_TYPE_SIZE;                                             \
<span class="lineNum">     954 </span>            :       }                                                                 \
<span class="lineNum">     955 </span>            :     while (_i-- &gt; 0)                                                    \
<span class="lineNum">     956 </span>            :       {                                                                 \
<span class="lineNum">     957 </span>            :         lsh2 (_r1, _r0, _r1, _r0, 1);                                   \
<span class="lineNum">     958 </span>            :         if (ge2 (_r1, _r0, (n1), (n0)))                                 \
<span class="lineNum">     959 </span>            :           sub_ddmmss (_r1, _r0, _r1, _r0, (n1), (n0));                  \
<span class="lineNum">     960 </span>            :       }                                                                 \
<span class="lineNum">     961 </span>            :     (r1) = _r1;                                                         \
<span class="lineNum">     962 </span>            :     (r0) = _r0;                                                         \
<span class="lineNum">     963 </span>            :   } while (0)
<span class="lineNum">     964 </span>            : 
<span class="lineNum">     965 </span>            : /* Modular two-word multiplication, r = a * b mod m, with mi = m^(-1) mod B.
<span class="lineNum">     966 </span>            :    Both a and b must be in redc form, the result will be in redc form too. */
<span class="lineNum">     967 </span>            : static inline uintmax_t
<span class="lineNum">     968 </span>            : mulredc (uintmax_t a, uintmax_t b, uintmax_t m, uintmax_t mi)
<span class="lineNum">     969 </span>            : {
<span class="lineNum">     970 </span>            :   uintmax_t rh, rl, q, th, tl _GL_UNUSED, xh;
<span class="lineNum">     971 </span>            : 
<span class="lineNum">     972 </span><span class="lineNoCov">          0 :   umul_ppmm (rh, rl, a, b);</span>
<span class="lineNum">     973 </span><span class="lineNoCov">          0 :   q = rl * mi;</span>
<span class="lineNum">     974 </span><span class="lineNoCov">          0 :   umul_ppmm (th, tl, q, m);</span>
<span class="lineNum">     975 </span><span class="lineNoCov">          0 :   xh = rh - th;</span>
<span class="lineNum">     976 </span><span class="lineNoCov">          0 :   if (rh &lt; th)</span>
<span class="lineNum">     977 </span><span class="lineNoCov">          0 :     xh += m;</span>
<span class="lineNum">     978 </span>            : 
<span class="lineNum">     979 </span>            :   return xh;
<span class="lineNum">     980 </span>            : }
<span class="lineNum">     981 </span>            : 
<span class="lineNum">     982 </span>            : /* Modular two-word multiplication, r = a * b mod m, with mi = m^(-1) mod B.
<span class="lineNum">     983 </span>            :    Both a and b must be in redc form, the result will be in redc form too.
<a name="984"><span class="lineNum">     984 </span>            :    For performance reasons, the most significant bit of m must be clear. */</a>
<span class="lineNum">     985 </span>            : static uintmax_t
<span class="lineNum">     986 </span><span class="lineNoCov">          0 : mulredc2 (uintmax_t *r1p,</span>
<span class="lineNum">     987 </span>            :           uintmax_t a1, uintmax_t a0, uintmax_t b1, uintmax_t b0,
<span class="lineNum">     988 </span>            :           uintmax_t m1, uintmax_t m0, uintmax_t mi)
<span class="lineNum">     989 </span>            : {
<span class="lineNum">     990 </span>            :   uintmax_t r1, r0, q, p1, p0 _GL_UNUSED, t1, t0, s1, s0;
<span class="lineNum">     991 </span><span class="lineNoCov">          0 :   mi = -mi;</span>
<span class="lineNum">     992 </span><span class="lineNoCov">          0 :   assert ( (a1 &gt;&gt; (W_TYPE_SIZE - 1)) == 0);</span>
<span class="lineNum">     993 </span><span class="lineNoCov">          0 :   assert ( (b1 &gt;&gt; (W_TYPE_SIZE - 1)) == 0);</span>
<span class="lineNum">     994 </span><span class="lineNoCov">          0 :   assert ( (m1 &gt;&gt; (W_TYPE_SIZE - 1)) == 0);</span>
<span class="lineNum">     995 </span>            : 
<span class="lineNum">     996 </span>            :   /* First compute a0 * &lt;b1, b0&gt; B^{-1}
<span class="lineNum">     997 </span>            :         +-----+
<span class="lineNum">     998 </span>            :         |a0 b0|
<span class="lineNum">     999 </span>            :      +--+--+--+
<span class="lineNum">    1000 </span>            :      |a0 b1|
<span class="lineNum">    1001 </span>            :      +--+--+--+
<span class="lineNum">    1002 </span>            :         |q0 m0|
<span class="lineNum">    1003 </span>            :      +--+--+--+
<span class="lineNum">    1004 </span>            :      |q0 m1|
<span class="lineNum">    1005 </span>            :     -+--+--+--+
<span class="lineNum">    1006 </span>            :      |r1|r0| 0|
<span class="lineNum">    1007 </span>            :      +--+--+--+
<span class="lineNum">    1008 </span>            :   */
<span class="lineNum">    1009 </span><span class="lineNoCov">          0 :   umul_ppmm (t1, t0, a0, b0);</span>
<span class="lineNum">    1010 </span><span class="lineNoCov">          0 :   umul_ppmm (r1, r0, a0, b1);</span>
<span class="lineNum">    1011 </span><span class="lineNoCov">          0 :   q = mi * t0;</span>
<span class="lineNum">    1012 </span><span class="lineNoCov">          0 :   umul_ppmm (p1, p0, q, m0);</span>
<span class="lineNum">    1013 </span><span class="lineNoCov">          0 :   umul_ppmm (s1, s0, q, m1);</span>
<span class="lineNum">    1014 </span><span class="lineNoCov">          0 :   r0 += (t0 != 0); /* Carry */</span>
<span class="lineNum">    1015 </span><span class="lineNoCov">          0 :   add_ssaaaa (r1, r0, r1, r0, 0, p1);</span>
<span class="lineNum">    1016 </span><span class="lineNoCov">          0 :   add_ssaaaa (r1, r0, r1, r0, 0, t1);</span>
<span class="lineNum">    1017 </span><span class="lineNoCov">          0 :   add_ssaaaa (r1, r0, r1, r0, s1, s0);</span>
<span class="lineNum">    1018 </span>            : 
<span class="lineNum">    1019 </span>            :   /* Next, (a1 * &lt;b1, b0&gt; + &lt;r1, r0&gt; B^{-1}
<span class="lineNum">    1020 </span>            :         +-----+
<span class="lineNum">    1021 </span>            :         |a1 b0|
<span class="lineNum">    1022 </span>            :         +--+--+
<span class="lineNum">    1023 </span>            :         |r1|r0|
<span class="lineNum">    1024 </span>            :      +--+--+--+
<span class="lineNum">    1025 </span>            :      |a1 b1|
<span class="lineNum">    1026 </span>            :      +--+--+--+
<span class="lineNum">    1027 </span>            :         |q1 m0|
<span class="lineNum">    1028 </span>            :      +--+--+--+
<span class="lineNum">    1029 </span>            :      |q1 m1|
<span class="lineNum">    1030 </span>            :     -+--+--+--+
<span class="lineNum">    1031 </span>            :      |r1|r0| 0|
<span class="lineNum">    1032 </span>            :      +--+--+--+
<span class="lineNum">    1033 </span>            :   */
<span class="lineNum">    1034 </span><span class="lineNoCov">          0 :   umul_ppmm (t1, t0, a1, b0);</span>
<span class="lineNum">    1035 </span><span class="lineNoCov">          0 :   umul_ppmm (s1, s0, a1, b1);</span>
<span class="lineNum">    1036 </span><span class="lineNoCov">          0 :   add_ssaaaa (t1, t0, t1, t0, 0, r0);</span>
<span class="lineNum">    1037 </span><span class="lineNoCov">          0 :   q = mi * t0;</span>
<span class="lineNum">    1038 </span><span class="lineNoCov">          0 :   add_ssaaaa (r1, r0, s1, s0, 0, r1);</span>
<span class="lineNum">    1039 </span><span class="lineNoCov">          0 :   umul_ppmm (p1, p0, q, m0);</span>
<span class="lineNum">    1040 </span><span class="lineNoCov">          0 :   umul_ppmm (s1, s0, q, m1);</span>
<span class="lineNum">    1041 </span><span class="lineNoCov">          0 :   r0 += (t0 != 0); /* Carry */</span>
<span class="lineNum">    1042 </span><span class="lineNoCov">          0 :   add_ssaaaa (r1, r0, r1, r0, 0, p1);</span>
<span class="lineNum">    1043 </span><span class="lineNoCov">          0 :   add_ssaaaa (r1, r0, r1, r0, 0, t1);</span>
<span class="lineNum">    1044 </span><span class="lineNoCov">          0 :   add_ssaaaa (r1, r0, r1, r0, s1, s0);</span>
<span class="lineNum">    1045 </span>            : 
<span class="lineNum">    1046 </span><span class="lineNoCov">          0 :   if (ge2 (r1, r0, m1, m0))</span>
<span class="lineNum">    1047 </span><span class="lineNoCov">          0 :     sub_ddmmss (r1, r0, r1, r0, m1, m0);</span>
<span class="lineNum">    1048 </span>            : 
<span class="lineNum">    1049 </span><span class="lineNoCov">          0 :   *r1p = r1;</span>
<span class="lineNum">    1050 </span><span class="lineNoCov">          0 :   return r0;</span>
<span class="lineNum">    1051 </span>            : }
<a name="1052"><span class="lineNum">    1052 </span>            : </a>
<span class="lineNum">    1053 </span>            : static uintmax_t _GL_ATTRIBUTE_CONST
<span class="lineNum">    1054 </span><span class="lineNoCov">          0 : powm (uintmax_t b, uintmax_t e, uintmax_t n, uintmax_t ni, uintmax_t one)</span>
<span class="lineNum">    1055 </span>            : {
<span class="lineNum">    1056 </span><span class="lineNoCov">          0 :   uintmax_t y = one;</span>
<span class="lineNum">    1057 </span>            : 
<span class="lineNum">    1058 </span><span class="lineNoCov">          0 :   if (e &amp; 1)</span>
<span class="lineNum">    1059 </span><span class="lineNoCov">          0 :     y = b;</span>
<span class="lineNum">    1060 </span>            : 
<span class="lineNum">    1061 </span><span class="lineNoCov">          0 :   while (e != 0)</span>
<span class="lineNum">    1062 </span>            :     {
<span class="lineNum">    1063 </span><span class="lineNoCov">          0 :       b = mulredc (b, b, n, ni);</span>
<span class="lineNum">    1064 </span><span class="lineNoCov">          0 :       e &gt;&gt;= 1;</span>
<span class="lineNum">    1065 </span>            : 
<span class="lineNum">    1066 </span><span class="lineNoCov">          0 :       if (e &amp; 1)</span>
<span class="lineNum">    1067 </span><span class="lineNoCov">          0 :         y = mulredc (y, b, n, ni);</span>
<span class="lineNum">    1068 </span>            :     }
<span class="lineNum">    1069 </span>            : 
<span class="lineNum">    1070 </span><span class="lineNoCov">          0 :   return y;</span>
<span class="lineNum">    1071 </span>            : }
<a name="1072"><span class="lineNum">    1072 </span>            : </a>
<span class="lineNum">    1073 </span>            : static uintmax_t
<span class="lineNum">    1074 </span><span class="lineNoCov">          0 : powm2 (uintmax_t *r1m,</span>
<span class="lineNum">    1075 </span>            :        const uintmax_t *bp, const uintmax_t *ep, const uintmax_t *np,
<span class="lineNum">    1076 </span>            :        uintmax_t ni, const uintmax_t *one)
<span class="lineNum">    1077 </span>            : {
<span class="lineNum">    1078 </span>            :   uintmax_t r1, r0, b1, b0, n1, n0;
<span class="lineNum">    1079 </span>            :   unsigned int i;
<span class="lineNum">    1080 </span>            :   uintmax_t e;
<span class="lineNum">    1081 </span>            : 
<span class="lineNum">    1082 </span><span class="lineNoCov">          0 :   b0 = bp[0];</span>
<span class="lineNum">    1083 </span><span class="lineNoCov">          0 :   b1 = bp[1];</span>
<span class="lineNum">    1084 </span><span class="lineNoCov">          0 :   n0 = np[0];</span>
<span class="lineNum">    1085 </span><span class="lineNoCov">          0 :   n1 = np[1];</span>
<span class="lineNum">    1086 </span>            : 
<span class="lineNum">    1087 </span><span class="lineNoCov">          0 :   r0 = one[0];</span>
<span class="lineNum">    1088 </span><span class="lineNoCov">          0 :   r1 = one[1];</span>
<span class="lineNum">    1089 </span>            : 
<span class="lineNum">    1090 </span><span class="lineNoCov">          0 :   for (e = ep[0], i = W_TYPE_SIZE; i &gt; 0; i--, e &gt;&gt;= 1)</span>
<span class="lineNum">    1091 </span>            :     {
<span class="lineNum">    1092 </span><span class="lineNoCov">          0 :       if (e &amp; 1)</span>
<span class="lineNum">    1093 </span>            :         {
<span class="lineNum">    1094 </span><span class="lineNoCov">          0 :           r0 = mulredc2 (r1m, r1, r0, b1, b0, n1, n0, ni);</span>
<span class="lineNum">    1095 </span><span class="lineNoCov">          0 :           r1 = *r1m;</span>
<span class="lineNum">    1096 </span>            :         }
<span class="lineNum">    1097 </span><span class="lineNoCov">          0 :       b0 = mulredc2 (r1m, b1, b0, b1, b0, n1, n0, ni);</span>
<span class="lineNum">    1098 </span><span class="lineNoCov">          0 :       b1 = *r1m;</span>
<span class="lineNum">    1099 </span>            :     }
<span class="lineNum">    1100 </span><span class="lineNoCov">          0 :   for (e = ep[1]; e &gt; 0; e &gt;&gt;= 1)</span>
<span class="lineNum">    1101 </span>            :     {
<span class="lineNum">    1102 </span><span class="lineNoCov">          0 :       if (e &amp; 1)</span>
<span class="lineNum">    1103 </span>            :         {
<span class="lineNum">    1104 </span><span class="lineNoCov">          0 :           r0 = mulredc2 (r1m, r1, r0, b1, b0, n1, n0, ni);</span>
<span class="lineNum">    1105 </span><span class="lineNoCov">          0 :           r1 = *r1m;</span>
<span class="lineNum">    1106 </span>            :         }
<span class="lineNum">    1107 </span><span class="lineNoCov">          0 :       b0 = mulredc2 (r1m, b1, b0, b1, b0, n1, n0, ni);</span>
<span class="lineNum">    1108 </span><span class="lineNoCov">          0 :       b1 = *r1m;</span>
<span class="lineNum">    1109 </span>            :     }
<span class="lineNum">    1110 </span><span class="lineNoCov">          0 :   *r1m = r1;</span>
<span class="lineNum">    1111 </span><span class="lineNoCov">          0 :   return r0;</span>
<span class="lineNum">    1112 </span>            : }
<a name="1113"><span class="lineNum">    1113 </span>            : </a>
<span class="lineNum">    1114 </span>            : static bool _GL_ATTRIBUTE_CONST
<span class="lineNum">    1115 </span><span class="lineNoCov">          0 : millerrabin (uintmax_t n, uintmax_t ni, uintmax_t b, uintmax_t q,</span>
<span class="lineNum">    1116 </span>            :              unsigned int k, uintmax_t one)
<span class="lineNum">    1117 </span>            : {
<span class="lineNum">    1118 </span><span class="lineNoCov">          0 :   uintmax_t y = powm (b, q, n, ni, one);</span>
<span class="lineNum">    1119 </span>            : 
<span class="lineNum">    1120 </span><span class="lineNoCov">          0 :   uintmax_t nm1 = n - one;      /* -1, but in redc representation. */</span>
<span class="lineNum">    1121 </span>            : 
<span class="lineNum">    1122 </span><span class="lineNoCov">          0 :   if (y == one || y == nm1)</span>
<span class="lineNum">    1123 </span>            :     return true;
<span class="lineNum">    1124 </span>            : 
<span class="lineNum">    1125 </span><span class="lineNoCov">          0 :   for (unsigned int i = 1; i &lt; k; i++)</span>
<span class="lineNum">    1126 </span>            :     {
<span class="lineNum">    1127 </span><span class="lineNoCov">          0 :       y = mulredc (y, y, n, ni);</span>
<span class="lineNum">    1128 </span>            : 
<span class="lineNum">    1129 </span><span class="lineNoCov">          0 :       if (y == nm1)</span>
<span class="lineNum">    1130 </span>            :         return true;
<span class="lineNum">    1131 </span><span class="lineNoCov">          0 :       if (y == one)</span>
<span class="lineNum">    1132 </span>            :         return false;
<span class="lineNum">    1133 </span>            :     }
<span class="lineNum">    1134 </span>            :   return false;
<span class="lineNum">    1135 </span>            : }
<a name="1136"><span class="lineNum">    1136 </span>            : </a>
<span class="lineNum">    1137 </span>            : static bool
<span class="lineNum">    1138 </span><span class="lineNoCov">          0 : millerrabin2 (const uintmax_t *np, uintmax_t ni, const uintmax_t *bp,</span>
<span class="lineNum">    1139 </span>            :               const uintmax_t *qp, unsigned int k, const uintmax_t *one)
<span class="lineNum">    1140 </span>            : {
<span class="lineNum">    1141 </span>            :   uintmax_t y1, y0, nm1_1, nm1_0, r1m;
<span class="lineNum">    1142 </span>            : 
<span class="lineNum">    1143 </span><span class="lineNoCov">          0 :   y0 = powm2 (&amp;r1m, bp, qp, np, ni, one);</span>
<span class="lineNum">    1144 </span><span class="lineNoCov">          0 :   y1 = r1m;</span>
<span class="lineNum">    1145 </span>            : 
<span class="lineNum">    1146 </span><span class="lineNoCov">          0 :   if (y0 == one[0] &amp;&amp; y1 == one[1])</span>
<span class="lineNum">    1147 </span>            :     return true;
<span class="lineNum">    1148 </span>            : 
<span class="lineNum">    1149 </span><span class="lineNoCov">          0 :   sub_ddmmss (nm1_1, nm1_0, np[1], np[0], one[1], one[0]);</span>
<span class="lineNum">    1150 </span>            : 
<span class="lineNum">    1151 </span><span class="lineNoCov">          0 :   if (y0 == nm1_0 &amp;&amp; y1 == nm1_1)</span>
<span class="lineNum">    1152 </span>            :     return true;
<span class="lineNum">    1153 </span>            : 
<span class="lineNum">    1154 </span><span class="lineNoCov">          0 :   for (unsigned int i = 1; i &lt; k; i++)</span>
<span class="lineNum">    1155 </span>            :     {
<span class="lineNum">    1156 </span><span class="lineNoCov">          0 :       y0 = mulredc2 (&amp;r1m, y1, y0, y1, y0, np[1], np[0], ni);</span>
<span class="lineNum">    1157 </span><span class="lineNoCov">          0 :       y1 = r1m;</span>
<span class="lineNum">    1158 </span>            : 
<span class="lineNum">    1159 </span><span class="lineNoCov">          0 :       if (y0 == nm1_0 &amp;&amp; y1 == nm1_1)</span>
<span class="lineNum">    1160 </span>            :         return true;
<span class="lineNum">    1161 </span><span class="lineNoCov">          0 :       if (y0 == one[0] &amp;&amp; y1 == one[1])</span>
<span class="lineNum">    1162 </span>            :         return false;
<span class="lineNum">    1163 </span>            :     }
<span class="lineNum">    1164 </span>            :   return false;
<span class="lineNum">    1165 </span>            : }
<span class="lineNum">    1166 </span>            : 
<span class="lineNum">    1167 </span>            : #if HAVE_GMP
<span class="lineNum">    1168 </span>            : static bool
<span class="lineNum">    1169 </span>            : mp_millerrabin (mpz_srcptr n, mpz_srcptr nm1, mpz_ptr x, mpz_ptr y,
<span class="lineNum">    1170 </span>            :                 mpz_srcptr q, unsigned long int k)
<span class="lineNum">    1171 </span>            : {
<span class="lineNum">    1172 </span>            :   mpz_powm (y, x, q, n);
<span class="lineNum">    1173 </span>            : 
<span class="lineNum">    1174 </span>            :   if (mpz_cmp_ui (y, 1) == 0 || mpz_cmp (y, nm1) == 0)
<span class="lineNum">    1175 </span>            :     return true;
<span class="lineNum">    1176 </span>            : 
<span class="lineNum">    1177 </span>            :   for (unsigned long int i = 1; i &lt; k; i++)
<span class="lineNum">    1178 </span>            :     {
<span class="lineNum">    1179 </span>            :       mpz_powm_ui (y, y, 2, n);
<span class="lineNum">    1180 </span>            :       if (mpz_cmp (y, nm1) == 0)
<span class="lineNum">    1181 </span>            :         return true;
<span class="lineNum">    1182 </span>            :       if (mpz_cmp_ui (y, 1) == 0)
<span class="lineNum">    1183 </span>            :         return false;
<span class="lineNum">    1184 </span>            :     }
<span class="lineNum">    1185 </span>            :   return false;
<span class="lineNum">    1186 </span>            : }
<span class="lineNum">    1187 </span>            : #endif
<span class="lineNum">    1188 </span>            : 
<span class="lineNum">    1189 </span>            : /* Lucas' prime test.  The number of iterations vary greatly, up to a few dozen
<a name="1190"><span class="lineNum">    1190 </span>            :    have been observed.  The average seem to be about 2.  */</a>
<span class="lineNum">    1191 </span>            : static bool
<span class="lineNum">    1192 </span><span class="lineNoCov">          0 : prime_p (uintmax_t n)</span>
<span class="lineNum">    1193 </span>            : {
<span class="lineNum">    1194 </span>            :   int k;
<span class="lineNum">    1195 </span>            :   bool is_prime;
<span class="lineNum">    1196 </span>            :   uintmax_t a_prim, one, ni;
<span class="lineNum">    1197 </span>            :   struct factors factors;
<span class="lineNum">    1198 </span>            : 
<span class="lineNum">    1199 </span><span class="lineNoCov">          0 :   if (n &lt;= 1)</span>
<span class="lineNum">    1200 </span>            :     return false;
<span class="lineNum">    1201 </span>            : 
<span class="lineNum">    1202 </span>            :   /* We have already casted out small primes. */
<span class="lineNum">    1203 </span><span class="lineNoCov">          0 :   if (n &lt; (uintmax_t) FIRST_OMITTED_PRIME * FIRST_OMITTED_PRIME)</span>
<span class="lineNum">    1204 </span>            :     return true;
<span class="lineNum">    1205 </span>            : 
<span class="lineNum">    1206 </span>            :   /* Precomputation for Miller-Rabin.  */
<span class="lineNum">    1207 </span><span class="lineNoCov">          0 :   uintmax_t q = n - 1;</span>
<span class="lineNum">    1208 </span><span class="lineNoCov">          0 :   for (k = 0; (q &amp; 1) == 0; k++)</span>
<span class="lineNum">    1209 </span><span class="lineNoCov">          0 :     q &gt;&gt;= 1;</span>
<span class="lineNum">    1210 </span>            : 
<span class="lineNum">    1211 </span><span class="lineNoCov">          0 :   uintmax_t a = 2;</span>
<span class="lineNum">    1212 </span><span class="lineNoCov">          0 :   binv (ni, n);                 /* ni &lt;- 1/n mod B */</span>
<span class="lineNum">    1213 </span><span class="lineNoCov">          0 :   redcify (one, 1, n);</span>
<span class="lineNum">    1214 </span><span class="lineNoCov">          0 :   addmod (a_prim, one, one, n); /* i.e., redcify a = 2 */</span>
<span class="lineNum">    1215 </span>            : 
<span class="lineNum">    1216 </span>            :   /* Perform a Miller-Rabin test, finds most composites quickly.  */
<span class="lineNum">    1217 </span><span class="lineNoCov">          0 :   if (!millerrabin (n, ni, a_prim, q, k, one))</span>
<span class="lineNum">    1218 </span>            :     return false;
<span class="lineNum">    1219 </span>            : 
<span class="lineNum">    1220 </span><span class="lineNoCov">          0 :   if (flag_prove_primality)</span>
<span class="lineNum">    1221 </span>            :     {
<span class="lineNum">    1222 </span>            :       /* Factor n-1 for Lucas.  */
<span class="lineNum">    1223 </span><span class="lineNoCov">          0 :       factor (0, n - 1, &amp;factors);</span>
<span class="lineNum">    1224 </span>            :     }
<span class="lineNum">    1225 </span>            : 
<span class="lineNum">    1226 </span>            :   /* Loop until Lucas proves our number prime, or Miller-Rabin proves our
<span class="lineNum">    1227 </span>            :      number composite.  */
<span class="lineNum">    1228 </span><span class="lineNoCov">          0 :   for (unsigned int r = 0; r &lt; PRIMES_PTAB_ENTRIES; r++)</span>
<span class="lineNum">    1229 </span>            :     {
<span class="lineNum">    1230 </span><span class="lineNoCov">          0 :       if (flag_prove_primality)</span>
<span class="lineNum">    1231 </span>            :         {
<span class="lineNum">    1232 </span>            :           is_prime = true;
<span class="lineNum">    1233 </span><span class="lineNoCov">          0 :           for (unsigned int i = 0; i &lt; factors.nfactors &amp;&amp; is_prime; i++)</span>
<span class="lineNum">    1234 </span>            :             {
<span class="lineNum">    1235 </span>            :               is_prime
<span class="lineNum">    1236 </span><span class="lineNoCov">          0 :                 = powm (a_prim, (n - 1) / factors.p[i], n, ni, one) != one;</span>
<span class="lineNum">    1237 </span>            :             }
<span class="lineNum">    1238 </span>            :         }
<span class="lineNum">    1239 </span>            :       else
<span class="lineNum">    1240 </span>            :         {
<span class="lineNum">    1241 </span>            :           /* After enough Miller-Rabin runs, be content. */
<span class="lineNum">    1242 </span><span class="lineNoCov">          0 :           is_prime = (r == MR_REPS - 1);</span>
<span class="lineNum">    1243 </span>            :         }
<span class="lineNum">    1244 </span>            : 
<span class="lineNum">    1245 </span><span class="lineNoCov">          0 :       if (is_prime)</span>
<span class="lineNum">    1246 </span>            :         return true;
<span class="lineNum">    1247 </span>            : 
<span class="lineNum">    1248 </span><span class="lineNoCov">          0 :       a += primes_diff[r];      /* Establish new base.  */</span>
<span class="lineNum">    1249 </span>            : 
<span class="lineNum">    1250 </span>            :       /* The following is equivalent to redcify (a_prim, a, n).  It runs faster
<span class="lineNum">    1251 </span>            :          on most processors, since it avoids udiv_qrnnd.  If we go down the
<span class="lineNum">    1252 </span>            :          udiv_qrnnd_preinv path, this code should be replaced.  */
<span class="lineNum">    1253 </span>            :       {
<span class="lineNum">    1254 </span>            :         uintmax_t s1, s0;
<span class="lineNum">    1255 </span><span class="lineNoCov">          0 :         umul_ppmm (s1, s0, one, a);</span>
<span class="lineNum">    1256 </span><span class="lineNoCov">          0 :         if (LIKELY (s1 == 0))</span>
<span class="lineNum">    1257 </span><span class="lineNoCov">          0 :           a_prim = s0 % n;</span>
<span class="lineNum">    1258 </span>            :         else
<span class="lineNum">    1259 </span>            :           {
<span class="lineNum">    1260 </span>            :             uintmax_t dummy _GL_UNUSED;
<span class="lineNum">    1261 </span><span class="lineNoCov">          0 :             udiv_qrnnd (dummy, a_prim, s1, s0, n);</span>
<span class="lineNum">    1262 </span>            :           }
<span class="lineNum">    1263 </span>            :       }
<span class="lineNum">    1264 </span>            : 
<span class="lineNum">    1265 </span><span class="lineNoCov">          0 :       if (!millerrabin (n, ni, a_prim, q, k, one))</span>
<span class="lineNum">    1266 </span>            :         return false;
<span class="lineNum">    1267 </span>            :     }
<span class="lineNum">    1268 </span>            : 
<span class="lineNum">    1269 </span><span class="lineNoCov">          0 :   error (0, 0, _(&quot;Lucas prime test failure.  This should not happen&quot;));</span>
<span class="lineNum">    1270 </span><span class="lineNoCov">          0 :   abort ();</span>
<span class="lineNum">    1271 </span>            : }
<a name="1272"><span class="lineNum">    1272 </span>            : </a>
<span class="lineNum">    1273 </span>            : static bool
<span class="lineNum">    1274 </span><span class="lineNoCov">          0 : prime2_p (uintmax_t n1, uintmax_t n0)</span>
<span class="lineNum">    1275 </span>            : {
<span class="lineNum">    1276 </span>            :   uintmax_t q[2], nm1[2];
<span class="lineNum">    1277 </span>            :   uintmax_t a_prim[2];
<span class="lineNum">    1278 </span>            :   uintmax_t one[2];
<span class="lineNum">    1279 </span>            :   uintmax_t na[2];
<span class="lineNum">    1280 </span>            :   uintmax_t ni;
<span class="lineNum">    1281 </span>            :   unsigned int k;
<span class="lineNum">    1282 </span>            :   struct factors factors;
<span class="lineNum">    1283 </span>            : 
<span class="lineNum">    1284 </span><span class="lineNoCov">          0 :   if (n1 == 0)</span>
<span class="lineNum">    1285 </span><span class="lineNoCov">          0 :     return prime_p (n0);</span>
<span class="lineNum">    1286 </span>            : 
<span class="lineNum">    1287 </span><span class="lineNoCov">          0 :   nm1[1] = n1 - (n0 == 0);</span>
<span class="lineNum">    1288 </span><span class="lineNoCov">          0 :   nm1[0] = n0 - 1;</span>
<span class="lineNum">    1289 </span><span class="lineNoCov">          0 :   if (nm1[0] == 0)</span>
<span class="lineNum">    1290 </span>            :     {
<span class="lineNum">    1291 </span><span class="lineNoCov">          0 :       count_trailing_zeros (k, nm1[1]);</span>
<span class="lineNum">    1292 </span>            : 
<span class="lineNum">    1293 </span><span class="lineNoCov">          0 :       q[0] = nm1[1] &gt;&gt; k;</span>
<span class="lineNum">    1294 </span><span class="lineNoCov">          0 :       q[1] = 0;</span>
<span class="lineNum">    1295 </span><span class="lineNoCov">          0 :       k += W_TYPE_SIZE;</span>
<span class="lineNum">    1296 </span>            :     }
<span class="lineNum">    1297 </span>            :   else
<span class="lineNum">    1298 </span>            :     {
<span class="lineNum">    1299 </span><span class="lineNoCov">          0 :       count_trailing_zeros (k, nm1[0]);</span>
<span class="lineNum">    1300 </span><span class="lineNoCov">          0 :       rsh2 (q[1], q[0], nm1[1], nm1[0], k);</span>
<span class="lineNum">    1301 </span>            :     }
<span class="lineNum">    1302 </span>            : 
<span class="lineNum">    1303 </span><span class="lineNoCov">          0 :   uintmax_t a = 2;</span>
<span class="lineNum">    1304 </span><span class="lineNoCov">          0 :   binv (ni, n0);</span>
<span class="lineNum">    1305 </span><span class="lineNoCov">          0 :   redcify2 (one[1], one[0], 1, n1, n0);</span>
<span class="lineNum">    1306 </span><span class="lineNoCov">          0 :   addmod2 (a_prim[1], a_prim[0], one[1], one[0], one[1], one[0], n1, n0);</span>
<span class="lineNum">    1307 </span>            : 
<span class="lineNum">    1308 </span>            :   /* FIXME: Use scalars or pointers in arguments? Some consistency needed. */
<span class="lineNum">    1309 </span><span class="lineNoCov">          0 :   na[0] = n0;</span>
<span class="lineNum">    1310 </span><span class="lineNoCov">          0 :   na[1] = n1;</span>
<span class="lineNum">    1311 </span>            : 
<span class="lineNum">    1312 </span><span class="lineNoCov">          0 :   if (!millerrabin2 (na, ni, a_prim, q, k, one))</span>
<span class="lineNum">    1313 </span>            :     return false;
<span class="lineNum">    1314 </span>            : 
<span class="lineNum">    1315 </span><span class="lineNoCov">          0 :   if (flag_prove_primality)</span>
<span class="lineNum">    1316 </span>            :     {
<span class="lineNum">    1317 </span>            :       /* Factor n-1 for Lucas.  */
<span class="lineNum">    1318 </span><span class="lineNoCov">          0 :       factor (nm1[1], nm1[0], &amp;factors);</span>
<span class="lineNum">    1319 </span>            :     }
<span class="lineNum">    1320 </span>            : 
<span class="lineNum">    1321 </span>            :   /* Loop until Lucas proves our number prime, or Miller-Rabin proves our
<span class="lineNum">    1322 </span>            :      number composite.  */
<span class="lineNum">    1323 </span><span class="lineNoCov">          0 :   for (unsigned int r = 0; r &lt; PRIMES_PTAB_ENTRIES; r++)</span>
<span class="lineNum">    1324 </span>            :     {
<span class="lineNum">    1325 </span>            :       bool is_prime;
<span class="lineNum">    1326 </span>            :       uintmax_t e[2], y[2];
<span class="lineNum">    1327 </span>            : 
<span class="lineNum">    1328 </span><span class="lineNoCov">          0 :       if (flag_prove_primality)</span>
<span class="lineNum">    1329 </span>            :         {
<span class="lineNum">    1330 </span><span class="lineNoCov">          0 :           is_prime = true;</span>
<span class="lineNum">    1331 </span><span class="lineNoCov">          0 :           if (factors.plarge[1])</span>
<span class="lineNum">    1332 </span>            :             {
<span class="lineNum">    1333 </span>            :               uintmax_t pi;
<span class="lineNum">    1334 </span><span class="lineNoCov">          0 :               binv (pi, factors.plarge[0]);</span>
<span class="lineNum">    1335 </span><span class="lineNoCov">          0 :               e[0] = pi * nm1[0];</span>
<span class="lineNum">    1336 </span><span class="lineNoCov">          0 :               e[1] = 0;</span>
<span class="lineNum">    1337 </span><span class="lineNoCov">          0 :               y[0] = powm2 (&amp;y[1], a_prim, e, na, ni, one);</span>
<span class="lineNum">    1338 </span><span class="lineNoCov">          0 :               is_prime = (y[0] != one[0] || y[1] != one[1]);</span>
<span class="lineNum">    1339 </span>            :             }
<span class="lineNum">    1340 </span><span class="lineNoCov">          0 :           for (unsigned int i = 0; i &lt; factors.nfactors &amp;&amp; is_prime; i++)</span>
<span class="lineNum">    1341 </span>            :             {
<span class="lineNum">    1342 </span>            :               /* FIXME: We always have the factor 2. Do we really need to
<span class="lineNum">    1343 </span>            :                  handle it here? We have done the same powering as part
<span class="lineNum">    1344 </span>            :                  of millerrabin. */
<span class="lineNum">    1345 </span><span class="lineNoCov">          0 :               if (factors.p[i] == 2)</span>
<span class="lineNum">    1346 </span><span class="lineNoCov">          0 :                 rsh2 (e[1], e[0], nm1[1], nm1[0], 1);</span>
<span class="lineNum">    1347 </span>            :               else
<span class="lineNum">    1348 </span><span class="lineNoCov">          0 :                 divexact_21 (e[1], e[0], nm1[1], nm1[0], factors.p[i]);</span>
<span class="lineNum">    1349 </span><span class="lineNoCov">          0 :               y[0] = powm2 (&amp;y[1], a_prim, e, na, ni, one);</span>
<span class="lineNum">    1350 </span><span class="lineNoCov">          0 :               is_prime = (y[0] != one[0] || y[1] != one[1]);</span>
<span class="lineNum">    1351 </span>            :             }
<span class="lineNum">    1352 </span>            :         }
<span class="lineNum">    1353 </span>            :       else
<span class="lineNum">    1354 </span>            :         {
<span class="lineNum">    1355 </span>            :           /* After enough Miller-Rabin runs, be content. */
<span class="lineNum">    1356 </span><span class="lineNoCov">          0 :           is_prime = (r == MR_REPS - 1);</span>
<span class="lineNum">    1357 </span>            :         }
<span class="lineNum">    1358 </span>            : 
<span class="lineNum">    1359 </span><span class="lineNoCov">          0 :       if (is_prime)</span>
<span class="lineNum">    1360 </span><span class="lineNoCov">          0 :         return true;</span>
<span class="lineNum">    1361 </span>            : 
<span class="lineNum">    1362 </span><span class="lineNoCov">          0 :       a += primes_diff[r];      /* Establish new base.  */</span>
<span class="lineNum">    1363 </span><span class="lineNoCov">          0 :       redcify2 (a_prim[1], a_prim[0], a, n1, n0);</span>
<span class="lineNum">    1364 </span>            : 
<span class="lineNum">    1365 </span><span class="lineNoCov">          0 :       if (!millerrabin2 (na, ni, a_prim, q, k, one))</span>
<span class="lineNum">    1366 </span>            :         return false;
<span class="lineNum">    1367 </span>            :     }
<span class="lineNum">    1368 </span>            : 
<span class="lineNum">    1369 </span><span class="lineNoCov">          0 :   error (0, 0, _(&quot;Lucas prime test failure.  This should not happen&quot;));</span>
<span class="lineNum">    1370 </span><span class="lineNoCov">          0 :   abort ();</span>
<span class="lineNum">    1371 </span>            : }
<span class="lineNum">    1372 </span>            : 
<span class="lineNum">    1373 </span>            : #if HAVE_GMP
<span class="lineNum">    1374 </span>            : static bool
<span class="lineNum">    1375 </span>            : mp_prime_p (mpz_t n)
<span class="lineNum">    1376 </span>            : {
<span class="lineNum">    1377 </span>            :   bool is_prime;
<span class="lineNum">    1378 </span>            :   mpz_t q, a, nm1, tmp;
<span class="lineNum">    1379 </span>            :   struct mp_factors factors;
<span class="lineNum">    1380 </span>            : 
<span class="lineNum">    1381 </span>            :   if (mpz_cmp_ui (n, 1) &lt;= 0)
<span class="lineNum">    1382 </span>            :     return false;
<span class="lineNum">    1383 </span>            : 
<span class="lineNum">    1384 </span>            :   /* We have already casted out small primes. */
<span class="lineNum">    1385 </span>            :   if (mpz_cmp_ui (n, (long) FIRST_OMITTED_PRIME * FIRST_OMITTED_PRIME) &lt; 0)
<span class="lineNum">    1386 </span>            :     return true;
<span class="lineNum">    1387 </span>            : 
<span class="lineNum">    1388 </span>            :   mpz_inits (q, a, nm1, tmp, NULL);
<span class="lineNum">    1389 </span>            : 
<span class="lineNum">    1390 </span>            :   /* Precomputation for Miller-Rabin.  */
<span class="lineNum">    1391 </span>            :   mpz_sub_ui (nm1, n, 1);
<span class="lineNum">    1392 </span>            : 
<span class="lineNum">    1393 </span>            :   /* Find q and k, where q is odd and n = 1 + 2**k * q.  */
<span class="lineNum">    1394 </span>            :   unsigned long int k = mpz_scan1 (nm1, 0);
<span class="lineNum">    1395 </span>            :   mpz_tdiv_q_2exp (q, nm1, k);
<span class="lineNum">    1396 </span>            : 
<span class="lineNum">    1397 </span>            :   mpz_set_ui (a, 2);
<span class="lineNum">    1398 </span>            : 
<span class="lineNum">    1399 </span>            :   /* Perform a Miller-Rabin test, finds most composites quickly.  */
<span class="lineNum">    1400 </span>            :   if (!mp_millerrabin (n, nm1, a, tmp, q, k))
<span class="lineNum">    1401 </span>            :     {
<span class="lineNum">    1402 </span>            :       is_prime = false;
<span class="lineNum">    1403 </span>            :       goto ret2;
<span class="lineNum">    1404 </span>            :     }
<span class="lineNum">    1405 </span>            : 
<span class="lineNum">    1406 </span>            :   if (flag_prove_primality)
<span class="lineNum">    1407 </span>            :     {
<span class="lineNum">    1408 </span>            :       /* Factor n-1 for Lucas.  */
<span class="lineNum">    1409 </span>            :       mpz_set (tmp, nm1);
<span class="lineNum">    1410 </span>            :       mp_factor (tmp, &amp;factors);
<span class="lineNum">    1411 </span>            :     }
<span class="lineNum">    1412 </span>            : 
<span class="lineNum">    1413 </span>            :   /* Loop until Lucas proves our number prime, or Miller-Rabin proves our
<span class="lineNum">    1414 </span>            :      number composite.  */
<span class="lineNum">    1415 </span>            :   for (unsigned int r = 0; r &lt; PRIMES_PTAB_ENTRIES; r++)
<span class="lineNum">    1416 </span>            :     {
<span class="lineNum">    1417 </span>            :       if (flag_prove_primality)
<span class="lineNum">    1418 </span>            :         {
<span class="lineNum">    1419 </span>            :           is_prime = true;
<span class="lineNum">    1420 </span>            :           for (unsigned long int i = 0; i &lt; factors.nfactors &amp;&amp; is_prime; i++)
<span class="lineNum">    1421 </span>            :             {
<span class="lineNum">    1422 </span>            :               mpz_divexact (tmp, nm1, factors.p[i]);
<span class="lineNum">    1423 </span>            :               mpz_powm (tmp, a, tmp, n);
<span class="lineNum">    1424 </span>            :               is_prime = mpz_cmp_ui (tmp, 1) != 0;
<span class="lineNum">    1425 </span>            :             }
<span class="lineNum">    1426 </span>            :         }
<span class="lineNum">    1427 </span>            :       else
<span class="lineNum">    1428 </span>            :         {
<span class="lineNum">    1429 </span>            :           /* After enough Miller-Rabin runs, be content. */
<span class="lineNum">    1430 </span>            :           is_prime = (r == MR_REPS - 1);
<span class="lineNum">    1431 </span>            :         }
<span class="lineNum">    1432 </span>            : 
<span class="lineNum">    1433 </span>            :       if (is_prime)
<span class="lineNum">    1434 </span>            :         goto ret1;
<span class="lineNum">    1435 </span>            : 
<span class="lineNum">    1436 </span>            :       mpz_add_ui (a, a, primes_diff[r]);        /* Establish new base.  */
<span class="lineNum">    1437 </span>            : 
<span class="lineNum">    1438 </span>            :       if (!mp_millerrabin (n, nm1, a, tmp, q, k))
<span class="lineNum">    1439 </span>            :         {
<span class="lineNum">    1440 </span>            :           is_prime = false;
<span class="lineNum">    1441 </span>            :           goto ret1;
<span class="lineNum">    1442 </span>            :         }
<span class="lineNum">    1443 </span>            :     }
<span class="lineNum">    1444 </span>            : 
<span class="lineNum">    1445 </span>            :   error (0, 0, _(&quot;Lucas prime test failure.  This should not happen&quot;));
<span class="lineNum">    1446 </span>            :   abort ();
<span class="lineNum">    1447 </span>            : 
<span class="lineNum">    1448 </span>            :  ret1:
<span class="lineNum">    1449 </span>            :   if (flag_prove_primality)
<span class="lineNum">    1450 </span>            :     mp_factor_clear (&amp;factors);
<span class="lineNum">    1451 </span>            :  ret2:
<span class="lineNum">    1452 </span>            :   mpz_clears (q, a, nm1, tmp, NULL);
<span class="lineNum">    1453 </span>            : 
<span class="lineNum">    1454 </span>            :   return is_prime;
<span class="lineNum">    1455 </span>            : }
<span class="lineNum">    1456 </span>            : #endif
<a name="1457"><span class="lineNum">    1457 </span>            : </a>
<span class="lineNum">    1458 </span>            : static void
<span class="lineNum">    1459 </span><span class="lineNoCov">          0 : factor_using_pollard_rho (uintmax_t n, unsigned long int a,</span>
<span class="lineNum">    1460 </span>            :                           struct factors *factors)
<span class="lineNum">    1461 </span>            : {
<span class="lineNum">    1462 </span>            :   uintmax_t x, z, y, P, t, ni, g;
<span class="lineNum">    1463 </span>            : 
<span class="lineNum">    1464 </span><span class="lineNoCov">          0 :   unsigned long int k = 1;</span>
<span class="lineNum">    1465 </span><span class="lineNoCov">          0 :   unsigned long int l = 1;</span>
<span class="lineNum">    1466 </span>            : 
<span class="lineNum">    1467 </span><span class="lineNoCov">          0 :   redcify (P, 1, n);</span>
<span class="lineNum">    1468 </span><span class="lineNoCov">          0 :   addmod (x, P, P, n);          /* i.e., redcify(2) */</span>
<span class="lineNum">    1469 </span><span class="lineNoCov">          0 :   y = z = x;</span>
<span class="lineNum">    1470 </span>            : 
<span class="lineNum">    1471 </span><span class="lineNoCov">          0 :   while (n != 1)</span>
<span class="lineNum">    1472 </span>            :     {
<span class="lineNum">    1473 </span><span class="lineNoCov">          0 :       assert (a &lt; n);</span>
<span class="lineNum">    1474 </span>            : 
<span class="lineNum">    1475 </span><span class="lineNoCov">          0 :       binv (ni, n);             /* FIXME: when could we use old 'ni' value? */</span>
<span class="lineNum">    1476 </span>            : 
<span class="lineNum">    1477 </span>            :       for (;;)
<span class="lineNum">    1478 </span>            :         {
<span class="lineNum">    1479 </span>            :           do
<span class="lineNum">    1480 </span>            :             {
<span class="lineNum">    1481 </span><span class="lineNoCov">          0 :               x = mulredc (x, x, n, ni);</span>
<span class="lineNum">    1482 </span><span class="lineNoCov">          0 :               addmod (x, x, a, n);</span>
<span class="lineNum">    1483 </span>            : 
<span class="lineNum">    1484 </span><span class="lineNoCov">          0 :               submod (t, z, x, n);</span>
<span class="lineNum">    1485 </span><span class="lineNoCov">          0 :               P = mulredc (P, t, n, ni);</span>
<span class="lineNum">    1486 </span>            : 
<span class="lineNum">    1487 </span><span class="lineNoCov">          0 :               if (k % 32 == 1)</span>
<span class="lineNum">    1488 </span>            :                 {
<span class="lineNum">    1489 </span><span class="lineNoCov">          0 :                   if (gcd_odd (P, n) != 1)</span>
<span class="lineNum">    1490 </span>            :                     goto factor_found;
<span class="lineNum">    1491 </span>            :                   y = x;
<span class="lineNum">    1492 </span>            :                 }
<span class="lineNum">    1493 </span>            :             }
<span class="lineNum">    1494 </span><span class="lineNoCov">          0 :           while (--k != 0);</span>
<span class="lineNum">    1495 </span>            : 
<span class="lineNum">    1496 </span><span class="lineNoCov">          0 :           z = x;</span>
<span class="lineNum">    1497 </span><span class="lineNoCov">          0 :           k = l;</span>
<span class="lineNum">    1498 </span><span class="lineNoCov">          0 :           l = 2 * l;</span>
<span class="lineNum">    1499 </span><span class="lineNoCov">          0 :           for (unsigned long int i = 0; i &lt; k; i++)</span>
<span class="lineNum">    1500 </span>            :             {
<span class="lineNum">    1501 </span><span class="lineNoCov">          0 :               x = mulredc (x, x, n, ni);</span>
<span class="lineNum">    1502 </span><span class="lineNoCov">          0 :               addmod (x, x, a, n);</span>
<span class="lineNum">    1503 </span>            :             }
<span class="lineNum">    1504 </span>            :           y = x;
<span class="lineNum">    1505 </span>            :         }
<span class="lineNum">    1506 </span>            : 
<span class="lineNum">    1507 </span>            :     factor_found:
<span class="lineNum">    1508 </span>            :       do
<span class="lineNum">    1509 </span>            :         {
<span class="lineNum">    1510 </span><span class="lineNoCov">          0 :           y = mulredc (y, y, n, ni);</span>
<span class="lineNum">    1511 </span><span class="lineNoCov">          0 :           addmod (y, y, a, n);</span>
<span class="lineNum">    1512 </span>            : 
<span class="lineNum">    1513 </span><span class="lineNoCov">          0 :           submod (t, z, y, n);</span>
<span class="lineNum">    1514 </span><span class="lineNoCov">          0 :           g = gcd_odd (t, n);</span>
<span class="lineNum">    1515 </span>            :         }
<span class="lineNum">    1516 </span><span class="lineNoCov">          0 :       while (g == 1);</span>
<span class="lineNum">    1517 </span>            : 
<span class="lineNum">    1518 </span><span class="lineNoCov">          0 :       n = n / g;</span>
<span class="lineNum">    1519 </span>            : 
<span class="lineNum">    1520 </span><span class="lineNoCov">          0 :       if (!prime_p (g))</span>
<span class="lineNum">    1521 </span><span class="lineNoCov">          0 :         factor_using_pollard_rho (g, a + 1, factors);</span>
<span class="lineNum">    1522 </span>            :       else
<span class="lineNum">    1523 </span><span class="lineNoCov">          0 :         factor_insert (factors, g);</span>
<span class="lineNum">    1524 </span>            : 
<span class="lineNum">    1525 </span><span class="lineNoCov">          0 :       if (prime_p (n))</span>
<span class="lineNum">    1526 </span>            :         {
<span class="lineNum">    1527 </span><span class="lineNoCov">          0 :           factor_insert (factors, n);</span>
<span class="lineNum">    1528 </span><span class="lineNoCov">          0 :           break;</span>
<span class="lineNum">    1529 </span>            :         }
<span class="lineNum">    1530 </span>            : 
<span class="lineNum">    1531 </span><span class="lineNoCov">          0 :       x = x % n;</span>
<span class="lineNum">    1532 </span><span class="lineNoCov">          0 :       z = z % n;</span>
<span class="lineNum">    1533 </span><span class="lineNoCov">          0 :       y = y % n;</span>
<span class="lineNum">    1534 </span>            :     }
<span class="lineNum">    1535 </span><span class="lineNoCov">          0 : }</span>
<a name="1536"><span class="lineNum">    1536 </span>            : </a>
<span class="lineNum">    1537 </span>            : static void
<span class="lineNum">    1538 </span><span class="lineNoCov">          0 : factor_using_pollard_rho2 (uintmax_t n1, uintmax_t n0, unsigned long int a,</span>
<span class="lineNum">    1539 </span>            :                            struct factors *factors)
<span class="lineNum">    1540 </span>            : {
<span class="lineNum">    1541 </span>            :   uintmax_t x1, x0, z1, z0, y1, y0, P1, P0, t1, t0, ni, g1, g0, r1m;
<span class="lineNum">    1542 </span>            : 
<span class="lineNum">    1543 </span><span class="lineNoCov">          0 :   unsigned long int k = 1;</span>
<span class="lineNum">    1544 </span><span class="lineNoCov">          0 :   unsigned long int l = 1;</span>
<span class="lineNum">    1545 </span>            : 
<span class="lineNum">    1546 </span><span class="lineNoCov">          0 :   redcify2 (P1, P0, 1, n1, n0);</span>
<span class="lineNum">    1547 </span><span class="lineNoCov">          0 :   addmod2 (x1, x0, P1, P0, P1, P0, n1, n0); /* i.e., redcify(2) */</span>
<span class="lineNum">    1548 </span><span class="lineNoCov">          0 :   y1 = z1 = x1;</span>
<span class="lineNum">    1549 </span><span class="lineNoCov">          0 :   y0 = z0 = x0;</span>
<span class="lineNum">    1550 </span>            : 
<span class="lineNum">    1551 </span><span class="lineNoCov">          0 :   while (n1 != 0 || n0 != 1)</span>
<span class="lineNum">    1552 </span>            :     {
<span class="lineNum">    1553 </span><span class="lineNoCov">          0 :       binv (ni, n0);</span>
<span class="lineNum">    1554 </span>            : 
<span class="lineNum">    1555 </span>            :       for (;;)
<span class="lineNum">    1556 </span>            :         {
<span class="lineNum">    1557 </span>            :           do
<span class="lineNum">    1558 </span>            :             {
<span class="lineNum">    1559 </span><span class="lineNoCov">          0 :               x0 = mulredc2 (&amp;r1m, x1, x0, x1, x0, n1, n0, ni);</span>
<span class="lineNum">    1560 </span><span class="lineNoCov">          0 :               x1 = r1m;</span>
<span class="lineNum">    1561 </span><span class="lineNoCov">          0 :               addmod2 (x1, x0, x1, x0, 0, (uintmax_t) a, n1, n0);</span>
<span class="lineNum">    1562 </span>            : 
<span class="lineNum">    1563 </span><span class="lineNoCov">          0 :               submod2 (t1, t0, z1, z0, x1, x0, n1, n0);</span>
<span class="lineNum">    1564 </span><span class="lineNoCov">          0 :               P0 = mulredc2 (&amp;r1m, P1, P0, t1, t0, n1, n0, ni);</span>
<span class="lineNum">    1565 </span><span class="lineNoCov">          0 :               P1 = r1m;</span>
<span class="lineNum">    1566 </span>            : 
<span class="lineNum">    1567 </span><span class="lineNoCov">          0 :               if (k % 32 == 1)</span>
<span class="lineNum">    1568 </span>            :                 {
<span class="lineNum">    1569 </span><span class="lineNoCov">          0 :                   g0 = gcd2_odd (&amp;g1, P1, P0, n1, n0);</span>
<span class="lineNum">    1570 </span><span class="lineNoCov">          0 :                   if (g1 != 0 || g0 != 1)</span>
<span class="lineNum">    1571 </span>            :                     goto factor_found;
<span class="lineNum">    1572 </span><span class="lineNoCov">          0 :                   y1 = x1; y0 = x0;</span>
<span class="lineNum">    1573 </span>            :                 }
<span class="lineNum">    1574 </span>            :             }
<span class="lineNum">    1575 </span><span class="lineNoCov">          0 :           while (--k != 0);</span>
<span class="lineNum">    1576 </span>            : 
<span class="lineNum">    1577 </span><span class="lineNoCov">          0 :           z1 = x1; z0 = x0;</span>
<span class="lineNum">    1578 </span><span class="lineNoCov">          0 :           k = l;</span>
<span class="lineNum">    1579 </span><span class="lineNoCov">          0 :           l = 2 * l;</span>
<span class="lineNum">    1580 </span><span class="lineNoCov">          0 :           for (unsigned long int i = 0; i &lt; k; i++)</span>
<span class="lineNum">    1581 </span>            :             {
<span class="lineNum">    1582 </span><span class="lineNoCov">          0 :               x0 = mulredc2 (&amp;r1m, x1, x0, x1, x0, n1, n0, ni);</span>
<span class="lineNum">    1583 </span><span class="lineNoCov">          0 :               x1 = r1m;</span>
<span class="lineNum">    1584 </span><span class="lineNoCov">          0 :               addmod2 (x1, x0, x1, x0, 0, (uintmax_t) a, n1, n0);</span>
<span class="lineNum">    1585 </span>            :             }
<span class="lineNum">    1586 </span><span class="lineNoCov">          0 :           y1 = x1; y0 = x0;</span>
<span class="lineNum">    1587 </span><span class="lineNoCov">          0 :         }</span>
<span class="lineNum">    1588 </span>            : 
<span class="lineNum">    1589 </span>            :     factor_found:
<span class="lineNum">    1590 </span>            :       do
<span class="lineNum">    1591 </span>            :         {
<span class="lineNum">    1592 </span><span class="lineNoCov">          0 :           y0 = mulredc2 (&amp;r1m, y1, y0, y1, y0, n1, n0, ni);</span>
<span class="lineNum">    1593 </span><span class="lineNoCov">          0 :           y1 = r1m;</span>
<span class="lineNum">    1594 </span><span class="lineNoCov">          0 :           addmod2 (y1, y0, y1, y0, 0, (uintmax_t) a, n1, n0);</span>
<span class="lineNum">    1595 </span>            : 
<span class="lineNum">    1596 </span><span class="lineNoCov">          0 :           submod2 (t1, t0, z1, z0, y1, y0, n1, n0);</span>
<span class="lineNum">    1597 </span><span class="lineNoCov">          0 :           g0 = gcd2_odd (&amp;g1, t1, t0, n1, n0);</span>
<span class="lineNum">    1598 </span>            :         }
<span class="lineNum">    1599 </span><span class="lineNoCov">          0 :       while (g1 == 0 &amp;&amp; g0 == 1);</span>
<span class="lineNum">    1600 </span>            : 
<span class="lineNum">    1601 </span><span class="lineNoCov">          0 :       if (g1 == 0)</span>
<span class="lineNum">    1602 </span>            :         {
<span class="lineNum">    1603 </span>            :           /* The found factor is one word. */
<span class="lineNum">    1604 </span><span class="lineNoCov">          0 :           divexact_21 (n1, n0, n1, n0, g0);     /* n = n / g */</span>
<span class="lineNum">    1605 </span>            : 
<span class="lineNum">    1606 </span><span class="lineNoCov">          0 :           if (!prime_p (g0))</span>
<span class="lineNum">    1607 </span><span class="lineNoCov">          0 :             factor_using_pollard_rho (g0, a + 1, factors);</span>
<span class="lineNum">    1608 </span>            :           else
<span class="lineNum">    1609 </span><span class="lineNoCov">          0 :             factor_insert (factors, g0);</span>
<span class="lineNum">    1610 </span>            :         }
<span class="lineNum">    1611 </span>            :       else
<span class="lineNum">    1612 </span>            :         {
<span class="lineNum">    1613 </span>            :           /* The found factor is two words.  This is highly unlikely, thus hard
<span class="lineNum">    1614 </span>            :              to trigger.  Please be careful before you change this code!  */
<span class="lineNum">    1615 </span>            :           uintmax_t ginv;
<span class="lineNum">    1616 </span>            : 
<span class="lineNum">    1617 </span><span class="lineNoCov">          0 :           binv (ginv, g0);      /* Compute n = n / g.  Since the result will */</span>
<span class="lineNum">    1618 </span><span class="lineNoCov">          0 :           n0 = ginv * n0;       /* fit one word, we can compute the quotient */</span>
<span class="lineNum">    1619 </span><span class="lineNoCov">          0 :           n1 = 0;               /* modulo B, ignoring the high divisor word. */</span>
<span class="lineNum">    1620 </span>            : 
<span class="lineNum">    1621 </span><span class="lineNoCov">          0 :           if (!prime2_p (g1, g0))</span>
<span class="lineNum">    1622 </span><span class="lineNoCov">          0 :             factor_using_pollard_rho2 (g1, g0, a + 1, factors);</span>
<span class="lineNum">    1623 </span>            :           else
<span class="lineNum">    1624 </span><span class="lineNoCov">          0 :             factor_insert_large (factors, g1, g0);</span>
<span class="lineNum">    1625 </span>            :         }
<span class="lineNum">    1626 </span>            : 
<span class="lineNum">    1627 </span><span class="lineNoCov">          0 :       if (n1 == 0)</span>
<span class="lineNum">    1628 </span>            :         {
<span class="lineNum">    1629 </span><span class="lineNoCov">          0 :           if (prime_p (n0))</span>
<span class="lineNum">    1630 </span>            :             {
<span class="lineNum">    1631 </span><span class="lineNoCov">          0 :               factor_insert (factors, n0);</span>
<span class="lineNum">    1632 </span><span class="lineNoCov">          0 :               break;</span>
<span class="lineNum">    1633 </span>            :             }
<span class="lineNum">    1634 </span>            : 
<span class="lineNum">    1635 </span><span class="lineNoCov">          0 :           factor_using_pollard_rho (n0, a, factors);</span>
<span class="lineNum">    1636 </span><span class="lineNoCov">          0 :           return;</span>
<span class="lineNum">    1637 </span>            :         }
<span class="lineNum">    1638 </span>            : 
<span class="lineNum">    1639 </span><span class="lineNoCov">          0 :       if (prime2_p (n1, n0))</span>
<span class="lineNum">    1640 </span>            :         {
<span class="lineNum">    1641 </span><span class="lineNoCov">          0 :           factor_insert_large (factors, n1, n0);</span>
<span class="lineNum">    1642 </span><span class="lineNoCov">          0 :           break;</span>
<span class="lineNum">    1643 </span>            :         }
<span class="lineNum">    1644 </span>            : 
<span class="lineNum">    1645 </span><span class="lineNoCov">          0 :       x0 = mod2 (&amp;x1, x1, x0, n1, n0);</span>
<span class="lineNum">    1646 </span><span class="lineNoCov">          0 :       z0 = mod2 (&amp;z1, z1, z0, n1, n0);</span>
<span class="lineNum">    1647 </span><span class="lineNoCov">          0 :       y0 = mod2 (&amp;y1, y1, y0, n1, n0);</span>
<span class="lineNum">    1648 </span>            :     }
<span class="lineNum">    1649 </span>            : }
<span class="lineNum">    1650 </span>            : 
<span class="lineNum">    1651 </span>            : #if HAVE_GMP
<span class="lineNum">    1652 </span>            : static void
<span class="lineNum">    1653 </span>            : mp_factor_using_pollard_rho (mpz_t n, unsigned long int a,
<span class="lineNum">    1654 </span>            :                              struct mp_factors *factors)
<span class="lineNum">    1655 </span>            : {
<span class="lineNum">    1656 </span>            :   mpz_t x, z, y, P;
<span class="lineNum">    1657 </span>            :   mpz_t t, t2;
<span class="lineNum">    1658 </span>            : 
<span class="lineNum">    1659 </span>            :   devmsg (&quot;[pollard-rho (%lu)] &quot;, a);
<span class="lineNum">    1660 </span>            : 
<span class="lineNum">    1661 </span>            :   mpz_inits (t, t2, NULL);
<span class="lineNum">    1662 </span>            :   mpz_init_set_si (y, 2);
<span class="lineNum">    1663 </span>            :   mpz_init_set_si (x, 2);
<span class="lineNum">    1664 </span>            :   mpz_init_set_si (z, 2);
<span class="lineNum">    1665 </span>            :   mpz_init_set_ui (P, 1);
<span class="lineNum">    1666 </span>            : 
<span class="lineNum">    1667 </span>            :   unsigned long long int k = 1;
<span class="lineNum">    1668 </span>            :   unsigned long long int l = 1;
<span class="lineNum">    1669 </span>            : 
<span class="lineNum">    1670 </span>            :   while (mpz_cmp_ui (n, 1) != 0)
<span class="lineNum">    1671 </span>            :     {
<span class="lineNum">    1672 </span>            :       for (;;)
<span class="lineNum">    1673 </span>            :         {
<span class="lineNum">    1674 </span>            :           do
<span class="lineNum">    1675 </span>            :             {
<span class="lineNum">    1676 </span>            :               mpz_mul (t, x, x);
<span class="lineNum">    1677 </span>            :               mpz_mod (x, t, n);
<span class="lineNum">    1678 </span>            :               mpz_add_ui (x, x, a);
<span class="lineNum">    1679 </span>            : 
<span class="lineNum">    1680 </span>            :               mpz_sub (t, z, x);
<span class="lineNum">    1681 </span>            :               mpz_mul (t2, P, t);
<span class="lineNum">    1682 </span>            :               mpz_mod (P, t2, n);
<span class="lineNum">    1683 </span>            : 
<span class="lineNum">    1684 </span>            :               if (k % 32 == 1)
<span class="lineNum">    1685 </span>            :                 {
<span class="lineNum">    1686 </span>            :                   mpz_gcd (t, P, n);
<span class="lineNum">    1687 </span>            :                   if (mpz_cmp_ui (t, 1) != 0)
<span class="lineNum">    1688 </span>            :                     goto factor_found;
<span class="lineNum">    1689 </span>            :                   mpz_set (y, x);
<span class="lineNum">    1690 </span>            :                 }
<span class="lineNum">    1691 </span>            :             }
<span class="lineNum">    1692 </span>            :           while (--k != 0);
<span class="lineNum">    1693 </span>            : 
<span class="lineNum">    1694 </span>            :           mpz_set (z, x);
<span class="lineNum">    1695 </span>            :           k = l;
<span class="lineNum">    1696 </span>            :           l = 2 * l;
<span class="lineNum">    1697 </span>            :           for (unsigned long long int i = 0; i &lt; k; i++)
<span class="lineNum">    1698 </span>            :             {
<span class="lineNum">    1699 </span>            :               mpz_mul (t, x, x);
<span class="lineNum">    1700 </span>            :               mpz_mod (x, t, n);
<span class="lineNum">    1701 </span>            :               mpz_add_ui (x, x, a);
<span class="lineNum">    1702 </span>            :             }
<span class="lineNum">    1703 </span>            :           mpz_set (y, x);
<span class="lineNum">    1704 </span>            :         }
<span class="lineNum">    1705 </span>            : 
<span class="lineNum">    1706 </span>            :     factor_found:
<span class="lineNum">    1707 </span>            :       do
<span class="lineNum">    1708 </span>            :         {
<span class="lineNum">    1709 </span>            :           mpz_mul (t, y, y);
<span class="lineNum">    1710 </span>            :           mpz_mod (y, t, n);
<span class="lineNum">    1711 </span>            :           mpz_add_ui (y, y, a);
<span class="lineNum">    1712 </span>            : 
<span class="lineNum">    1713 </span>            :           mpz_sub (t, z, y);
<span class="lineNum">    1714 </span>            :           mpz_gcd (t, t, n);
<span class="lineNum">    1715 </span>            :         }
<span class="lineNum">    1716 </span>            :       while (mpz_cmp_ui (t, 1) == 0);
<span class="lineNum">    1717 </span>            : 
<span class="lineNum">    1718 </span>            :       mpz_divexact (n, n, t);   /* divide by t, before t is overwritten */
<span class="lineNum">    1719 </span>            : 
<span class="lineNum">    1720 </span>            :       if (!mp_prime_p (t))
<span class="lineNum">    1721 </span>            :         {
<span class="lineNum">    1722 </span>            :           devmsg (&quot;[composite factor--restarting pollard-rho] &quot;);
<span class="lineNum">    1723 </span>            :           mp_factor_using_pollard_rho (t, a + 1, factors);
<span class="lineNum">    1724 </span>            :         }
<span class="lineNum">    1725 </span>            :       else
<span class="lineNum">    1726 </span>            :         {
<span class="lineNum">    1727 </span>            :           mp_factor_insert (factors, t);
<span class="lineNum">    1728 </span>            :         }
<span class="lineNum">    1729 </span>            : 
<span class="lineNum">    1730 </span>            :       if (mp_prime_p (n))
<span class="lineNum">    1731 </span>            :         {
<span class="lineNum">    1732 </span>            :           mp_factor_insert (factors, n);
<span class="lineNum">    1733 </span>            :           break;
<span class="lineNum">    1734 </span>            :         }
<span class="lineNum">    1735 </span>            : 
<span class="lineNum">    1736 </span>            :       mpz_mod (x, x, n);
<span class="lineNum">    1737 </span>            :       mpz_mod (z, z, n);
<span class="lineNum">    1738 </span>            :       mpz_mod (y, y, n);
<span class="lineNum">    1739 </span>            :     }
<span class="lineNum">    1740 </span>            : 
<span class="lineNum">    1741 </span>            :   mpz_clears (P, t2, t, z, x, y, NULL);
<span class="lineNum">    1742 </span>            : }
<span class="lineNum">    1743 </span>            : #endif
<span class="lineNum">    1744 </span>            : 
<span class="lineNum">    1745 </span>            : #if USE_SQUFOF
<span class="lineNum">    1746 </span>            : /* FIXME: Maybe better to use an iteration converging to 1/sqrt(n)?  If
<span class="lineNum">    1747 </span>            :    algorithm is replaced, consider also returning the remainder. */
<span class="lineNum">    1748 </span>            : static uintmax_t _GL_ATTRIBUTE_CONST
<span class="lineNum">    1749 </span>            : isqrt (uintmax_t n)
<span class="lineNum">    1750 </span>            : {
<span class="lineNum">    1751 </span>            :   uintmax_t x;
<span class="lineNum">    1752 </span>            :   unsigned c;
<span class="lineNum">    1753 </span>            :   if (n == 0)
<span class="lineNum">    1754 </span>            :     return 0;
<span class="lineNum">    1755 </span>            : 
<span class="lineNum">    1756 </span>            :   count_leading_zeros (c, n);
<span class="lineNum">    1757 </span>            : 
<span class="lineNum">    1758 </span>            :   /* Make x &gt; sqrt(n). This will be invariant through the loop. */
<span class="lineNum">    1759 </span>            :   x = (uintmax_t) 1 &lt;&lt; ((W_TYPE_SIZE + 1 - c) / 2);
<span class="lineNum">    1760 </span>            : 
<span class="lineNum">    1761 </span>            :   for (;;)
<span class="lineNum">    1762 </span>            :     {
<span class="lineNum">    1763 </span>            :       uintmax_t y = (x + n/x) / 2;
<span class="lineNum">    1764 </span>            :       if (y &gt;= x)
<span class="lineNum">    1765 </span>            :         return x;
<span class="lineNum">    1766 </span>            : 
<span class="lineNum">    1767 </span>            :       x = y;
<span class="lineNum">    1768 </span>            :     }
<span class="lineNum">    1769 </span>            : }
<span class="lineNum">    1770 </span>            : 
<span class="lineNum">    1771 </span>            : static uintmax_t _GL_ATTRIBUTE_CONST
<span class="lineNum">    1772 </span>            : isqrt2 (uintmax_t nh, uintmax_t nl)
<span class="lineNum">    1773 </span>            : {
<span class="lineNum">    1774 </span>            :   unsigned int shift;
<span class="lineNum">    1775 </span>            :   uintmax_t x;
<span class="lineNum">    1776 </span>            : 
<span class="lineNum">    1777 </span>            :   /* Ensures the remainder fits in an uintmax_t. */
<span class="lineNum">    1778 </span>            :   assert (nh &lt; ((uintmax_t) 1 &lt;&lt; (W_TYPE_SIZE - 2)));
<span class="lineNum">    1779 </span>            : 
<span class="lineNum">    1780 </span>            :   if (nh == 0)
<span class="lineNum">    1781 </span>            :     return isqrt (nl);
<span class="lineNum">    1782 </span>            : 
<span class="lineNum">    1783 </span>            :   count_leading_zeros (shift, nh);
<span class="lineNum">    1784 </span>            :   shift &amp;= ~1;
<span class="lineNum">    1785 </span>            : 
<span class="lineNum">    1786 </span>            :   /* Make x &gt; sqrt(n) */
<span class="lineNum">    1787 </span>            :   x = isqrt ( (nh &lt;&lt; shift) + (nl &gt;&gt; (W_TYPE_SIZE - shift))) + 1;
<span class="lineNum">    1788 </span>            :   x &lt;&lt;= (W_TYPE_SIZE - shift) / 2;
<span class="lineNum">    1789 </span>            : 
<span class="lineNum">    1790 </span>            :   /* Do we need more than one iteration? */
<span class="lineNum">    1791 </span>            :   for (;;)
<span class="lineNum">    1792 </span>            :     {
<span class="lineNum">    1793 </span>            :       uintmax_t r _GL_UNUSED;
<span class="lineNum">    1794 </span>            :       uintmax_t q, y;
<span class="lineNum">    1795 </span>            :       udiv_qrnnd (q, r, nh, nl, x);
<span class="lineNum">    1796 </span>            :       y = (x + q) / 2;
<span class="lineNum">    1797 </span>            : 
<span class="lineNum">    1798 </span>            :       if (y &gt;= x)
<span class="lineNum">    1799 </span>            :         {
<span class="lineNum">    1800 </span>            :           uintmax_t hi, lo;
<span class="lineNum">    1801 </span>            :           umul_ppmm (hi, lo, x + 1, x + 1);
<span class="lineNum">    1802 </span>            :           assert (gt2 (hi, lo, nh, nl));
<span class="lineNum">    1803 </span>            : 
<span class="lineNum">    1804 </span>            :           umul_ppmm (hi, lo, x, x);
<span class="lineNum">    1805 </span>            :           assert (ge2 (nh, nl, hi, lo));
<span class="lineNum">    1806 </span>            :           sub_ddmmss (hi, lo, nh, nl, hi, lo);
<span class="lineNum">    1807 </span>            :           assert (hi == 0);
<span class="lineNum">    1808 </span>            : 
<span class="lineNum">    1809 </span>            :           return x;
<span class="lineNum">    1810 </span>            :         }
<span class="lineNum">    1811 </span>            : 
<span class="lineNum">    1812 </span>            :       x = y;
<span class="lineNum">    1813 </span>            :     }
<span class="lineNum">    1814 </span>            : }
<span class="lineNum">    1815 </span>            : 
<span class="lineNum">    1816 </span>            : /* MAGIC[N] has a bit i set iff i is a quadratic residue mod N. */
<span class="lineNum">    1817 </span>            : # define MAGIC64 0x0202021202030213ULL
<span class="lineNum">    1818 </span>            : # define MAGIC63 0x0402483012450293ULL
<span class="lineNum">    1819 </span>            : # define MAGIC65 0x218a019866014613ULL
<span class="lineNum">    1820 </span>            : # define MAGIC11 0x23b
<span class="lineNum">    1821 </span>            : 
<span class="lineNum">    1822 </span>            : /* Return the square root if the input is a square, otherwise 0. */
<span class="lineNum">    1823 </span>            : static uintmax_t _GL_ATTRIBUTE_CONST
<span class="lineNum">    1824 </span>            : is_square (uintmax_t x)
<span class="lineNum">    1825 </span>            : {
<span class="lineNum">    1826 </span>            :   /* Uses the tests suggested by Cohen. Excludes 99% of the non-squares before
<span class="lineNum">    1827 </span>            :      computing the square root. */
<span class="lineNum">    1828 </span>            :   if (((MAGIC64 &gt;&gt; (x &amp; 63)) &amp; 1)
<span class="lineNum">    1829 </span>            :       &amp;&amp; ((MAGIC63 &gt;&gt; (x % 63)) &amp; 1)
<span class="lineNum">    1830 </span>            :       /* Both 0 and 64 are squares mod (65) */
<span class="lineNum">    1831 </span>            :       &amp;&amp; ((MAGIC65 &gt;&gt; ((x % 65) &amp; 63)) &amp; 1)
<span class="lineNum">    1832 </span>            :       &amp;&amp; ((MAGIC11 &gt;&gt; (x % 11) &amp; 1)))
<span class="lineNum">    1833 </span>            :     {
<span class="lineNum">    1834 </span>            :       uintmax_t r = isqrt (x);
<span class="lineNum">    1835 </span>            :       if (r*r == x)
<span class="lineNum">    1836 </span>            :         return r;
<span class="lineNum">    1837 </span>            :     }
<span class="lineNum">    1838 </span>            :   return 0;
<span class="lineNum">    1839 </span>            : }
<span class="lineNum">    1840 </span>            : 
<span class="lineNum">    1841 </span>            : /* invtab[i] = floor(0x10000 / (0x100 + i) */
<span class="lineNum">    1842 </span>            : static const unsigned short invtab[0x81] =
<span class="lineNum">    1843 </span>            :   {
<span class="lineNum">    1844 </span>            :     0x200,
<span class="lineNum">    1845 </span>            :     0x1fc, 0x1f8, 0x1f4, 0x1f0, 0x1ec, 0x1e9, 0x1e5, 0x1e1,
<span class="lineNum">    1846 </span>            :     0x1de, 0x1da, 0x1d7, 0x1d4, 0x1d0, 0x1cd, 0x1ca, 0x1c7,
<span class="lineNum">    1847 </span>            :     0x1c3, 0x1c0, 0x1bd, 0x1ba, 0x1b7, 0x1b4, 0x1b2, 0x1af,
<span class="lineNum">    1848 </span>            :     0x1ac, 0x1a9, 0x1a6, 0x1a4, 0x1a1, 0x19e, 0x19c, 0x199,
<span class="lineNum">    1849 </span>            :     0x197, 0x194, 0x192, 0x18f, 0x18d, 0x18a, 0x188, 0x186,
<span class="lineNum">    1850 </span>            :     0x183, 0x181, 0x17f, 0x17d, 0x17a, 0x178, 0x176, 0x174,
<span class="lineNum">    1851 </span>            :     0x172, 0x170, 0x16e, 0x16c, 0x16a, 0x168, 0x166, 0x164,
<span class="lineNum">    1852 </span>            :     0x162, 0x160, 0x15e, 0x15c, 0x15a, 0x158, 0x157, 0x155,
<span class="lineNum">    1853 </span>            :     0x153, 0x151, 0x150, 0x14e, 0x14c, 0x14a, 0x149, 0x147,
<span class="lineNum">    1854 </span>            :     0x146, 0x144, 0x142, 0x141, 0x13f, 0x13e, 0x13c, 0x13b,
<span class="lineNum">    1855 </span>            :     0x139, 0x138, 0x136, 0x135, 0x133, 0x132, 0x130, 0x12f,
<span class="lineNum">    1856 </span>            :     0x12e, 0x12c, 0x12b, 0x129, 0x128, 0x127, 0x125, 0x124,
<span class="lineNum">    1857 </span>            :     0x123, 0x121, 0x120, 0x11f, 0x11e, 0x11c, 0x11b, 0x11a,
<span class="lineNum">    1858 </span>            :     0x119, 0x118, 0x116, 0x115, 0x114, 0x113, 0x112, 0x111,
<span class="lineNum">    1859 </span>            :     0x10f, 0x10e, 0x10d, 0x10c, 0x10b, 0x10a, 0x109, 0x108,
<span class="lineNum">    1860 </span>            :     0x107, 0x106, 0x105, 0x104, 0x103, 0x102, 0x101, 0x100,
<span class="lineNum">    1861 </span>            :   };
<span class="lineNum">    1862 </span>            : 
<span class="lineNum">    1863 </span>            : /* Compute q = [u/d], r = u mod d.  Avoids slow hardware division for the case
<span class="lineNum">    1864 </span>            :    that q &lt; 0x40; here it instead uses a table of (Euclidian) inverses.  */
<span class="lineNum">    1865 </span>            : # define div_smallq(q, r, u, d)                                          \
<span class="lineNum">    1866 </span>            :   do {                                                                  \
<span class="lineNum">    1867 </span>            :     if ((u) / 0x40 &lt; (d))                                               \
<span class="lineNum">    1868 </span>            :       {                                                                 \
<span class="lineNum">    1869 </span>            :         int _cnt;                                                       \
<span class="lineNum">    1870 </span>            :         uintmax_t _dinv, _mask, _q, _r;                                 \
<span class="lineNum">    1871 </span>            :         count_leading_zeros (_cnt, (d));                                \
<span class="lineNum">    1872 </span>            :         _r = (u);                                                       \
<span class="lineNum">    1873 </span>            :         if (UNLIKELY (_cnt &gt; (W_TYPE_SIZE - 8)))                        \
<span class="lineNum">    1874 </span>            :           {                                                             \
<span class="lineNum">    1875 </span>            :             _dinv = invtab[((d) &lt;&lt; (_cnt + 8 - W_TYPE_SIZE)) - 0x80];   \
<span class="lineNum">    1876 </span>            :             _q = _dinv * _r &gt;&gt; (8 + W_TYPE_SIZE - _cnt);                \
<span class="lineNum">    1877 </span>            :           }                                                             \
<span class="lineNum">    1878 </span>            :         else                                                            \
<span class="lineNum">    1879 </span>            :           {                                                             \
<span class="lineNum">    1880 </span>            :             _dinv = invtab[((d) &gt;&gt; (W_TYPE_SIZE - 8 - _cnt)) - 0x7f];   \
<span class="lineNum">    1881 </span>            :             _q = _dinv * (_r &gt;&gt; (W_TYPE_SIZE - 3 - _cnt)) &gt;&gt; 11;        \
<span class="lineNum">    1882 </span>            :           }                                                             \
<span class="lineNum">    1883 </span>            :         _r -= _q*(d);                                                   \
<span class="lineNum">    1884 </span>            :                                                                         \
<span class="lineNum">    1885 </span>            :         _mask = -(uintmax_t) (_r &gt;= (d));                               \
<span class="lineNum">    1886 </span>            :         (r) = _r - (_mask &amp; (d));                                       \
<span class="lineNum">    1887 </span>            :         (q) = _q - _mask;                                               \
<span class="lineNum">    1888 </span>            :         assert ( (q) * (d) + (r) == u);                                 \
<span class="lineNum">    1889 </span>            :       }                                                                 \
<span class="lineNum">    1890 </span>            :     else                                                                \
<span class="lineNum">    1891 </span>            :       {                                                                 \
<span class="lineNum">    1892 </span>            :         uintmax_t _q = (u) / (d);                                       \
<span class="lineNum">    1893 </span>            :         (r) = (u) - _q * (d);                                           \
<span class="lineNum">    1894 </span>            :         (q) = _q;                                                       \
<span class="lineNum">    1895 </span>            :       }                                                                 \
<span class="lineNum">    1896 </span>            :   } while (0)
<span class="lineNum">    1897 </span>            : 
<span class="lineNum">    1898 </span>            : /* Notes: Example N = 22117019. After first phase we find Q1 = 6314, Q
<span class="lineNum">    1899 </span>            :    = 3025, P = 1737, representing F_{18} = (-6314, 2* 1737, 3025),
<span class="lineNum">    1900 </span>            :    with 3025 = 55^2.
<span class="lineNum">    1901 </span>            : 
<span class="lineNum">    1902 </span>            :    Constructing the square root, we get Q1 = 55, Q = 8653, P = 4652,
<span class="lineNum">    1903 </span>            :    representing G_0 = (-55, 2*4652, 8653).
<span class="lineNum">    1904 </span>            : 
<span class="lineNum">    1905 </span>            :    In the notation of the paper:
<span class="lineNum">    1906 </span>            : 
<span class="lineNum">    1907 </span>            :    S_{-1} = 55, S_0 = 8653, R_0 = 4652
<span class="lineNum">    1908 </span>            : 
<span class="lineNum">    1909 </span>            :    Put
<span class="lineNum">    1910 </span>            : 
<span class="lineNum">    1911 </span>            :      t_0 = floor([q_0 + R_0] / S0) = 1
<span class="lineNum">    1912 </span>            :      R_1 = t_0 * S_0 - R_0 = 4001
<span class="lineNum">    1913 </span>            :      S_1 = S_{-1} +t_0 (R_0 - R_1) = 706
<span class="lineNum">    1914 </span>            : */
<span class="lineNum">    1915 </span>            : 
<span class="lineNum">    1916 </span>            : /* Multipliers, in order of efficiency:
<span class="lineNum">    1917 </span>            :    0.7268  3*5*7*11 = 1155 = 3 (mod 4)
<span class="lineNum">    1918 </span>            :    0.7317  3*5*7    =  105 = 1
<span class="lineNum">    1919 </span>            :    0.7820  3*5*11   =  165 = 1
<span class="lineNum">    1920 </span>            :    0.7872  3*5      =   15 = 3
<span class="lineNum">    1921 </span>            :    0.8101  3*7*11   =  231 = 3
<span class="lineNum">    1922 </span>            :    0.8155  3*7      =   21 = 1
<span class="lineNum">    1923 </span>            :    0.8284  5*7*11   =  385 = 1
<span class="lineNum">    1924 </span>            :    0.8339  5*7      =   35 = 3
<span class="lineNum">    1925 </span>            :    0.8716  3*11     =   33 = 1
<span class="lineNum">    1926 </span>            :    0.8774  3        =    3 = 3
<span class="lineNum">    1927 </span>            :    0.8913  5*11     =   55 = 3
<span class="lineNum">    1928 </span>            :    0.8972  5        =    5 = 1
<span class="lineNum">    1929 </span>            :    0.9233  7*11     =   77 = 1
<span class="lineNum">    1930 </span>            :    0.9295  7        =    7 = 3
<span class="lineNum">    1931 </span>            :    0.9934  11       =   11 = 3
<span class="lineNum">    1932 </span>            : */
<span class="lineNum">    1933 </span>            : # define QUEUE_SIZE 50
<span class="lineNum">    1934 </span>            : #endif
<span class="lineNum">    1935 </span>            : 
<span class="lineNum">    1936 </span>            : #if STAT_SQUFOF
<span class="lineNum">    1937 </span>            : # define Q_FREQ_SIZE 50
<span class="lineNum">    1938 </span>            : /* Element 0 keeps the total */
<span class="lineNum">    1939 </span>            : static unsigned int q_freq[Q_FREQ_SIZE + 1];
<span class="lineNum">    1940 </span>            : # define MIN(a,b) ((a) &lt; (b) ? (a) : (b))
<span class="lineNum">    1941 </span>            : #endif
<span class="lineNum">    1942 </span>            : 
<span class="lineNum">    1943 </span>            : #if USE_SQUFOF
<span class="lineNum">    1944 </span>            : /* Return true on success.  Expected to fail only for numbers
<span class="lineNum">    1945 </span>            :    &gt;= 2^{2*W_TYPE_SIZE - 2}, or close to that limit. */
<span class="lineNum">    1946 </span>            : static bool
<span class="lineNum">    1947 </span>            : factor_using_squfof (uintmax_t n1, uintmax_t n0, struct factors *factors)
<span class="lineNum">    1948 </span>            : {
<span class="lineNum">    1949 </span>            :   /* Uses algorithm and notation from
<span class="lineNum">    1950 </span>            : 
<span class="lineNum">    1951 </span>            :      SQUARE FORM FACTORIZATION
<span class="lineNum">    1952 </span>            :      JASON E. GOWER AND SAMUEL S. WAGSTAFF, JR.
<span class="lineNum">    1953 </span>            : 
<span class="lineNum">    1954 </span>            :      http://homes.cerias.purdue.edu/~ssw/squfof.pdf
<span class="lineNum">    1955 </span>            :    */
<span class="lineNum">    1956 </span>            : 
<span class="lineNum">    1957 </span>            :   static const unsigned int multipliers_1[] =
<span class="lineNum">    1958 </span>            :     { /* = 1 (mod 4) */
<span class="lineNum">    1959 </span>            :       105, 165, 21, 385, 33, 5, 77, 1, 0
<span class="lineNum">    1960 </span>            :     };
<span class="lineNum">    1961 </span>            :   static const unsigned int multipliers_3[] =
<span class="lineNum">    1962 </span>            :     { /* = 3 (mod 4) */
<span class="lineNum">    1963 </span>            :       1155, 15, 231, 35, 3, 55, 7, 11, 0
<span class="lineNum">    1964 </span>            :     };
<span class="lineNum">    1965 </span>            : 
<span class="lineNum">    1966 </span>            :   const unsigned int *m;
<span class="lineNum">    1967 </span>            : 
<span class="lineNum">    1968 </span>            :   struct { uintmax_t Q; uintmax_t P; } queue[QUEUE_SIZE];
<span class="lineNum">    1969 </span>            : 
<span class="lineNum">    1970 </span>            :   if (n1 &gt;= ((uintmax_t) 1 &lt;&lt; (W_TYPE_SIZE - 2)))
<span class="lineNum">    1971 </span>            :     return false;
<span class="lineNum">    1972 </span>            : 
<span class="lineNum">    1973 </span>            :   uintmax_t sqrt_n = isqrt2 (n1, n0);
<span class="lineNum">    1974 </span>            : 
<span class="lineNum">    1975 </span>            :   if (n0 == sqrt_n * sqrt_n)
<span class="lineNum">    1976 </span>            :     {
<span class="lineNum">    1977 </span>            :       uintmax_t p1, p0;
<span class="lineNum">    1978 </span>            : 
<span class="lineNum">    1979 </span>            :       umul_ppmm (p1, p0, sqrt_n, sqrt_n);
<span class="lineNum">    1980 </span>            :       assert (p0 == n0);
<span class="lineNum">    1981 </span>            : 
<span class="lineNum">    1982 </span>            :       if (n1 == p1)
<span class="lineNum">    1983 </span>            :         {
<span class="lineNum">    1984 </span>            :           if (prime_p (sqrt_n))
<span class="lineNum">    1985 </span>            :             factor_insert_multiplicity (factors, sqrt_n, 2);
<span class="lineNum">    1986 </span>            :           else
<span class="lineNum">    1987 </span>            :             {
<span class="lineNum">    1988 </span>            :               struct factors f;
<span class="lineNum">    1989 </span>            : 
<span class="lineNum">    1990 </span>            :               f.nfactors = 0;
<span class="lineNum">    1991 </span>            :               if (!factor_using_squfof (0, sqrt_n, &amp;f))
<span class="lineNum">    1992 </span>            :                 {
<span class="lineNum">    1993 </span>            :                   /* Try pollard rho instead */
<span class="lineNum">    1994 </span>            :                   factor_using_pollard_rho (sqrt_n, 1, &amp;f);
<span class="lineNum">    1995 </span>            :                 }
<span class="lineNum">    1996 </span>            :               /* Duplicate the new factors */
<span class="lineNum">    1997 </span>            :               for (unsigned int i = 0; i &lt; f.nfactors; i++)
<span class="lineNum">    1998 </span>            :                 factor_insert_multiplicity (factors, f.p[i], 2*f.e[i]);
<span class="lineNum">    1999 </span>            :             }
<span class="lineNum">    2000 </span>            :           return true;
<span class="lineNum">    2001 </span>            :         }
<span class="lineNum">    2002 </span>            :     }
<span class="lineNum">    2003 </span>            : 
<span class="lineNum">    2004 </span>            :   /* Select multipliers so we always get n * mu = 3 (mod 4) */
<span class="lineNum">    2005 </span>            :   for (m = (n0 % 4 == 1) ? multipliers_3 : multipliers_1;
<span class="lineNum">    2006 </span>            :        *m; m++)
<span class="lineNum">    2007 </span>            :     {
<span class="lineNum">    2008 </span>            :       uintmax_t S, Dh, Dl, Q1, Q, P, L, L1, B;
<span class="lineNum">    2009 </span>            :       unsigned int i;
<span class="lineNum">    2010 </span>            :       unsigned int mu = *m;
<span class="lineNum">    2011 </span>            :       unsigned int qpos = 0;
<span class="lineNum">    2012 </span>            : 
<span class="lineNum">    2013 </span>            :       assert (mu * n0 % 4 == 3);
<span class="lineNum">    2014 </span>            : 
<span class="lineNum">    2015 </span>            :       /* In the notation of the paper, with mu * n == 3 (mod 4), we
<span class="lineNum">    2016 </span>            :          get \Delta = 4 mu * n, and the paper's \mu is 2 mu. As far as
<span class="lineNum">    2017 </span>            :          I understand it, the necessary bound is 4 \mu^3 &lt; n, or 32
<span class="lineNum">    2018 </span>            :          mu^3 &lt; n.
<span class="lineNum">    2019 </span>            : 
<span class="lineNum">    2020 </span>            :          However, this seems insufficient: With n = 37243139 and mu =
<span class="lineNum">    2021 </span>            :          105, we get a trivial factor, from the square 38809 = 197^2,
<span class="lineNum">    2022 </span>            :          without any corresponding Q earlier in the iteration.
<span class="lineNum">    2023 </span>            : 
<span class="lineNum">    2024 </span>            :          Requiring 64 mu^3 &lt; n seems sufficient. */
<span class="lineNum">    2025 </span>            :       if (n1 == 0)
<span class="lineNum">    2026 </span>            :         {
<span class="lineNum">    2027 </span>            :           if ((uintmax_t) mu*mu*mu &gt;= n0 / 64)
<span class="lineNum">    2028 </span>            :             continue;
<span class="lineNum">    2029 </span>            :         }
<span class="lineNum">    2030 </span>            :       else
<span class="lineNum">    2031 </span>            :         {
<span class="lineNum">    2032 </span>            :           if (n1 &gt; ((uintmax_t) 1 &lt;&lt; (W_TYPE_SIZE - 2)) / mu)
<span class="lineNum">    2033 </span>            :             continue;
<span class="lineNum">    2034 </span>            :         }
<span class="lineNum">    2035 </span>            :       umul_ppmm (Dh, Dl, n0, mu);
<span class="lineNum">    2036 </span>            :       Dh += n1 * mu;
<span class="lineNum">    2037 </span>            : 
<span class="lineNum">    2038 </span>            :       assert (Dl % 4 != 1);
<span class="lineNum">    2039 </span>            :       assert (Dh &lt; (uintmax_t) 1 &lt;&lt; (W_TYPE_SIZE - 2));
<span class="lineNum">    2040 </span>            : 
<span class="lineNum">    2041 </span>            :       S = isqrt2 (Dh, Dl);
<span class="lineNum">    2042 </span>            : 
<span class="lineNum">    2043 </span>            :       Q1 = 1;
<span class="lineNum">    2044 </span>            :       P = S;
<span class="lineNum">    2045 </span>            : 
<span class="lineNum">    2046 </span>            :       /* Square root remainder fits in one word, so ignore high part. */
<span class="lineNum">    2047 </span>            :       Q = Dl - P*P;
<span class="lineNum">    2048 </span>            :       /* FIXME: When can this differ from floor(sqrt(2 sqrt(D)))? */
<span class="lineNum">    2049 </span>            :       L = isqrt (2*S);
<span class="lineNum">    2050 </span>            :       B = 2*L;
<span class="lineNum">    2051 </span>            :       L1 = mu * 2 * L;
<span class="lineNum">    2052 </span>            : 
<span class="lineNum">    2053 </span>            :       /* The form is (+/- Q1, 2P, -/+ Q), of discriminant 4 (P^2 + Q Q1) =
<span class="lineNum">    2054 </span>            :          4 D. */
<span class="lineNum">    2055 </span>            : 
<span class="lineNum">    2056 </span>            :       for (i = 0; i &lt;= B; i++)
<span class="lineNum">    2057 </span>            :         {
<span class="lineNum">    2058 </span>            :           uintmax_t q, P1, t, rem;
<span class="lineNum">    2059 </span>            : 
<span class="lineNum">    2060 </span>            :           div_smallq (q, rem, S+P, Q);
<span class="lineNum">    2061 </span>            :           P1 = S - rem; /* P1 = q*Q - P */
<span class="lineNum">    2062 </span>            : 
<span class="lineNum">    2063 </span>            :           IF_LINT (assert (q &gt; 0 &amp;&amp; Q &gt; 0));
<span class="lineNum">    2064 </span>            : 
<span class="lineNum">    2065 </span>            : # if STAT_SQUFOF
<span class="lineNum">    2066 </span>            :           q_freq[0]++;
<span class="lineNum">    2067 </span>            :           q_freq[MIN (q, Q_FREQ_SIZE)]++;
<span class="lineNum">    2068 </span>            : # endif
<span class="lineNum">    2069 </span>            : 
<span class="lineNum">    2070 </span>            :           if (Q &lt;= L1)
<span class="lineNum">    2071 </span>            :             {
<span class="lineNum">    2072 </span>            :               uintmax_t g = Q;
<span class="lineNum">    2073 </span>            : 
<span class="lineNum">    2074 </span>            :               if ( (Q &amp; 1) == 0)
<span class="lineNum">    2075 </span>            :                 g /= 2;
<span class="lineNum">    2076 </span>            : 
<span class="lineNum">    2077 </span>            :               g /= gcd_odd (g, mu);
<span class="lineNum">    2078 </span>            : 
<span class="lineNum">    2079 </span>            :               if (g &lt;= L)
<span class="lineNum">    2080 </span>            :                 {
<span class="lineNum">    2081 </span>            :                   if (qpos &gt;= QUEUE_SIZE)
<span class="lineNum">    2082 </span>            :                     error (EXIT_FAILURE, 0, _(&quot;squfof queue overflow&quot;));
<span class="lineNum">    2083 </span>            :                   queue[qpos].Q = g;
<span class="lineNum">    2084 </span>            :                   queue[qpos].P = P % g;
<span class="lineNum">    2085 </span>            :                   qpos++;
<span class="lineNum">    2086 </span>            :                 }
<span class="lineNum">    2087 </span>            :             }
<span class="lineNum">    2088 </span>            : 
<span class="lineNum">    2089 </span>            :           /* I think the difference can be either sign, but mod
<span class="lineNum">    2090 </span>            :              2^W_TYPE_SIZE arithmetic should be fine. */
<span class="lineNum">    2091 </span>            :           t = Q1 + q * (P - P1);
<span class="lineNum">    2092 </span>            :           Q1 = Q;
<span class="lineNum">    2093 </span>            :           Q = t;
<span class="lineNum">    2094 </span>            :           P = P1;
<span class="lineNum">    2095 </span>            : 
<span class="lineNum">    2096 </span>            :           if ( (i &amp; 1) == 0)
<span class="lineNum">    2097 </span>            :             {
<span class="lineNum">    2098 </span>            :               uintmax_t r = is_square (Q);
<span class="lineNum">    2099 </span>            :               if (r)
<span class="lineNum">    2100 </span>            :                 {
<span class="lineNum">    2101 </span>            :                   for (unsigned int j = 0; j &lt; qpos; j++)
<span class="lineNum">    2102 </span>            :                     {
<span class="lineNum">    2103 </span>            :                       if (queue[j].Q == r)
<span class="lineNum">    2104 </span>            :                         {
<span class="lineNum">    2105 </span>            :                           if (r == 1)
<span class="lineNum">    2106 </span>            :                             /* Traversed entire cycle. */
<span class="lineNum">    2107 </span>            :                             goto next_multiplier;
<span class="lineNum">    2108 </span>            : 
<span class="lineNum">    2109 </span>            :                           /* Need the absolute value for divisibility test. */
<span class="lineNum">    2110 </span>            :                           if (P &gt;= queue[j].P)
<span class="lineNum">    2111 </span>            :                             t = P - queue[j].P;
<span class="lineNum">    2112 </span>            :                           else
<span class="lineNum">    2113 </span>            :                             t = queue[j].P - P;
<span class="lineNum">    2114 </span>            :                           if (t % r == 0)
<span class="lineNum">    2115 </span>            :                             {
<span class="lineNum">    2116 </span>            :                               /* Delete entries up to and including entry
<span class="lineNum">    2117 </span>            :                                  j, which matched. */
<span class="lineNum">    2118 </span>            :                               memmove (queue, queue + j + 1,
<span class="lineNum">    2119 </span>            :                                        (qpos - j - 1) * sizeof (queue[0]));
<span class="lineNum">    2120 </span>            :                               qpos -= (j + 1);
<span class="lineNum">    2121 </span>            :                             }
<span class="lineNum">    2122 </span>            :                           goto next_i;
<span class="lineNum">    2123 </span>            :                         }
<span class="lineNum">    2124 </span>            :                     }
<span class="lineNum">    2125 </span>            : 
<span class="lineNum">    2126 </span>            :                   /* We have found a square form, which should give a
<span class="lineNum">    2127 </span>            :                      factor. */
<span class="lineNum">    2128 </span>            :                   Q1 = r;
<span class="lineNum">    2129 </span>            :                   assert (S &gt;= P); /* What signs are possible? */
<span class="lineNum">    2130 </span>            :                   P += r * ((S - P) / r);
<span class="lineNum">    2131 </span>            : 
<span class="lineNum">    2132 </span>            :                   /* Note: Paper says (N - P*P) / Q1, that seems incorrect
<span class="lineNum">    2133 </span>            :                      for the case D = 2N. */
<span class="lineNum">    2134 </span>            :                   /* Compute Q = (D - P*P) / Q1, but we need double
<span class="lineNum">    2135 </span>            :                      precision. */
<span class="lineNum">    2136 </span>            :                   uintmax_t hi, lo;
<span class="lineNum">    2137 </span>            :                   umul_ppmm (hi, lo, P, P);
<span class="lineNum">    2138 </span>            :                   sub_ddmmss (hi, lo, Dh, Dl, hi, lo);
<span class="lineNum">    2139 </span>            :                   udiv_qrnnd (Q, rem, hi, lo, Q1);
<span class="lineNum">    2140 </span>            :                   assert (rem == 0);
<span class="lineNum">    2141 </span>            : 
<span class="lineNum">    2142 </span>            :                   for (;;)
<span class="lineNum">    2143 </span>            :                     {
<span class="lineNum">    2144 </span>            :                       /* Note: There appears to by a typo in the paper,
<span class="lineNum">    2145 </span>            :                          Step 4a in the algorithm description says q &lt;--
<span class="lineNum">    2146 </span>            :                          floor([S+P]/\hat Q), but looking at the equations
<span class="lineNum">    2147 </span>            :                          in Sec. 3.1, it should be q &lt;-- floor([S+P] / Q).
<span class="lineNum">    2148 </span>            :                          (In this code, \hat Q is Q1). */
<span class="lineNum">    2149 </span>            :                       div_smallq (q, rem, S+P, Q);
<span class="lineNum">    2150 </span>            :                       P1 = S - rem;     /* P1 = q*Q - P */
<span class="lineNum">    2151 </span>            : 
<span class="lineNum">    2152 </span>            : # if STAT_SQUFOF
<span class="lineNum">    2153 </span>            :                       q_freq[0]++;
<span class="lineNum">    2154 </span>            :                       q_freq[MIN (q, Q_FREQ_SIZE)]++;
<span class="lineNum">    2155 </span>            : # endif
<span class="lineNum">    2156 </span>            :                       if (P == P1)
<span class="lineNum">    2157 </span>            :                         break;
<span class="lineNum">    2158 </span>            :                       t = Q1 + q * (P - P1);
<span class="lineNum">    2159 </span>            :                       Q1 = Q;
<span class="lineNum">    2160 </span>            :                       Q = t;
<span class="lineNum">    2161 </span>            :                       P = P1;
<span class="lineNum">    2162 </span>            :                     }
<span class="lineNum">    2163 </span>            : 
<span class="lineNum">    2164 </span>            :                   if ( (Q &amp; 1) == 0)
<span class="lineNum">    2165 </span>            :                     Q /= 2;
<span class="lineNum">    2166 </span>            :                   Q /= gcd_odd (Q, mu);
<span class="lineNum">    2167 </span>            : 
<span class="lineNum">    2168 </span>            :                   assert (Q &gt; 1 &amp;&amp; (n1 || Q &lt; n0));
<span class="lineNum">    2169 </span>            : 
<span class="lineNum">    2170 </span>            :                   if (prime_p (Q))
<span class="lineNum">    2171 </span>            :                     factor_insert (factors, Q);
<span class="lineNum">    2172 </span>            :                   else if (!factor_using_squfof (0, Q, factors))
<span class="lineNum">    2173 </span>            :                     factor_using_pollard_rho (Q, 2, factors);
<span class="lineNum">    2174 </span>            : 
<span class="lineNum">    2175 </span>            :                   divexact_21 (n1, n0, n1, n0, Q);
<span class="lineNum">    2176 </span>            : 
<span class="lineNum">    2177 </span>            :                   if (prime2_p (n1, n0))
<span class="lineNum">    2178 </span>            :                     factor_insert_large (factors, n1, n0);
<span class="lineNum">    2179 </span>            :                   else
<span class="lineNum">    2180 </span>            :                     {
<span class="lineNum">    2181 </span>            :                       if (!factor_using_squfof (n1, n0, factors))
<span class="lineNum">    2182 </span>            :                         {
<span class="lineNum">    2183 </span>            :                           if (n1 == 0)
<span class="lineNum">    2184 </span>            :                             factor_using_pollard_rho (n0, 1, factors);
<span class="lineNum">    2185 </span>            :                           else
<span class="lineNum">    2186 </span>            :                             factor_using_pollard_rho2 (n1, n0, 1, factors);
<span class="lineNum">    2187 </span>            :                         }
<span class="lineNum">    2188 </span>            :                     }
<span class="lineNum">    2189 </span>            : 
<span class="lineNum">    2190 </span>            :                   return true;
<span class="lineNum">    2191 </span>            :                 }
<span class="lineNum">    2192 </span>            :             }
<span class="lineNum">    2193 </span>            :         next_i:;
<span class="lineNum">    2194 </span>            :         }
<span class="lineNum">    2195 </span>            :     next_multiplier:;
<span class="lineNum">    2196 </span>            :     }
<span class="lineNum">    2197 </span>            :   return false;
<span class="lineNum">    2198 </span>            : }
<span class="lineNum">    2199 </span>            : #endif
<span class="lineNum">    2200 </span>            : 
<span class="lineNum">    2201 </span>            : /* Compute the prime factors of the 128-bit number (T1,T0), and put the
<a name="2202"><span class="lineNum">    2202 </span>            :    results in FACTORS.  */</a>
<span class="lineNum">    2203 </span>            : static void
<span class="lineNum">    2204 </span><span class="lineNoCov">          0 : factor (uintmax_t t1, uintmax_t t0, struct factors *factors)</span>
<span class="lineNum">    2205 </span>            : {
<span class="lineNum">    2206 </span><span class="lineNoCov">          0 :   factors-&gt;nfactors = 0;</span>
<span class="lineNum">    2207 </span><span class="lineNoCov">          0 :   factors-&gt;plarge[1] = 0;</span>
<span class="lineNum">    2208 </span>            : 
<span class="lineNum">    2209 </span><span class="lineNoCov">          0 :   if (t1 == 0 &amp;&amp; t0 &lt; 2)</span>
<span class="lineNum">    2210 </span>            :     return;
<span class="lineNum">    2211 </span>            : 
<span class="lineNum">    2212 </span><span class="lineNoCov">          0 :   t0 = factor_using_division (&amp;t1, t1, t0, factors);</span>
<span class="lineNum">    2213 </span>            : 
<span class="lineNum">    2214 </span><span class="lineNoCov">          0 :   if (t1 == 0 &amp;&amp; t0 &lt; 2)</span>
<span class="lineNum">    2215 </span>            :     return;
<span class="lineNum">    2216 </span>            : 
<span class="lineNum">    2217 </span><span class="lineNoCov">          0 :   if (prime2_p (t1, t0))</span>
<span class="lineNum">    2218 </span><span class="lineNoCov">          0 :     factor_insert_large (factors, t1, t0);</span>
<span class="lineNum">    2219 </span>            :   else
<span class="lineNum">    2220 </span>            :     {
<span class="lineNum">    2221 </span>            : #if USE_SQUFOF
<span class="lineNum">    2222 </span>            :       if (factor_using_squfof (t1, t0, factors))
<span class="lineNum">    2223 </span>            :         return;
<span class="lineNum">    2224 </span>            : #endif
<span class="lineNum">    2225 </span>            : 
<span class="lineNum">    2226 </span><span class="lineNoCov">          0 :       if (t1 == 0)</span>
<span class="lineNum">    2227 </span><span class="lineNoCov">          0 :         factor_using_pollard_rho (t0, 1, factors);</span>
<span class="lineNum">    2228 </span>            :       else
<span class="lineNum">    2229 </span><span class="lineNoCov">          0 :         factor_using_pollard_rho2 (t1, t0, 1, factors);</span>
<span class="lineNum">    2230 </span>            :     }
<span class="lineNum">    2231 </span>            : }
<span class="lineNum">    2232 </span>            : 
<span class="lineNum">    2233 </span>            : #if HAVE_GMP
<span class="lineNum">    2234 </span>            : /* Use Pollard-rho to compute the prime factors of
<span class="lineNum">    2235 </span>            :    arbitrary-precision T, and put the results in FACTORS.  */
<span class="lineNum">    2236 </span>            : static void
<span class="lineNum">    2237 </span>            : mp_factor (mpz_t t, struct mp_factors *factors)
<span class="lineNum">    2238 </span>            : {
<span class="lineNum">    2239 </span>            :   mp_factor_init (factors);
<span class="lineNum">    2240 </span>            : 
<span class="lineNum">    2241 </span>            :   if (mpz_sgn (t) != 0)
<span class="lineNum">    2242 </span>            :     {
<span class="lineNum">    2243 </span>            :       mp_factor_using_division (t, factors);
<span class="lineNum">    2244 </span>            : 
<span class="lineNum">    2245 </span>            :       if (mpz_cmp_ui (t, 1) != 0)
<span class="lineNum">    2246 </span>            :         {
<span class="lineNum">    2247 </span>            :           devmsg (&quot;[is number prime?] &quot;);
<span class="lineNum">    2248 </span>            :           if (mp_prime_p (t))
<span class="lineNum">    2249 </span>            :             mp_factor_insert (factors, t);
<span class="lineNum">    2250 </span>            :           else
<span class="lineNum">    2251 </span>            :             mp_factor_using_pollard_rho (t, 1, factors);
<span class="lineNum">    2252 </span>            :         }
<span class="lineNum">    2253 </span>            :     }
<span class="lineNum">    2254 </span>            : }
<span class="lineNum">    2255 </span>            : #endif
<a name="2256"><span class="lineNum">    2256 </span>            : </a>
<span class="lineNum">    2257 </span>            : static strtol_error
<span class="lineNum">    2258 </span><span class="lineNoCov">          0 : strto2uintmax (uintmax_t *hip, uintmax_t *lop, const char *s)</span>
<span class="lineNum">    2259 </span>            : {
<span class="lineNum">    2260 </span>            :   unsigned int lo_carry;
<span class="lineNum">    2261 </span><span class="lineNoCov">          0 :   uintmax_t hi = 0, lo = 0;</span>
<span class="lineNum">    2262 </span>            : 
<span class="lineNum">    2263 </span><span class="lineNoCov">          0 :   strtol_error err = LONGINT_INVALID;</span>
<span class="lineNum">    2264 </span>            : 
<span class="lineNum">    2265 </span>            :   /* Skip initial spaces and '+'.  */
<span class="lineNum">    2266 </span>            :   for (;;)
<span class="lineNum">    2267 </span>            :     {
<span class="lineNum">    2268 </span><span class="lineNoCov">          0 :       char c = *s;</span>
<span class="lineNum">    2269 </span><span class="lineNoCov">          0 :       if (c == ' ')</span>
<span class="lineNum">    2270 </span><span class="lineNoCov">          0 :         s++;</span>
<span class="lineNum">    2271 </span><span class="lineNoCov">          0 :       else if (c == '+')</span>
<span class="lineNum">    2272 </span>            :         {
<span class="lineNum">    2273 </span><span class="lineNoCov">          0 :           s++;</span>
<span class="lineNum">    2274 </span><span class="lineNoCov">          0 :           break;</span>
<span class="lineNum">    2275 </span>            :         }
<span class="lineNum">    2276 </span>            :       else
<span class="lineNum">    2277 </span>            :         break;
<span class="lineNum">    2278 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">    2279 </span>            : 
<span class="lineNum">    2280 </span>            :   /* Initial scan for invalid digits.  */
<span class="lineNum">    2281 </span><span class="lineNoCov">          0 :   const char *p = s;</span>
<span class="lineNum">    2282 </span>            :   for (;;)
<span class="lineNum">    2283 </span>            :     {
<span class="lineNum">    2284 </span><span class="lineNoCov">          0 :       unsigned int c = *p++;</span>
<span class="lineNum">    2285 </span><span class="lineNoCov">          0 :       if (c == 0)</span>
<span class="lineNum">    2286 </span>            :         break;
<span class="lineNum">    2287 </span>            : 
<span class="lineNum">    2288 </span><span class="lineNoCov">          0 :       if (UNLIKELY (!ISDIGIT (c)))</span>
<span class="lineNum">    2289 </span>            :         {
<span class="lineNum">    2290 </span>            :           err = LONGINT_INVALID;
<span class="lineNum">    2291 </span>            :           break;
<span class="lineNum">    2292 </span>            :         }
<span class="lineNum">    2293 </span>            : 
<span class="lineNum">    2294 </span>            :       err = LONGINT_OK;           /* we've seen at least one valid digit */
<span class="lineNum">    2295 </span>            :     }
<span class="lineNum">    2296 </span>            : 
<span class="lineNum">    2297 </span><span class="lineNoCov">          0 :   for (;err == LONGINT_OK;)</span>
<span class="lineNum">    2298 </span>            :     {
<span class="lineNum">    2299 </span><span class="lineNoCov">          0 :       unsigned int c = *s++;</span>
<span class="lineNum">    2300 </span><span class="lineNoCov">          0 :       if (c == 0)</span>
<span class="lineNum">    2301 </span>            :         break;
<span class="lineNum">    2302 </span>            : 
<span class="lineNum">    2303 </span><span class="lineNoCov">          0 :       c -= '0';</span>
<span class="lineNum">    2304 </span>            : 
<span class="lineNum">    2305 </span><span class="lineNoCov">          0 :       if (UNLIKELY (hi &gt; ~(uintmax_t)0 / 10))</span>
<span class="lineNum">    2306 </span>            :         {
<span class="lineNum">    2307 </span>            :           err = LONGINT_OVERFLOW;
<span class="lineNum">    2308 </span>            :           break;
<span class="lineNum">    2309 </span>            :         }
<span class="lineNum">    2310 </span><span class="lineNoCov">          0 :       hi = 10 * hi;</span>
<span class="lineNum">    2311 </span>            : 
<span class="lineNum">    2312 </span><span class="lineNoCov">          0 :       lo_carry = (lo &gt;&gt; (W_TYPE_SIZE - 3)) + (lo &gt;&gt; (W_TYPE_SIZE - 1));</span>
<span class="lineNum">    2313 </span><span class="lineNoCov">          0 :       lo_carry += 10 * lo &lt; 2 * lo;</span>
<span class="lineNum">    2314 </span>            : 
<span class="lineNum">    2315 </span><span class="lineNoCov">          0 :       lo = 10 * lo;</span>
<span class="lineNum">    2316 </span><span class="lineNoCov">          0 :       lo += c;</span>
<span class="lineNum">    2317 </span>            : 
<span class="lineNum">    2318 </span><span class="lineNoCov">          0 :       lo_carry += lo &lt; c;</span>
<span class="lineNum">    2319 </span><span class="lineNoCov">          0 :       hi += lo_carry;</span>
<span class="lineNum">    2320 </span><span class="lineNoCov">          0 :       if (UNLIKELY (hi &lt; lo_carry))</span>
<span class="lineNum">    2321 </span>            :         {
<span class="lineNum">    2322 </span>            :           err = LONGINT_OVERFLOW;
<span class="lineNum">    2323 </span>            :           break;
<span class="lineNum">    2324 </span>            :         }
<span class="lineNum">    2325 </span>            :     }
<span class="lineNum">    2326 </span>            : 
<span class="lineNum">    2327 </span><span class="lineNoCov">          0 :   *hip = hi;</span>
<span class="lineNum">    2328 </span><span class="lineNoCov">          0 :   *lop = lo;</span>
<span class="lineNum">    2329 </span>            : 
<span class="lineNum">    2330 </span><span class="lineNoCov">          0 :   return err;</span>
<span class="lineNum">    2331 </span>            : }
<span class="lineNum">    2332 </span>            : 
<span class="lineNum">    2333 </span>            : /* Structure and routines for buffering and outputting full lines,
<span class="lineNum">    2334 </span>            :    to support parallel operation efficiently.  */
<span class="lineNum">    2335 </span>            : static struct lbuf_
<span class="lineNum">    2336 </span>            : {
<span class="lineNum">    2337 </span>            :   char *buf;
<span class="lineNum">    2338 </span>            :   char *end;
<span class="lineNum">    2339 </span>            : } lbuf;
<span class="lineNum">    2340 </span>            : 
<span class="lineNum">    2341 </span>            : /* 512 is chosen to give good performance,
<span class="lineNum">    2342 </span>            :    and also is the max guaranteed size that
<span class="lineNum">    2343 </span>            :    consumers can read atomically through pipes.
<span class="lineNum">    2344 </span>            :    Also it's big enough to cater for max line length
<span class="lineNum">    2345 </span>            :    even with 128 bit uintmax_t.  */
<span class="lineNum">    2346 </span>            : #define FACTOR_PIPE_BUF 512
<span class="lineNum">    2347 </span>            : 
<span class="lineNum">    2348 </span>            : static void
<span class="lineNum">    2349 </span>            : lbuf_alloc (void)
<span class="lineNum">    2350 </span>            : {
<span class="lineNum">    2351 </span><span class="lineNoCov">          0 :   if (lbuf.buf)</span>
<span class="lineNum">    2352 </span>            :     return;
<span class="lineNum">    2353 </span>            : 
<span class="lineNum">    2354 </span>            :   /* Double to ensure enough space for
<span class="lineNum">    2355 </span>            :      previous numbers + next number.  */
<span class="lineNum">    2356 </span><span class="lineNoCov">          0 :   lbuf.buf = xmalloc (FACTOR_PIPE_BUF * 2);</span>
<span class="lineNum">    2357 </span><span class="lineNoCov">          0 :   lbuf.end = lbuf.buf;</span>
<span class="lineNum">    2358 </span>            : }
<span class="lineNum">    2359 </span>            : 
<a name="2360"><span class="lineNum">    2360 </span>            : /* Write complete LBUF to standard output.  */</a>
<span class="lineNum">    2361 </span>            : static void
<span class="lineNum">    2362 </span><span class="lineNoCov">          0 : lbuf_flush (void)</span>
<span class="lineNum">    2363 </span>            : {
<span class="lineNum">    2364 </span><span class="lineNoCov">          0 :   size_t size = lbuf.end - lbuf.buf;</span>
<span class="lineNum">    2365 </span><span class="lineNoCov">          0 :   if (full_write (STDOUT_FILENO, lbuf.buf, size) != size)</span>
<span class="lineNum">    2366 </span><span class="lineNoCov">          0 :     error (EXIT_FAILURE, errno, &quot;%s&quot;, _(&quot;write error&quot;));</span>
<span class="lineNum">    2367 </span><span class="lineNoCov">          0 :   lbuf.end = lbuf.buf;</span>
<span class="lineNum">    2368 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    2369 </span>            : 
<span class="lineNum">    2370 </span>            : /* Add a character C to LBUF and if it's a newline
<span class="lineNum">    2371 </span>            :    and enough bytes are already buffered,
<a name="2372"><span class="lineNum">    2372 </span>            :    then write atomically to standard output.  */</a>
<span class="lineNum">    2373 </span>            : static void
<span class="lineNum">    2374 </span><span class="lineNoCov">          0 : lbuf_putc (char c)</span>
<span class="lineNum">    2375 </span>            : {
<span class="lineNum">    2376 </span><span class="lineNoCov">          0 :   *lbuf.end++ = c;</span>
<span class="lineNum">    2377 </span>            : 
<span class="lineNum">    2378 </span><span class="lineNoCov">          0 :   if (c == '\n')</span>
<span class="lineNum">    2379 </span>            :     {
<span class="lineNum">    2380 </span><span class="lineNoCov">          0 :       size_t buffered = lbuf.end - lbuf.buf;</span>
<span class="lineNum">    2381 </span>            : 
<span class="lineNum">    2382 </span><span class="lineNoCov">          0 :       if (buffered &gt;= FACTOR_PIPE_BUF)</span>
<span class="lineNum">    2383 </span>            :         {
<span class="lineNum">    2384 </span>            :           /* Write output in &lt;= PIPE_BUF chunks
<span class="lineNum">    2385 </span>            :              so consumers can read atomically.  */
<span class="lineNum">    2386 </span><span class="lineNoCov">          0 :           char const *tend = lbuf.end;</span>
<span class="lineNum">    2387 </span>            : 
<span class="lineNum">    2388 </span>            :           /* Since a umaxint_t's factors must fit in 512
<span class="lineNum">    2389 </span>            :              we're guaranteed to find a newline here.  */
<span class="lineNum">    2390 </span><span class="lineNoCov">          0 :           char *tlend = lbuf.buf + FACTOR_PIPE_BUF;</span>
<span class="lineNum">    2391 </span><span class="lineNoCov">          0 :           while (*--tlend != '\n');</span>
<span class="lineNum">    2392 </span><span class="lineNoCov">          0 :           tlend++;</span>
<span class="lineNum">    2393 </span>            : 
<span class="lineNum">    2394 </span><span class="lineNoCov">          0 :           lbuf.end = tlend;</span>
<span class="lineNum">    2395 </span><span class="lineNoCov">          0 :           lbuf_flush ();</span>
<span class="lineNum">    2396 </span>            : 
<span class="lineNum">    2397 </span>            :           /* Buffer the remainder.  */
<span class="lineNum">    2398 </span><span class="lineNoCov">          0 :           memcpy (lbuf.buf, tlend, tend - tlend);</span>
<span class="lineNum">    2399 </span><span class="lineNoCov">          0 :           lbuf.end = lbuf.buf + (tend - tlend);</span>
<span class="lineNum">    2400 </span>            :         }
<span class="lineNum">    2401 </span>            :     }
<span class="lineNum">    2402 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    2403 </span>            : 
<a name="2404"><span class="lineNum">    2404 </span>            : /* Buffer an int to the internal LBUF.  */</a>
<span class="lineNum">    2405 </span>            : static void
<span class="lineNum">    2406 </span><span class="lineNoCov">          0 : lbuf_putint (uintmax_t i, size_t min_width)</span>
<span class="lineNum">    2407 </span>            : {
<span class="lineNum">    2408 </span>            :   char buf[INT_BUFSIZE_BOUND (uintmax_t)];
<span class="lineNum">    2409 </span><span class="lineNoCov">          0 :   char const *umaxstr = umaxtostr (i, buf);</span>
<span class="lineNum">    2410 </span><span class="lineNoCov">          0 :   size_t width = sizeof (buf) - (umaxstr - buf) - 1;</span>
<span class="lineNum">    2411 </span><span class="lineNoCov">          0 :   size_t z = width;</span>
<span class="lineNum">    2412 </span>            : 
<span class="lineNum">    2413 </span><span class="lineNoCov">          0 :   for (; z &lt; min_width; z++)</span>
<span class="lineNum">    2414 </span><span class="lineNoCov">          0 :     *lbuf.end++ = '0';</span>
<span class="lineNum">    2415 </span>            : 
<span class="lineNum">    2416 </span><span class="lineNoCov">          0 :   memcpy (lbuf.end, umaxstr, width);</span>
<span class="lineNum">    2417 </span><span class="lineNoCov">          0 :   lbuf.end += width;</span>
<span class="lineNum">    2418 </span><span class="lineNoCov">          0 : }</span>
<a name="2419"><span class="lineNum">    2419 </span>            : </a>
<span class="lineNum">    2420 </span>            : static void
<span class="lineNum">    2421 </span><span class="lineNoCov">          0 : print_uintmaxes (uintmax_t t1, uintmax_t t0)</span>
<span class="lineNum">    2422 </span>            : {
<span class="lineNum">    2423 </span>            :   uintmax_t q, r;
<span class="lineNum">    2424 </span>            : 
<span class="lineNum">    2425 </span><span class="lineNoCov">          0 :   if (t1 == 0)</span>
<span class="lineNum">    2426 </span><span class="lineNoCov">          0 :     lbuf_putint (t0, 0);</span>
<span class="lineNum">    2427 </span>            :   else
<span class="lineNum">    2428 </span>            :     {
<span class="lineNum">    2429 </span>            :       /* Use very plain code here since it seems hard to write fast code
<span class="lineNum">    2430 </span>            :          without assuming a specific word size.  */
<span class="lineNum">    2431 </span><span class="lineNoCov">          0 :       q = t1 / 1000000000;</span>
<span class="lineNum">    2432 </span><span class="lineNoCov">          0 :       r = t1 % 1000000000;</span>
<span class="lineNum">    2433 </span><span class="lineNoCov">          0 :       udiv_qrnnd (t0, r, r, t0, 1000000000);</span>
<span class="lineNum">    2434 </span><span class="lineNoCov">          0 :       print_uintmaxes (q, t0);</span>
<span class="lineNum">    2435 </span><span class="lineNoCov">          0 :       lbuf_putint (r, 9);</span>
<span class="lineNum">    2436 </span>            :     }
<span class="lineNum">    2437 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    2438 </span>            : 
<a name="2439"><span class="lineNum">    2439 </span>            : /* Single-precision factoring */</a>
<span class="lineNum">    2440 </span>            : static void
<span class="lineNum">    2441 </span><span class="lineNoCov">          0 : print_factors_single (uintmax_t t1, uintmax_t t0)</span>
<span class="lineNum">    2442 </span>            : {
<span class="lineNum">    2443 </span>            :   struct factors factors;
<span class="lineNum">    2444 </span>            : 
<span class="lineNum">    2445 </span><span class="lineNoCov">          0 :   print_uintmaxes (t1, t0);</span>
<span class="lineNum">    2446 </span><span class="lineNoCov">          0 :   lbuf_putc (':');</span>
<span class="lineNum">    2447 </span>            : 
<span class="lineNum">    2448 </span><span class="lineNoCov">          0 :   factor (t1, t0, &amp;factors);</span>
<span class="lineNum">    2449 </span>            : 
<span class="lineNum">    2450 </span><span class="lineNoCov">          0 :   for (unsigned int j = 0; j &lt; factors.nfactors; j++)</span>
<span class="lineNum">    2451 </span><span class="lineNoCov">          0 :     for (unsigned int k = 0; k &lt; factors.e[j]; k++)</span>
<span class="lineNum">    2452 </span>            :       {
<span class="lineNum">    2453 </span><span class="lineNoCov">          0 :         lbuf_putc (' ');</span>
<span class="lineNum">    2454 </span><span class="lineNoCov">          0 :         print_uintmaxes (0, factors.p[j]);</span>
<span class="lineNum">    2455 </span>            :       }
<span class="lineNum">    2456 </span>            : 
<span class="lineNum">    2457 </span><span class="lineNoCov">          0 :   if (factors.plarge[1])</span>
<span class="lineNum">    2458 </span>            :     {
<span class="lineNum">    2459 </span><span class="lineNoCov">          0 :       lbuf_putc (' ');</span>
<span class="lineNum">    2460 </span><span class="lineNoCov">          0 :       print_uintmaxes (factors.plarge[1], factors.plarge[0]);</span>
<span class="lineNum">    2461 </span>            :     }
<span class="lineNum">    2462 </span>            : 
<span class="lineNum">    2463 </span><span class="lineNoCov">          0 :   lbuf_putc ('\n');</span>
<span class="lineNum">    2464 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    2465 </span>            : 
<span class="lineNum">    2466 </span>            : /* Emit the factors of the indicated number.  If we have the option of using
<span class="lineNum">    2467 </span>            :    either algorithm, we select on the basis of the length of the number.
<span class="lineNum">    2468 </span>            :    For longer numbers, we prefer the MP algorithm even if the native algorithm
<span class="lineNum">    2469 </span>            :    has enough digits, because the algorithm is better.  The turnover point
<a name="2470"><span class="lineNum">    2470 </span>            :    depends on the value.  */</a>
<span class="lineNum">    2471 </span>            : static bool
<span class="lineNum">    2472 </span><span class="lineNoCov">          0 : print_factors (const char *input)</span>
<span class="lineNum">    2473 </span>            : {
<span class="lineNum">    2474 </span>            :   uintmax_t t1, t0;
<span class="lineNum">    2475 </span>            : 
<span class="lineNum">    2476 </span>            :   /* Try converting the number to one or two words.  If it fails, use GMP or
<span class="lineNum">    2477 </span>            :      print an error message.  The 2nd condition checks that the most
<span class="lineNum">    2478 </span>            :      significant bit of the two-word number is clear, in a typesize neutral
<span class="lineNum">    2479 </span>            :      way.  */
<span class="lineNum">    2480 </span><span class="lineNoCov">          0 :   strtol_error err = strto2uintmax (&amp;t1, &amp;t0, input);</span>
<span class="lineNum">    2481 </span>            : 
<span class="lineNum">    2482 </span><span class="lineNoCov">          0 :   switch (err)</span>
<span class="lineNum">    2483 </span>            :     {
<span class="lineNum">    2484 </span>            :     case LONGINT_OK:
<span class="lineNum">    2485 </span><span class="lineNoCov">          0 :       if (((t1 &lt;&lt; 1) &gt;&gt; 1) == t1)</span>
<span class="lineNum">    2486 </span>            :         {
<span class="lineNum">    2487 </span><span class="lineNoCov">          0 :           devmsg (&quot;[using single-precision arithmetic] &quot;);</span>
<span class="lineNum">    2488 </span><span class="lineNoCov">          0 :           print_factors_single (t1, t0);</span>
<span class="lineNum">    2489 </span><span class="lineNoCov">          0 :           return true;</span>
<span class="lineNum">    2490 </span>            :         }
<span class="lineNum">    2491 </span>            :       break;
<span class="lineNum">    2492 </span>            : 
<span class="lineNum">    2493 </span>            :     case LONGINT_OVERFLOW:
<span class="lineNum">    2494 </span>            :       /* Try GMP.  */
<span class="lineNum">    2495 </span>            :       break;
<span class="lineNum">    2496 </span>            : 
<span class="lineNum">    2497 </span>            :     default:
<span class="lineNum">    2498 </span><span class="lineNoCov">          0 :       error (0, 0, _(&quot;%s is not a valid positive integer&quot;), quote (input));</span>
<span class="lineNum">    2499 </span><span class="lineNoCov">          0 :       return false;</span>
<span class="lineNum">    2500 </span>            :     }
<span class="lineNum">    2501 </span>            : 
<span class="lineNum">    2502 </span>            : #if HAVE_GMP
<span class="lineNum">    2503 </span>            :   devmsg (&quot;[using arbitrary-precision arithmetic] &quot;);
<span class="lineNum">    2504 </span>            :   mpz_t t;
<span class="lineNum">    2505 </span>            :   struct mp_factors factors;
<span class="lineNum">    2506 </span>            : 
<span class="lineNum">    2507 </span>            :   mpz_init_set_str (t, input, 10);
<span class="lineNum">    2508 </span>            : 
<span class="lineNum">    2509 </span>            :   gmp_printf (&quot;%Zd:&quot;, t);
<span class="lineNum">    2510 </span>            :   mp_factor (t, &amp;factors);
<span class="lineNum">    2511 </span>            : 
<span class="lineNum">    2512 </span>            :   for (unsigned int j = 0; j &lt; factors.nfactors; j++)
<span class="lineNum">    2513 </span>            :     for (unsigned int k = 0; k &lt; factors.e[j]; k++)
<span class="lineNum">    2514 </span>            :       gmp_printf (&quot; %Zd&quot;, factors.p[j]);
<span class="lineNum">    2515 </span>            : 
<span class="lineNum">    2516 </span>            :   mp_factor_clear (&amp;factors);
<span class="lineNum">    2517 </span>            :   mpz_clear (t);
<span class="lineNum">    2518 </span>            :   putchar ('\n');
<span class="lineNum">    2519 </span>            :   fflush (stdout);
<span class="lineNum">    2520 </span>            :   return true;
<span class="lineNum">    2521 </span>            : #else
<span class="lineNum">    2522 </span><span class="lineNoCov">          0 :   error (0, 0, _(&quot;%s is too large&quot;), quote (input));</span>
<span class="lineNum">    2523 </span><span class="lineNoCov">          0 :   return false;</span>
<span class="lineNum">    2524 </span>            : #endif
<span class="lineNum">    2525 </span>            : }
<a name="2526"><span class="lineNum">    2526 </span>            : </a>
<span class="lineNum">    2527 </span>            : void
<span class="lineNum">    2528 </span><span class="lineNoCov">          0 : usage (int status)</span>
<span class="lineNum">    2529 </span>            : {
<span class="lineNum">    2530 </span><span class="lineNoCov">          0 :   if (status != EXIT_SUCCESS)</span>
<span class="lineNum">    2531 </span><span class="lineNoCov">          0 :     emit_try_help ();</span>
<span class="lineNum">    2532 </span>            :   else
<span class="lineNum">    2533 </span>            :     {
<span class="lineNum">    2534 </span><span class="lineNoCov">          0 :       printf (_(&quot;\</span>
<span class="lineNum">    2535 </span>            : Usage: %s [NUMBER]...\n\
<span class="lineNum">    2536 </span>            :   or:  %s OPTION\n\
<span class="lineNum">    2537 </span>            : &quot;),
<span class="lineNum">    2538 </span>            :               program_name, program_name);
<span class="lineNum">    2539 </span><span class="lineNoCov">          0 :       fputs (_(&quot;\</span>
<span class="lineNum">    2540 </span>            : Print the prime factors of each specified integer NUMBER.  If none\n\
<span class="lineNum">    2541 </span>            : are specified on the command line, read them from standard input.\n\
<span class="lineNum">    2542 </span>            : \n\
<span class="lineNum">    2543 </span>            : &quot;), stdout);
<span class="lineNum">    2544 </span><span class="lineNoCov">          0 :       fputs (HELP_OPTION_DESCRIPTION, stdout);</span>
<span class="lineNum">    2545 </span><span class="lineNoCov">          0 :       fputs (VERSION_OPTION_DESCRIPTION, stdout);</span>
<span class="lineNum">    2546 </span><span class="lineNoCov">          0 :       emit_ancillary_info (PROGRAM_NAME);</span>
<span class="lineNum">    2547 </span>            :     }
<span class="lineNum">    2548 </span><span class="lineNoCov">          0 :   exit (status);</span>
<span class="lineNum">    2549 </span>            : }
<a name="2550"><span class="lineNum">    2550 </span>            : </a>
<span class="lineNum">    2551 </span>            : static bool
<span class="lineNum">    2552 </span><span class="lineNoCov">          0 : do_stdin (void)</span>
<span class="lineNum">    2553 </span>            : {
<span class="lineNum">    2554 </span><span class="lineNoCov">          0 :   bool ok = true;</span>
<span class="lineNum">    2555 </span>            :   token_buffer tokenbuffer;
<span class="lineNum">    2556 </span>            : 
<span class="lineNum">    2557 </span><span class="lineNoCov">          0 :   init_tokenbuffer (&amp;tokenbuffer);</span>
<span class="lineNum">    2558 </span>            : 
<span class="lineNum">    2559 </span>            :   while (true)
<span class="lineNum">    2560 </span>            :     {
<span class="lineNum">    2561 </span><span class="lineNoCov">          0 :       size_t token_length = readtoken (stdin, DELIM, sizeof (DELIM) - 1,</span>
<span class="lineNum">    2562 </span>            :                                        &amp;tokenbuffer);
<span class="lineNum">    2563 </span><span class="lineNoCov">          0 :       if (token_length == (size_t) -1)</span>
<span class="lineNum">    2564 </span>            :         break;
<span class="lineNum">    2565 </span><span class="lineNoCov">          0 :       ok &amp;= print_factors (tokenbuffer.buffer);</span>
<span class="lineNum">    2566 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">    2567 </span><span class="lineNoCov">          0 :   free (tokenbuffer.buffer);</span>
<span class="lineNum">    2568 </span>            : 
<span class="lineNum">    2569 </span><span class="lineNoCov">          0 :   return ok;</span>
<span class="lineNum">    2570 </span>            : }
<a name="2571"><span class="lineNum">    2571 </span>            : </a>
<span class="lineNum">    2572 </span>            : int
<span class="lineNum">    2573 </span><span class="lineNoCov">          0 : main (int argc, char **argv)</span>
<span class="lineNum">    2574 </span>            : {
<span class="lineNum">    2575 </span>            :   initialize_main (&amp;argc, &amp;argv);
<span class="lineNum">    2576 </span><span class="lineNoCov">          0 :   set_program_name (argv[0]);</span>
<span class="lineNum">    2577 </span><span class="lineNoCov">          0 :   setlocale (LC_ALL, &quot;&quot;);</span>
<span class="lineNum">    2578 </span><span class="lineNoCov">          0 :   bindtextdomain (PACKAGE, LOCALEDIR);</span>
<span class="lineNum">    2579 </span><span class="lineNoCov">          0 :   textdomain (PACKAGE);</span>
<span class="lineNum">    2580 </span>            : 
<span class="lineNum">    2581 </span>            :   lbuf_alloc ();
<span class="lineNum">    2582 </span><span class="lineNoCov">          0 :   atexit (close_stdout);</span>
<span class="lineNum">    2583 </span><span class="lineNoCov">          0 :   atexit (lbuf_flush);</span>
<span class="lineNum">    2584 </span>            : 
<span class="lineNum">    2585 </span>            :   int c;
<span class="lineNum">    2586 </span><span class="lineNoCov">          0 :   while ((c = getopt_long (argc, argv, &quot;&quot;, long_options, NULL)) != -1)</span>
<span class="lineNum">    2587 </span>            :     {
<span class="lineNum">    2588 </span><span class="lineNoCov">          0 :       switch (c)</span>
<span class="lineNum">    2589 </span>            :         {
<span class="lineNum">    2590 </span>            :         case DEV_DEBUG_OPTION:
<span class="lineNum">    2591 </span><span class="lineNoCov">          0 :           dev_debug = true;</span>
<span class="lineNum">    2592 </span><span class="lineNoCov">          0 :           break;</span>
<span class="lineNum">    2593 </span>            : 
<span class="lineNum">    2594 </span><span class="lineNoCov">          0 :         case_GETOPT_HELP_CHAR;</span>
<span class="lineNum">    2595 </span>            : 
<span class="lineNum">    2596 </span><span class="lineNoCov">          0 :         case_GETOPT_VERSION_CHAR (PROGRAM_NAME, AUTHORS);</span>
<span class="lineNum">    2597 </span>            : 
<span class="lineNum">    2598 </span>            :         default:
<span class="lineNum">    2599 </span><span class="lineNoCov">          0 :           usage (EXIT_FAILURE);</span>
<span class="lineNum">    2600 </span>            :         }
<span class="lineNum">    2601 </span>            :     }
<span class="lineNum">    2602 </span>            : 
<span class="lineNum">    2603 </span>            : #if STAT_SQUFOF
<span class="lineNum">    2604 </span>            :   memset (q_freq, 0, sizeof (q_freq));
<span class="lineNum">    2605 </span>            : #endif
<span class="lineNum">    2606 </span>            : 
<span class="lineNum">    2607 </span>            :   bool ok;
<span class="lineNum">    2608 </span><span class="lineNoCov">          0 :   if (argc &lt;= optind)</span>
<span class="lineNum">    2609 </span><span class="lineNoCov">          0 :     ok = do_stdin ();</span>
<span class="lineNum">    2610 </span>            :   else
<span class="lineNum">    2611 </span>            :     {
<span class="lineNum">    2612 </span>            :       ok = true;
<span class="lineNum">    2613 </span><span class="lineNoCov">          0 :       for (int i = optind; i &lt; argc; i++)</span>
<span class="lineNum">    2614 </span><span class="lineNoCov">          0 :         if (! print_factors (argv[i]))</span>
<span class="lineNum">    2615 </span><span class="lineNoCov">          0 :           ok = false;</span>
<span class="lineNum">    2616 </span>            :     }
<span class="lineNum">    2617 </span>            : 
<span class="lineNum">    2618 </span>            : #if STAT_SQUFOF
<span class="lineNum">    2619 </span>            :   if (q_freq[0] &gt; 0)
<span class="lineNum">    2620 </span>            :     {
<span class="lineNum">    2621 </span>            :       double acc_f;
<span class="lineNum">    2622 </span>            :       printf (&quot;q  freq.  cum. freq.(total: %d)\n&quot;, q_freq[0]);
<span class="lineNum">    2623 </span>            :       for (unsigned int i = 1, acc_f = 0.0; i &lt;= Q_FREQ_SIZE; i++)
<span class="lineNum">    2624 </span>            :         {
<span class="lineNum">    2625 </span>            :           double f = (double) q_freq[i] / q_freq[0];
<span class="lineNum">    2626 </span>            :           acc_f += f;
<span class="lineNum">    2627 </span>            :           printf (&quot;%s%d %.2f%% %.2f%%\n&quot;, i == Q_FREQ_SIZE ? &quot;&gt;=&quot; : &quot;&quot;, i,
<span class="lineNum">    2628 </span>            :                   100.0 * f, 100.0 * acc_f);
<span class="lineNum">    2629 </span>            :         }
<span class="lineNum">    2630 </span>            :     }
<span class="lineNum">    2631 </span>            : #endif
<span class="lineNum">    2632 </span>            : 
<span class="lineNum">    2633 </span><span class="lineNoCov">          0 :   return ok ? EXIT_SUCCESS : EXIT_FAILURE;</span>
<span class="lineNum">    2634 </span>            : }
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.12</a></td></tr>
  </table>
  <br>

</body>
</html>
