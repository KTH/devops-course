<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - trace.lcov_info_final - src/fmt.c</title>
  <link rel="stylesheet" type="text/css" href="../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../index.html">top level</a> - <a href="index.html">src</a> - fmt.c<span style="font-size: 80%;"> (source / <a href="fmt.c.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">trace.lcov_info_final</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">0</td>
            <td class="headerCovTableEntry">319</td>
            <td class="headerCovTableEntryLo">0.0 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2019-04-22 20:19:38</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">0</td>
            <td class="headerCovTableEntry">18</td>
            <td class="headerCovTableEntryLo">0.0 %</td>
          </tr>
          <tr><td><img src="../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : /* GNU fmt -- simple text formatter.</a>
<span class="lineNum">       2 </span>            :    Copyright (C) 1994-2016 Free Software Foundation, Inc.
<span class="lineNum">       3 </span>            : 
<span class="lineNum">       4 </span>            :    This program is free software: you can redistribute it and/or modify
<span class="lineNum">       5 </span>            :    it under the terms of the GNU General Public License as published by
<span class="lineNum">       6 </span>            :    the Free Software Foundation, either version 3 of the License, or
<span class="lineNum">       7 </span>            :    (at your option) any later version.
<span class="lineNum">       8 </span>            : 
<span class="lineNum">       9 </span>            :    This program is distributed in the hope that it will be useful,
<span class="lineNum">      10 </span>            :    but WITHOUT ANY WARRANTY; without even the implied warranty of
<span class="lineNum">      11 </span>            :    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
<span class="lineNum">      12 </span>            :    GNU General Public License for more details.
<span class="lineNum">      13 </span>            : 
<span class="lineNum">      14 </span>            :    You should have received a copy of the GNU General Public License
<span class="lineNum">      15 </span>            :    along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.  */
<span class="lineNum">      16 </span>            : 
<span class="lineNum">      17 </span>            : /* Written by Ross Paterson &lt;rap@doc.ic.ac.uk&gt;.  */
<span class="lineNum">      18 </span>            : 
<span class="lineNum">      19 </span>            : #include &lt;config.h&gt;
<span class="lineNum">      20 </span>            : #include &lt;stdio.h&gt;
<span class="lineNum">      21 </span>            : #include &lt;sys/types.h&gt;
<span class="lineNum">      22 </span>            : #include &lt;getopt.h&gt;
<span class="lineNum">      23 </span>            : #include &lt;assert.h&gt;
<span class="lineNum">      24 </span>            : 
<span class="lineNum">      25 </span>            : /* Redefine.  Otherwise, systems (Unicos for one) with headers that define
<span class="lineNum">      26 </span>            :    it to be a type get syntax errors for the variable declaration below.  */
<span class="lineNum">      27 </span>            : #define word unused_word_type
<span class="lineNum">      28 </span>            : 
<span class="lineNum">      29 </span>            : #include &quot;system.h&quot;
<span class="lineNum">      30 </span>            : #include &quot;error.h&quot;
<span class="lineNum">      31 </span>            : #include &quot;fadvise.h&quot;
<span class="lineNum">      32 </span>            : #include &quot;xdectoint.h&quot;
<span class="lineNum">      33 </span>            : 
<span class="lineNum">      34 </span>            : /* The official name of this program (e.g., no 'g' prefix).  */
<span class="lineNum">      35 </span>            : #define PROGRAM_NAME &quot;fmt&quot;
<span class="lineNum">      36 </span>            : 
<span class="lineNum">      37 </span>            : #define AUTHORS proper_name (&quot;Ross Paterson&quot;)
<span class="lineNum">      38 </span>            : 
<span class="lineNum">      39 </span>            : /* The following parameters represent the program's idea of what is
<span class="lineNum">      40 </span>            :    &quot;best&quot;.  Adjust to taste, subject to the caveats given.  */
<span class="lineNum">      41 </span>            : 
<span class="lineNum">      42 </span>            : /* Default longest permitted line length (max_width).  */
<span class="lineNum">      43 </span>            : #define WIDTH   75
<span class="lineNum">      44 </span>            : 
<span class="lineNum">      45 </span>            : /* Prefer lines to be LEEWAY % shorter than the maximum width, giving
<span class="lineNum">      46 </span>            :    room for optimization.  */
<span class="lineNum">      47 </span>            : #define LEEWAY  7
<span class="lineNum">      48 </span>            : 
<span class="lineNum">      49 </span>            : /* The default secondary indent of tagged paragraph used for unindented
<span class="lineNum">      50 </span>            :    one-line paragraphs not preceded by any multi-line paragraphs.  */
<span class="lineNum">      51 </span>            : #define DEF_INDENT 3
<span class="lineNum">      52 </span>            : 
<span class="lineNum">      53 </span>            : /* Costs and bonuses are expressed as the equivalent departure from the
<span class="lineNum">      54 </span>            :    optimal line length, multiplied by 10.  e.g. assigning something a
<span class="lineNum">      55 </span>            :    cost of 50 means that it is as bad as a line 5 characters too short
<span class="lineNum">      56 </span>            :    or too long.  The definition of SHORT_COST(n) should not be changed.
<span class="lineNum">      57 </span>            :    However, EQUIV(n) may need tuning.  */
<span class="lineNum">      58 </span>            : 
<span class="lineNum">      59 </span>            : /* FIXME: &quot;fmt&quot; misbehaves given large inputs or options.  One
<span class="lineNum">      60 </span>            :    possible workaround for part of the problem is to change COST to be
<span class="lineNum">      61 </span>            :    a floating-point type.  There are other problems besides COST,
<span class="lineNum">      62 </span>            :    though; see MAXWORDS below.  */
<span class="lineNum">      63 </span>            : 
<span class="lineNum">      64 </span>            : typedef long int COST;
<span class="lineNum">      65 </span>            : 
<span class="lineNum">      66 </span>            : #define MAXCOST TYPE_MAXIMUM (COST)
<span class="lineNum">      67 </span>            : 
<span class="lineNum">      68 </span>            : #define SQR(n)          ((n) * (n))
<span class="lineNum">      69 </span>            : #define EQUIV(n)        SQR ((COST) (n))
<span class="lineNum">      70 </span>            : 
<span class="lineNum">      71 </span>            : /* Cost of a filled line n chars longer or shorter than goal_width.  */
<span class="lineNum">      72 </span>            : #define SHORT_COST(n)   EQUIV ((n) * 10)
<span class="lineNum">      73 </span>            : 
<span class="lineNum">      74 </span>            : /* Cost of the difference between adjacent filled lines.  */
<span class="lineNum">      75 </span>            : #define RAGGED_COST(n)  (SHORT_COST (n) / 2)
<span class="lineNum">      76 </span>            : 
<span class="lineNum">      77 </span>            : /* Basic cost per line.  */
<span class="lineNum">      78 </span>            : #define LINE_COST       EQUIV (70)
<span class="lineNum">      79 </span>            : 
<span class="lineNum">      80 </span>            : /* Cost of breaking a line after the first word of a sentence, where
<span class="lineNum">      81 </span>            :    the length of the word is N.  */
<span class="lineNum">      82 </span>            : #define WIDOW_COST(n)   (EQUIV (200) / ((n) + 2))
<span class="lineNum">      83 </span>            : 
<span class="lineNum">      84 </span>            : /* Cost of breaking a line before the last word of a sentence, where
<span class="lineNum">      85 </span>            :    the length of the word is N.  */
<span class="lineNum">      86 </span>            : #define ORPHAN_COST(n)  (EQUIV (150) / ((n) + 2))
<span class="lineNum">      87 </span>            : 
<span class="lineNum">      88 </span>            : /* Bonus for breaking a line at the end of a sentence.  */
<span class="lineNum">      89 </span>            : #define SENTENCE_BONUS  EQUIV (50)
<span class="lineNum">      90 </span>            : 
<span class="lineNum">      91 </span>            : /* Cost of breaking a line after a period not marking end of a sentence.
<span class="lineNum">      92 </span>            :    With the definition of sentence we are using (borrowed from emacs, see
<span class="lineNum">      93 </span>            :    get_line()) such a break would then look like a sentence break.  Hence
<span class="lineNum">      94 </span>            :    we assign a very high cost -- it should be avoided unless things are
<span class="lineNum">      95 </span>            :    really bad.  */
<span class="lineNum">      96 </span>            : #define NOBREAK_COST    EQUIV (600)
<span class="lineNum">      97 </span>            : 
<span class="lineNum">      98 </span>            : /* Bonus for breaking a line before open parenthesis.  */
<span class="lineNum">      99 </span>            : #define PAREN_BONUS     EQUIV (40)
<span class="lineNum">     100 </span>            : 
<span class="lineNum">     101 </span>            : /* Bonus for breaking a line after other punctuation.  */
<span class="lineNum">     102 </span>            : #define PUNCT_BONUS     EQUIV(40)
<span class="lineNum">     103 </span>            : 
<span class="lineNum">     104 </span>            : /* Credit for breaking a long paragraph one line later.  */
<span class="lineNum">     105 </span>            : #define LINE_CREDIT     EQUIV(3)
<span class="lineNum">     106 </span>            : 
<span class="lineNum">     107 </span>            : /* Size of paragraph buffer, in words and characters.  Longer paragraphs
<span class="lineNum">     108 </span>            :    are handled neatly (cf. flush_paragraph()), so long as these values
<span class="lineNum">     109 </span>            :    are considerably greater than required by the width.  These values
<span class="lineNum">     110 </span>            :    cannot be extended indefinitely: doing so would run into size limits
<span class="lineNum">     111 </span>            :    and/or cause more overflows in cost calculations.  FIXME: Remove these
<span class="lineNum">     112 </span>            :    arbitrary limits.  */
<span class="lineNum">     113 </span>            : 
<span class="lineNum">     114 </span>            : #define MAXWORDS        1000
<span class="lineNum">     115 </span>            : #define MAXCHARS        5000
<span class="lineNum">     116 </span>            : 
<span class="lineNum">     117 </span>            : /* Extra ctype(3)-style macros.  */
<span class="lineNum">     118 </span>            : 
<span class="lineNum">     119 </span>            : #define isopen(c)       (strchr (&quot;(['`\&quot;&quot;, c) != NULL)
<span class="lineNum">     120 </span>            : #define isclose(c)      (strchr (&quot;)]'\&quot;&quot;, c) != NULL)
<span class="lineNum">     121 </span>            : #define isperiod(c)     (strchr (&quot;.?!&quot;, c) != NULL)
<span class="lineNum">     122 </span>            : 
<span class="lineNum">     123 </span>            : /* Size of a tab stop, for expansion on input and re-introduction on
<span class="lineNum">     124 </span>            :    output.  */
<span class="lineNum">     125 </span>            : #define TABWIDTH        8
<span class="lineNum">     126 </span>            : 
<span class="lineNum">     127 </span>            : /* Word descriptor structure.  */
<span class="lineNum">     128 </span>            : 
<span class="lineNum">     129 </span>            : typedef struct Word WORD;
<span class="lineNum">     130 </span>            : 
<span class="lineNum">     131 </span>            : struct Word
<span class="lineNum">     132 </span>            :   {
<span class="lineNum">     133 </span>            : 
<span class="lineNum">     134 </span>            :     /* Static attributes determined during input.  */
<span class="lineNum">     135 </span>            : 
<span class="lineNum">     136 </span>            :     const char *text;           /* the text of the word */
<span class="lineNum">     137 </span>            :     int length;                 /* length of this word */
<span class="lineNum">     138 </span>            :     int space;                  /* the size of the following space */
<span class="lineNum">     139 </span>            :     unsigned int paren:1;       /* starts with open paren */
<span class="lineNum">     140 </span>            :     unsigned int period:1;      /* ends in [.?!])* */
<span class="lineNum">     141 </span>            :     unsigned int punct:1;       /* ends in punctuation */
<span class="lineNum">     142 </span>            :     unsigned int final:1;       /* end of sentence */
<span class="lineNum">     143 </span>            : 
<span class="lineNum">     144 </span>            :     /* The remaining fields are computed during the optimization.  */
<span class="lineNum">     145 </span>            : 
<span class="lineNum">     146 </span>            :     int line_length;            /* length of the best line starting here */
<span class="lineNum">     147 </span>            :     COST best_cost;             /* cost of best paragraph starting here */
<span class="lineNum">     148 </span>            :     WORD *next_break;           /* break which achieves best_cost */
<span class="lineNum">     149 </span>            :   };
<span class="lineNum">     150 </span>            : 
<span class="lineNum">     151 </span>            : /* Forward declarations.  */
<span class="lineNum">     152 </span>            : 
<span class="lineNum">     153 </span>            : static void set_prefix (char *p);
<span class="lineNum">     154 </span>            : static void fmt (FILE *f);
<span class="lineNum">     155 </span>            : static bool get_paragraph (FILE *f);
<span class="lineNum">     156 </span>            : static int get_line (FILE *f, int c);
<span class="lineNum">     157 </span>            : static int get_prefix (FILE *f);
<span class="lineNum">     158 </span>            : static int get_space (FILE *f, int c);
<span class="lineNum">     159 </span>            : static int copy_rest (FILE *f, int c);
<span class="lineNum">     160 </span>            : static bool same_para (int c);
<span class="lineNum">     161 </span>            : static void flush_paragraph (void);
<span class="lineNum">     162 </span>            : static void fmt_paragraph (void);
<span class="lineNum">     163 </span>            : static void check_punctuation (WORD *w);
<span class="lineNum">     164 </span>            : static COST base_cost (WORD *this);
<span class="lineNum">     165 </span>            : static COST line_cost (WORD *next, int len);
<span class="lineNum">     166 </span>            : static void put_paragraph (WORD *finish);
<span class="lineNum">     167 </span>            : static void put_line (WORD *w, int indent);
<span class="lineNum">     168 </span>            : static void put_word (WORD *w);
<span class="lineNum">     169 </span>            : static void put_space (int space);
<span class="lineNum">     170 </span>            : 
<span class="lineNum">     171 </span>            : /* Option values.  */
<span class="lineNum">     172 </span>            : 
<span class="lineNum">     173 </span>            : /* If true, first 2 lines may have different indent (default false).  */
<span class="lineNum">     174 </span>            : static bool crown;
<span class="lineNum">     175 </span>            : 
<span class="lineNum">     176 </span>            : /* If true, first 2 lines _must_ have different indent (default false).  */
<span class="lineNum">     177 </span>            : static bool tagged;
<span class="lineNum">     178 </span>            : 
<span class="lineNum">     179 </span>            : /* If true, each line is a paragraph on its own (default false).  */
<span class="lineNum">     180 </span>            : static bool split;
<span class="lineNum">     181 </span>            : 
<span class="lineNum">     182 </span>            : /* If true, don't preserve inter-word spacing (default false).  */
<span class="lineNum">     183 </span>            : static bool uniform;
<span class="lineNum">     184 </span>            : 
<span class="lineNum">     185 </span>            : /* Prefix minus leading and trailing spaces (default &quot;&quot;).  */
<span class="lineNum">     186 </span>            : static const char *prefix;
<span class="lineNum">     187 </span>            : 
<span class="lineNum">     188 </span>            : /* User-supplied maximum line width (default WIDTH).  The only output
<span class="lineNum">     189 </span>            :    lines longer than this will each comprise a single word.  */
<span class="lineNum">     190 </span>            : static int max_width;
<span class="lineNum">     191 </span>            : 
<span class="lineNum">     192 </span>            : /* Values derived from the option values.  */
<span class="lineNum">     193 </span>            : 
<span class="lineNum">     194 </span>            : /* The length of prefix minus leading space.  */
<span class="lineNum">     195 </span>            : static int prefix_full_length;
<span class="lineNum">     196 </span>            : 
<span class="lineNum">     197 </span>            : /* The length of the leading space trimmed from the prefix.  */
<span class="lineNum">     198 </span>            : static int prefix_lead_space;
<span class="lineNum">     199 </span>            : 
<span class="lineNum">     200 </span>            : /* The length of prefix minus leading and trailing space.  */
<span class="lineNum">     201 </span>            : static int prefix_length;
<span class="lineNum">     202 </span>            : 
<span class="lineNum">     203 </span>            : /* The preferred width of text lines, set to LEEWAY % less than max_width.  */
<span class="lineNum">     204 </span>            : static int goal_width;
<span class="lineNum">     205 </span>            : 
<span class="lineNum">     206 </span>            : /* Dynamic variables.  */
<span class="lineNum">     207 </span>            : 
<span class="lineNum">     208 </span>            : /* Start column of the character most recently read from the input file.  */
<span class="lineNum">     209 </span>            : static int in_column;
<span class="lineNum">     210 </span>            : 
<span class="lineNum">     211 </span>            : /* Start column of the next character to be written to stdout.  */
<span class="lineNum">     212 </span>            : static int out_column;
<span class="lineNum">     213 </span>            : 
<span class="lineNum">     214 </span>            : /* Space for the paragraph text -- longer paragraphs are handled neatly
<span class="lineNum">     215 </span>            :    (cf. flush_paragraph()).  */
<span class="lineNum">     216 </span>            : static char parabuf[MAXCHARS];
<span class="lineNum">     217 </span>            : 
<span class="lineNum">     218 </span>            : /* A pointer into parabuf, indicating the first unused character position.  */
<span class="lineNum">     219 </span>            : static char *wptr;
<span class="lineNum">     220 </span>            : 
<span class="lineNum">     221 </span>            : /* The words of a paragraph -- longer paragraphs are handled neatly
<span class="lineNum">     222 </span>            :    (cf. flush_paragraph()).  */
<span class="lineNum">     223 </span>            : static WORD word[MAXWORDS];
<span class="lineNum">     224 </span>            : 
<span class="lineNum">     225 </span>            : /* A pointer into the above word array, indicating the first position
<span class="lineNum">     226 </span>            :    after the last complete word.  Sometimes it will point at an incomplete
<span class="lineNum">     227 </span>            :    word.  */
<span class="lineNum">     228 </span>            : static WORD *word_limit;
<span class="lineNum">     229 </span>            : 
<span class="lineNum">     230 </span>            : /* If true, current input file contains tab characters, and so tabs can be
<span class="lineNum">     231 </span>            :    used for white space on output.  */
<span class="lineNum">     232 </span>            : static bool tabs;
<span class="lineNum">     233 </span>            : 
<span class="lineNum">     234 </span>            : /* Space before trimmed prefix on each line of the current paragraph.  */
<span class="lineNum">     235 </span>            : static int prefix_indent;
<span class="lineNum">     236 </span>            : 
<span class="lineNum">     237 </span>            : /* Indentation of the first line of the current paragraph.  */
<span class="lineNum">     238 </span>            : static int first_indent;
<span class="lineNum">     239 </span>            : 
<span class="lineNum">     240 </span>            : /* Indentation of other lines of the current paragraph */
<span class="lineNum">     241 </span>            : static int other_indent;
<span class="lineNum">     242 </span>            : 
<span class="lineNum">     243 </span>            : /* To detect the end of a paragraph, we need to look ahead to the first
<span class="lineNum">     244 </span>            :    non-blank character after the prefix on the next line, or the first
<span class="lineNum">     245 </span>            :    character on the following line that failed to match the prefix.
<span class="lineNum">     246 </span>            :    We can reconstruct the lookahead from that character (next_char), its
<span class="lineNum">     247 </span>            :    position on the line (in_column) and the amount of space before the
<span class="lineNum">     248 </span>            :    prefix (next_prefix_indent).  See get_paragraph() and copy_rest().  */
<span class="lineNum">     249 </span>            : 
<span class="lineNum">     250 </span>            : /* The last character read from the input file.  */
<span class="lineNum">     251 </span>            : static int next_char;
<span class="lineNum">     252 </span>            : 
<span class="lineNum">     253 </span>            : /* The space before the trimmed prefix (or part of it) on the next line
<span class="lineNum">     254 </span>            :    after the current paragraph.  */
<span class="lineNum">     255 </span>            : static int next_prefix_indent;
<span class="lineNum">     256 </span>            : 
<span class="lineNum">     257 </span>            : /* If nonzero, the length of the last line output in the current
<span class="lineNum">     258 </span>            :    paragraph, used to charge for raggedness at the split point for long
<span class="lineNum">     259 </span>            :    paragraphs chosen by fmt_paragraph().  */
<span class="lineNum">     260 </span>            : static int last_line_length;
<a name="261"><span class="lineNum">     261 </span>            : </a>
<span class="lineNum">     262 </span>            : void
<span class="lineNum">     263 </span><span class="lineNoCov">          0 : usage (int status)</span>
<span class="lineNum">     264 </span>            : {
<span class="lineNum">     265 </span><span class="lineNoCov">          0 :   if (status != EXIT_SUCCESS)</span>
<span class="lineNum">     266 </span><span class="lineNoCov">          0 :     emit_try_help ();</span>
<span class="lineNum">     267 </span>            :   else
<span class="lineNum">     268 </span>            :     {
<span class="lineNum">     269 </span><span class="lineNoCov">          0 :       printf (_(&quot;Usage: %s [-WIDTH] [OPTION]... [FILE]...\n&quot;), program_name);</span>
<span class="lineNum">     270 </span><span class="lineNoCov">          0 :       fputs (_(&quot;\</span>
<span class="lineNum">     271 </span>            : Reformat each paragraph in the FILE(s), writing to standard output.\n\
<span class="lineNum">     272 </span>            : The option -WIDTH is an abbreviated form of --width=DIGITS.\n\
<span class="lineNum">     273 </span>            : &quot;), stdout);
<span class="lineNum">     274 </span>            : 
<span class="lineNum">     275 </span><span class="lineNoCov">          0 :       emit_stdin_note ();</span>
<span class="lineNum">     276 </span><span class="lineNoCov">          0 :       emit_mandatory_arg_note ();</span>
<span class="lineNum">     277 </span>            : 
<span class="lineNum">     278 </span><span class="lineNoCov">          0 :       fputs (_(&quot;\</span>
<span class="lineNum">     279 </span>            :   -c, --crown-margin        preserve indentation of first two lines\n\
<span class="lineNum">     280 </span>            :   -p, --prefix=STRING       reformat only lines beginning with STRING,\n\
<span class="lineNum">     281 </span>            :                               reattaching the prefix to reformatted lines\n\
<span class="lineNum">     282 </span>            :   -s, --split-only          split long lines, but do not refill\n\
<span class="lineNum">     283 </span>            : &quot;),
<span class="lineNum">     284 </span>            :              stdout);
<span class="lineNum">     285 </span>            :       /* Tell xgettext that the &quot;% o&quot; below is not a printf-style
<span class="lineNum">     286 </span>            :          format string:  xgettext:no-c-format */
<span class="lineNum">     287 </span><span class="lineNoCov">          0 :       fputs (_(&quot;\</span>
<span class="lineNum">     288 </span>            :   -t, --tagged-paragraph    indentation of first line different from second\n\
<span class="lineNum">     289 </span>            :   -u, --uniform-spacing     one space between words, two after sentences\n\
<span class="lineNum">     290 </span>            :   -w, --width=WIDTH         maximum line width (default of 75 columns)\n\
<span class="lineNum">     291 </span>            :   -g, --goal=WIDTH          goal width (default of 93% of width)\n\
<span class="lineNum">     292 </span>            : &quot;), stdout);
<span class="lineNum">     293 </span><span class="lineNoCov">          0 :       fputs (HELP_OPTION_DESCRIPTION, stdout);</span>
<span class="lineNum">     294 </span><span class="lineNoCov">          0 :       fputs (VERSION_OPTION_DESCRIPTION, stdout);</span>
<span class="lineNum">     295 </span><span class="lineNoCov">          0 :       emit_ancillary_info (PROGRAM_NAME);</span>
<span class="lineNum">     296 </span>            :     }
<span class="lineNum">     297 </span><span class="lineNoCov">          0 :   exit (status);</span>
<span class="lineNum">     298 </span>            : }
<span class="lineNum">     299 </span>            : 
<span class="lineNum">     300 </span>            : /* Decode options and launch execution.  */
<span class="lineNum">     301 </span>            : 
<span class="lineNum">     302 </span>            : static struct option const long_options[] =
<span class="lineNum">     303 </span>            : {
<span class="lineNum">     304 </span>            :   {&quot;crown-margin&quot;, no_argument, NULL, 'c'},
<span class="lineNum">     305 </span>            :   {&quot;prefix&quot;, required_argument, NULL, 'p'},
<span class="lineNum">     306 </span>            :   {&quot;split-only&quot;, no_argument, NULL, 's'},
<span class="lineNum">     307 </span>            :   {&quot;tagged-paragraph&quot;, no_argument, NULL, 't'},
<span class="lineNum">     308 </span>            :   {&quot;uniform-spacing&quot;, no_argument, NULL, 'u'},
<span class="lineNum">     309 </span>            :   {&quot;width&quot;, required_argument, NULL, 'w'},
<span class="lineNum">     310 </span>            :   {&quot;goal&quot;, required_argument, NULL, 'g'},
<span class="lineNum">     311 </span>            :   {GETOPT_HELP_OPTION_DECL},
<span class="lineNum">     312 </span>            :   {GETOPT_VERSION_OPTION_DECL},
<span class="lineNum">     313 </span>            :   {NULL, 0, NULL, 0},
<span class="lineNum">     314 </span>            : };
<a name="315"><span class="lineNum">     315 </span>            : </a>
<span class="lineNum">     316 </span>            : int
<span class="lineNum">     317 </span><span class="lineNoCov">          0 : main (int argc, char **argv)</span>
<span class="lineNum">     318 </span>            : {
<span class="lineNum">     319 </span>            :   int optchar;
<span class="lineNum">     320 </span><span class="lineNoCov">          0 :   bool ok = true;</span>
<span class="lineNum">     321 </span><span class="lineNoCov">          0 :   char const *max_width_option = NULL;</span>
<span class="lineNum">     322 </span><span class="lineNoCov">          0 :   char const *goal_width_option = NULL;</span>
<span class="lineNum">     323 </span>            : 
<span class="lineNum">     324 </span>            :   initialize_main (&amp;argc, &amp;argv);
<span class="lineNum">     325 </span><span class="lineNoCov">          0 :   set_program_name (argv[0]);</span>
<span class="lineNum">     326 </span><span class="lineNoCov">          0 :   setlocale (LC_ALL, &quot;&quot;);</span>
<span class="lineNum">     327 </span><span class="lineNoCov">          0 :   bindtextdomain (PACKAGE, LOCALEDIR);</span>
<span class="lineNum">     328 </span><span class="lineNoCov">          0 :   textdomain (PACKAGE);</span>
<span class="lineNum">     329 </span>            : 
<span class="lineNum">     330 </span><span class="lineNoCov">          0 :   atexit (close_stdout);</span>
<span class="lineNum">     331 </span>            : 
<span class="lineNum">     332 </span><span class="lineNoCov">          0 :   crown = tagged = split = uniform = false;</span>
<span class="lineNum">     333 </span><span class="lineNoCov">          0 :   max_width = WIDTH;</span>
<span class="lineNum">     334 </span><span class="lineNoCov">          0 :   prefix = &quot;&quot;;</span>
<span class="lineNum">     335 </span><span class="lineNoCov">          0 :   prefix_length = prefix_lead_space = prefix_full_length = 0;</span>
<span class="lineNum">     336 </span>            : 
<span class="lineNum">     337 </span><span class="lineNoCov">          0 :   if (argc &gt; 1 &amp;&amp; argv[1][0] == '-' &amp;&amp; ISDIGIT (argv[1][1]))</span>
<span class="lineNum">     338 </span>            :     {
<span class="lineNum">     339 </span>            :       /* Old option syntax; a dash followed by one or more digits.  */
<span class="lineNum">     340 </span><span class="lineNoCov">          0 :       max_width_option = argv[1] + 1;</span>
<span class="lineNum">     341 </span>            : 
<span class="lineNum">     342 </span>            :       /* Make the option we just parsed invisible to getopt.  */
<span class="lineNum">     343 </span><span class="lineNoCov">          0 :       argv[1] = argv[0];</span>
<span class="lineNum">     344 </span><span class="lineNoCov">          0 :       argv++;</span>
<span class="lineNum">     345 </span><span class="lineNoCov">          0 :       argc--;</span>
<span class="lineNum">     346 </span>            :     }
<span class="lineNum">     347 </span>            : 
<span class="lineNum">     348 </span><span class="lineNoCov">          0 :   while ((optchar = getopt_long (argc, argv, &quot;0123456789cstuw:p:g:&quot;,</span>
<span class="lineNum">     349 </span>            :                                  long_options, NULL))
<span class="lineNum">     350 </span>            :          != -1)
<span class="lineNum">     351 </span><span class="lineNoCov">          0 :     switch (optchar)</span>
<span class="lineNum">     352 </span>            :       {
<span class="lineNum">     353 </span>            :       default:
<span class="lineNum">     354 </span><span class="lineNoCov">          0 :         if (ISDIGIT (optchar))</span>
<span class="lineNum">     355 </span><span class="lineNoCov">          0 :           error (0, 0, _(&quot;invalid option -- %c; -WIDTH is recognized\</span>
<span class="lineNum">     356 </span>            :  only when it is the first\noption; use -w N instead&quot;),
<span class="lineNum">     357 </span>            :                  optchar);
<span class="lineNum">     358 </span><span class="lineNoCov">          0 :         usage (EXIT_FAILURE);</span>
<span class="lineNum">     359 </span>            : 
<span class="lineNum">     360 </span>            :       case 'c':
<span class="lineNum">     361 </span><span class="lineNoCov">          0 :         crown = true;</span>
<span class="lineNum">     362 </span><span class="lineNoCov">          0 :         break;</span>
<span class="lineNum">     363 </span>            : 
<span class="lineNum">     364 </span>            :       case 's':
<span class="lineNum">     365 </span><span class="lineNoCov">          0 :         split = true;</span>
<span class="lineNum">     366 </span><span class="lineNoCov">          0 :         break;</span>
<span class="lineNum">     367 </span>            : 
<span class="lineNum">     368 </span>            :       case 't':
<span class="lineNum">     369 </span><span class="lineNoCov">          0 :         tagged = true;</span>
<span class="lineNum">     370 </span><span class="lineNoCov">          0 :         break;</span>
<span class="lineNum">     371 </span>            : 
<span class="lineNum">     372 </span>            :       case 'u':
<span class="lineNum">     373 </span><span class="lineNoCov">          0 :         uniform = true;</span>
<span class="lineNum">     374 </span><span class="lineNoCov">          0 :         break;</span>
<span class="lineNum">     375 </span>            : 
<span class="lineNum">     376 </span>            :       case 'w':
<span class="lineNum">     377 </span><span class="lineNoCov">          0 :         max_width_option = optarg;</span>
<span class="lineNum">     378 </span><span class="lineNoCov">          0 :         break;</span>
<span class="lineNum">     379 </span>            : 
<span class="lineNum">     380 </span>            :       case 'g':
<span class="lineNum">     381 </span><span class="lineNoCov">          0 :         goal_width_option = optarg;</span>
<span class="lineNum">     382 </span><span class="lineNoCov">          0 :         break;</span>
<span class="lineNum">     383 </span>            : 
<span class="lineNum">     384 </span>            :       case 'p':
<span class="lineNum">     385 </span><span class="lineNoCov">          0 :         set_prefix (optarg);</span>
<span class="lineNum">     386 </span><span class="lineNoCov">          0 :         break;</span>
<span class="lineNum">     387 </span>            : 
<span class="lineNum">     388 </span><span class="lineNoCov">          0 :       case_GETOPT_HELP_CHAR;</span>
<span class="lineNum">     389 </span>            : 
<span class="lineNum">     390 </span><span class="lineNoCov">          0 :       case_GETOPT_VERSION_CHAR (PROGRAM_NAME, AUTHORS);</span>
<span class="lineNum">     391 </span>            : 
<span class="lineNum">     392 </span>            :       }
<span class="lineNum">     393 </span>            : 
<span class="lineNum">     394 </span><span class="lineNoCov">          0 :   if (max_width_option)</span>
<span class="lineNum">     395 </span>            :     {
<span class="lineNum">     396 </span>            :       /* Limit max_width to MAXCHARS / 2; otherwise, the resulting
<span class="lineNum">     397 </span>            :          output can be quite ugly.  */
<span class="lineNum">     398 </span><span class="lineNoCov">          0 :       max_width = xdectoumax (max_width_option, 0, MAXCHARS / 2, &quot;&quot;,</span>
<span class="lineNum">     399 </span><span class="lineNoCov">          0 :                               _(&quot;invalid width&quot;), 0);</span>
<span class="lineNum">     400 </span>            :     }
<span class="lineNum">     401 </span>            : 
<span class="lineNum">     402 </span><span class="lineNoCov">          0 :   if (goal_width_option)</span>
<span class="lineNum">     403 </span>            :     {
<span class="lineNum">     404 </span>            :       /* Limit goal_width to max_width.  */
<span class="lineNum">     405 </span><span class="lineNoCov">          0 :       goal_width = xdectoumax (goal_width_option, 0, max_width, &quot;&quot;,</span>
<span class="lineNum">     406 </span><span class="lineNoCov">          0 :                                _(&quot;invalid width&quot;), 0);</span>
<span class="lineNum">     407 </span><span class="lineNoCov">          0 :       if (max_width_option == NULL)</span>
<span class="lineNum">     408 </span><span class="lineNoCov">          0 :         max_width = goal_width + 10;</span>
<span class="lineNum">     409 </span>            :     }
<span class="lineNum">     410 </span>            :   else
<span class="lineNum">     411 </span>            :     {
<span class="lineNum">     412 </span><span class="lineNoCov">          0 :       goal_width = max_width * (2 * (100 - LEEWAY) + 1) / 200;</span>
<span class="lineNum">     413 </span>            :     }
<span class="lineNum">     414 </span>            : 
<span class="lineNum">     415 </span><span class="lineNoCov">          0 :   if (optind == argc)</span>
<span class="lineNum">     416 </span><span class="lineNoCov">          0 :     fmt (stdin);</span>
<span class="lineNum">     417 </span>            :   else
<span class="lineNum">     418 </span>            :     {
<span class="lineNum">     419 </span><span class="lineNoCov">          0 :       for (; optind &lt; argc; optind++)</span>
<span class="lineNum">     420 </span>            :         {
<span class="lineNum">     421 </span><span class="lineNoCov">          0 :           char *file = argv[optind];</span>
<span class="lineNum">     422 </span><span class="lineNoCov">          0 :           if (STREQ (file, &quot;-&quot;))</span>
<span class="lineNum">     423 </span><span class="lineNoCov">          0 :             fmt (stdin);</span>
<span class="lineNum">     424 </span>            :           else
<span class="lineNum">     425 </span>            :             {
<span class="lineNum">     426 </span>            :               FILE *in_stream;
<span class="lineNum">     427 </span><span class="lineNoCov">          0 :               in_stream = fopen (file, &quot;r&quot;);</span>
<span class="lineNum">     428 </span><span class="lineNoCov">          0 :               if (in_stream != NULL)</span>
<span class="lineNum">     429 </span>            :                 {
<span class="lineNum">     430 </span><span class="lineNoCov">          0 :                   fmt (in_stream);</span>
<span class="lineNum">     431 </span><span class="lineNoCov">          0 :                   if (fclose (in_stream) == EOF)</span>
<span class="lineNum">     432 </span>            :                     {
<span class="lineNum">     433 </span><span class="lineNoCov">          0 :                       error (0, errno, &quot;%s&quot;, quotef (file));</span>
<span class="lineNum">     434 </span><span class="lineNoCov">          0 :                       ok = false;</span>
<span class="lineNum">     435 </span>            :                     }
<span class="lineNum">     436 </span>            :                 }
<span class="lineNum">     437 </span>            :               else
<span class="lineNum">     438 </span>            :                 {
<span class="lineNum">     439 </span><span class="lineNoCov">          0 :                   error (0, errno, _(&quot;cannot open %s for reading&quot;),</span>
<span class="lineNum">     440 </span>            :                          quoteaf (file));
<span class="lineNum">     441 </span><span class="lineNoCov">          0 :                   ok = false;</span>
<span class="lineNum">     442 </span>            :                 }
<span class="lineNum">     443 </span>            :             }
<span class="lineNum">     444 </span>            :         }
<span class="lineNum">     445 </span>            :     }
<span class="lineNum">     446 </span>            : 
<span class="lineNum">     447 </span><span class="lineNoCov">          0 :   return ok ? EXIT_SUCCESS : EXIT_FAILURE;</span>
<span class="lineNum">     448 </span>            : }
<span class="lineNum">     449 </span>            : 
<span class="lineNum">     450 </span>            : /* Trim space from the front and back of the string P, yielding the prefix,
<span class="lineNum">     451 </span>            :    and record the lengths of the prefix and the space trimmed.  */
<a name="452"><span class="lineNum">     452 </span>            : </a>
<span class="lineNum">     453 </span>            : static void
<span class="lineNum">     454 </span><span class="lineNoCov">          0 : set_prefix (char *p)</span>
<span class="lineNum">     455 </span>            : {
<span class="lineNum">     456 </span>            :   char *s;
<span class="lineNum">     457 </span>            : 
<span class="lineNum">     458 </span><span class="lineNoCov">          0 :   prefix_lead_space = 0;</span>
<span class="lineNum">     459 </span><span class="lineNoCov">          0 :   while (*p == ' ')</span>
<span class="lineNum">     460 </span>            :     {
<span class="lineNum">     461 </span><span class="lineNoCov">          0 :       prefix_lead_space++;</span>
<span class="lineNum">     462 </span><span class="lineNoCov">          0 :       p++;</span>
<span class="lineNum">     463 </span>            :     }
<span class="lineNum">     464 </span><span class="lineNoCov">          0 :   prefix = p;</span>
<span class="lineNum">     465 </span><span class="lineNoCov">          0 :   prefix_full_length = strlen (p);</span>
<span class="lineNum">     466 </span><span class="lineNoCov">          0 :   s = p + prefix_full_length;</span>
<span class="lineNum">     467 </span><span class="lineNoCov">          0 :   while (s &gt; p &amp;&amp; s[-1] == ' ')</span>
<span class="lineNum">     468 </span><span class="lineNoCov">          0 :     s--;</span>
<span class="lineNum">     469 </span><span class="lineNoCov">          0 :   *s = '\0';</span>
<span class="lineNum">     470 </span><span class="lineNoCov">          0 :   prefix_length = s - p;</span>
<span class="lineNum">     471 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     472 </span>            : 
<span class="lineNum">     473 </span>            : /* read file F and send formatted output to stdout.  */
<a name="474"><span class="lineNum">     474 </span>            : </a>
<span class="lineNum">     475 </span>            : static void
<span class="lineNum">     476 </span><span class="lineNoCov">          0 : fmt (FILE *f)</span>
<span class="lineNum">     477 </span>            : {
<span class="lineNum">     478 </span><span class="lineNoCov">          0 :   fadvise (f, FADVISE_SEQUENTIAL);</span>
<span class="lineNum">     479 </span><span class="lineNoCov">          0 :   tabs = false;</span>
<span class="lineNum">     480 </span><span class="lineNoCov">          0 :   other_indent = 0;</span>
<span class="lineNum">     481 </span><span class="lineNoCov">          0 :   next_char = get_prefix (f);</span>
<span class="lineNum">     482 </span><span class="lineNoCov">          0 :   while (get_paragraph (f))</span>
<span class="lineNum">     483 </span>            :     {
<span class="lineNum">     484 </span><span class="lineNoCov">          0 :       fmt_paragraph ();</span>
<span class="lineNum">     485 </span><span class="lineNoCov">          0 :       put_paragraph (word_limit);</span>
<span class="lineNum">     486 </span>            :     }
<span class="lineNum">     487 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     488 </span>            : 
<span class="lineNum">     489 </span>            : /* Set the global variable 'other_indent' according to SAME_PARAGRAPH
<span class="lineNum">     490 </span>            :    and other global variables.  */
<a name="491"><span class="lineNum">     491 </span>            : </a>
<span class="lineNum">     492 </span>            : static void
<span class="lineNum">     493 </span><span class="lineNoCov">          0 : set_other_indent (bool same_paragraph)</span>
<span class="lineNum">     494 </span>            : {
<span class="lineNum">     495 </span><span class="lineNoCov">          0 :   if (split)</span>
<span class="lineNum">     496 </span><span class="lineNoCov">          0 :     other_indent = first_indent;</span>
<span class="lineNum">     497 </span><span class="lineNoCov">          0 :   else if (crown)</span>
<span class="lineNum">     498 </span>            :     {
<span class="lineNum">     499 </span><span class="lineNoCov">          0 :       other_indent = (same_paragraph ? in_column : first_indent);</span>
<span class="lineNum">     500 </span>            :     }
<span class="lineNum">     501 </span><span class="lineNoCov">          0 :   else if (tagged)</span>
<span class="lineNum">     502 </span>            :     {
<span class="lineNum">     503 </span><span class="lineNoCov">          0 :       if (same_paragraph &amp;&amp; in_column != first_indent)</span>
<span class="lineNum">     504 </span>            :         {
<span class="lineNum">     505 </span><span class="lineNoCov">          0 :           other_indent = in_column;</span>
<span class="lineNum">     506 </span>            :         }
<span class="lineNum">     507 </span>            : 
<span class="lineNum">     508 </span>            :       /* Only one line: use the secondary indent from last time if it
<span class="lineNum">     509 </span>            :          splits, or 0 if there have been no multi-line paragraphs in the
<span class="lineNum">     510 </span>            :          input so far.  But if these rules make the two indents the same,
<span class="lineNum">     511 </span>            :          pick a new secondary indent.  */
<span class="lineNum">     512 </span>            : 
<span class="lineNum">     513 </span><span class="lineNoCov">          0 :       else if (other_indent == first_indent)</span>
<span class="lineNum">     514 </span><span class="lineNoCov">          0 :         other_indent = first_indent == 0 ? DEF_INDENT : 0;</span>
<span class="lineNum">     515 </span>            :     }
<span class="lineNum">     516 </span>            :   else
<span class="lineNum">     517 </span>            :     {
<span class="lineNum">     518 </span><span class="lineNoCov">          0 :       other_indent = first_indent;</span>
<span class="lineNum">     519 </span>            :     }
<span class="lineNum">     520 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     521 </span>            : 
<span class="lineNum">     522 </span>            : /* Read a paragraph from input file F.  A paragraph consists of a
<span class="lineNum">     523 </span>            :    maximal number of non-blank (excluding any prefix) lines subject to:
<span class="lineNum">     524 </span>            :    * In split mode, a paragraph is a single non-blank line.
<span class="lineNum">     525 </span>            :    * In crown mode, the second and subsequent lines must have the
<span class="lineNum">     526 </span>            :    same indentation, but possibly different from the indent of the
<span class="lineNum">     527 </span>            :    first line.
<span class="lineNum">     528 </span>            :    * Tagged mode is similar, but the first and second lines must have
<span class="lineNum">     529 </span>            :    different indentations.
<span class="lineNum">     530 </span>            :    * Otherwise, all lines of a paragraph must have the same indent.
<span class="lineNum">     531 </span>            :    If a prefix is in effect, it must be present at the same indent for
<span class="lineNum">     532 </span>            :    each line in the paragraph.
<span class="lineNum">     533 </span>            : 
<span class="lineNum">     534 </span>            :    Return false if end-of-file was encountered before the start of a
<span class="lineNum">     535 </span>            :    paragraph, else true.  */
<a name="536"><span class="lineNum">     536 </span>            : </a>
<span class="lineNum">     537 </span>            : static bool
<span class="lineNum">     538 </span><span class="lineNoCov">          0 : get_paragraph (FILE *f)</span>
<span class="lineNum">     539 </span>            : {
<span class="lineNum">     540 </span>            :   int c;
<span class="lineNum">     541 </span>            : 
<span class="lineNum">     542 </span><span class="lineNoCov">          0 :   last_line_length = 0;</span>
<span class="lineNum">     543 </span><span class="lineNoCov">          0 :   c = next_char;</span>
<span class="lineNum">     544 </span>            : 
<span class="lineNum">     545 </span>            :   /* Scan (and copy) blank lines, and lines not introduced by the prefix.  */
<span class="lineNum">     546 </span>            : 
<span class="lineNum">     547 </span><span class="lineNoCov">          0 :   while (c == '\n' || c == EOF</span>
<span class="lineNum">     548 </span><span class="lineNoCov">          0 :          || next_prefix_indent &lt; prefix_lead_space</span>
<span class="lineNum">     549 </span><span class="lineNoCov">          0 :          || in_column &lt; next_prefix_indent + prefix_full_length)</span>
<span class="lineNum">     550 </span>            :     {
<span class="lineNum">     551 </span><span class="lineNoCov">          0 :       c = copy_rest (f, c);</span>
<span class="lineNum">     552 </span><span class="lineNoCov">          0 :       if (c == EOF)</span>
<span class="lineNum">     553 </span>            :         {
<span class="lineNum">     554 </span><span class="lineNoCov">          0 :           next_char = EOF;</span>
<span class="lineNum">     555 </span><span class="lineNoCov">          0 :           return false;</span>
<span class="lineNum">     556 </span>            :         }
<span class="lineNum">     557 </span><span class="lineNoCov">          0 :       putchar ('\n');</span>
<span class="lineNum">     558 </span><span class="lineNoCov">          0 :       c = get_prefix (f);</span>
<span class="lineNum">     559 </span>            :     }
<span class="lineNum">     560 </span>            : 
<span class="lineNum">     561 </span>            :   /* Got a suitable first line for a paragraph.  */
<span class="lineNum">     562 </span>            : 
<span class="lineNum">     563 </span><span class="lineNoCov">          0 :   prefix_indent = next_prefix_indent;</span>
<span class="lineNum">     564 </span><span class="lineNoCov">          0 :   first_indent = in_column;</span>
<span class="lineNum">     565 </span><span class="lineNoCov">          0 :   wptr = parabuf;</span>
<span class="lineNum">     566 </span><span class="lineNoCov">          0 :   word_limit = word;</span>
<span class="lineNum">     567 </span><span class="lineNoCov">          0 :   c = get_line (f, c);</span>
<span class="lineNum">     568 </span><span class="lineNoCov">          0 :   set_other_indent (same_para (c));</span>
<span class="lineNum">     569 </span>            : 
<span class="lineNum">     570 </span>            :   /* Read rest of paragraph (unless split is specified).  */
<span class="lineNum">     571 </span>            : 
<span class="lineNum">     572 </span><span class="lineNoCov">          0 :   if (split)</span>
<span class="lineNum">     573 </span>            :     {
<span class="lineNum">     574 </span>            :       /* empty */
<span class="lineNum">     575 </span>            :     }
<span class="lineNum">     576 </span><span class="lineNoCov">          0 :   else if (crown)</span>
<span class="lineNum">     577 </span>            :     {
<span class="lineNum">     578 </span><span class="lineNoCov">          0 :       if (same_para (c))</span>
<span class="lineNum">     579 </span>            :         {
<span class="lineNum">     580 </span>            :           do
<span class="lineNum">     581 </span>            :             {                   /* for each line till the end of the para */
<span class="lineNum">     582 </span><span class="lineNoCov">          0 :               c = get_line (f, c);</span>
<span class="lineNum">     583 </span>            :             }
<span class="lineNum">     584 </span><span class="lineNoCov">          0 :           while (same_para (c) &amp;&amp; in_column == other_indent);</span>
<span class="lineNum">     585 </span>            :         }
<span class="lineNum">     586 </span>            :     }
<span class="lineNum">     587 </span><span class="lineNoCov">          0 :   else if (tagged)</span>
<span class="lineNum">     588 </span>            :     {
<span class="lineNum">     589 </span><span class="lineNoCov">          0 :       if (same_para (c) &amp;&amp; in_column != first_indent)</span>
<span class="lineNum">     590 </span>            :         {
<span class="lineNum">     591 </span>            :           do
<span class="lineNum">     592 </span>            :             {                   /* for each line till the end of the para */
<span class="lineNum">     593 </span><span class="lineNoCov">          0 :               c = get_line (f, c);</span>
<span class="lineNum">     594 </span>            :             }
<span class="lineNum">     595 </span><span class="lineNoCov">          0 :           while (same_para (c) &amp;&amp; in_column == other_indent);</span>
<span class="lineNum">     596 </span>            :         }
<span class="lineNum">     597 </span>            :     }
<span class="lineNum">     598 </span>            :   else
<span class="lineNum">     599 </span>            :     {
<span class="lineNum">     600 </span><span class="lineNoCov">          0 :       while (same_para (c) &amp;&amp; in_column == other_indent)</span>
<span class="lineNum">     601 </span><span class="lineNoCov">          0 :         c = get_line (f, c);</span>
<span class="lineNum">     602 </span>            :     }
<span class="lineNum">     603 </span>            : 
<span class="lineNum">     604 </span>            :   /* Tell static analysis tools that using word_limit[-1] is ok.
<span class="lineNum">     605 </span>            :      word_limit is guaranteed to have been incremented by get_line.  */
<span class="lineNum">     606 </span><span class="lineNoCov">          0 :   assert (word &lt; word_limit);</span>
<span class="lineNum">     607 </span>            : 
<span class="lineNum">     608 </span><span class="lineNoCov">          0 :   (word_limit - 1)-&gt;period = (word_limit - 1)-&gt;final = true;</span>
<span class="lineNum">     609 </span><span class="lineNoCov">          0 :   next_char = c;</span>
<span class="lineNum">     610 </span><span class="lineNoCov">          0 :   return true;</span>
<span class="lineNum">     611 </span>            : }
<span class="lineNum">     612 </span>            : 
<span class="lineNum">     613 </span>            : /* Copy to the output a line that failed to match the prefix, or that
<span class="lineNum">     614 </span>            :    was blank after the prefix.  In the former case, C is the character
<span class="lineNum">     615 </span>            :    that failed to match the prefix.  In the latter, C is \n or EOF.
<span class="lineNum">     616 </span>            :    Return the character (\n or EOF) ending the line.  */
<a name="617"><span class="lineNum">     617 </span>            : </a>
<span class="lineNum">     618 </span>            : static int
<span class="lineNum">     619 </span><span class="lineNoCov">          0 : copy_rest (FILE *f, int c)</span>
<span class="lineNum">     620 </span>            : {
<span class="lineNum">     621 </span>            :   const char *s;
<span class="lineNum">     622 </span>            : 
<span class="lineNum">     623 </span><span class="lineNoCov">          0 :   out_column = 0;</span>
<span class="lineNum">     624 </span><span class="lineNoCov">          0 :   if (in_column &gt; next_prefix_indent || (c != '\n' &amp;&amp; c != EOF))</span>
<span class="lineNum">     625 </span>            :     {
<span class="lineNum">     626 </span><span class="lineNoCov">          0 :       put_space (next_prefix_indent);</span>
<span class="lineNum">     627 </span><span class="lineNoCov">          0 :       for (s = prefix; out_column != in_column &amp;&amp; *s; out_column++)</span>
<span class="lineNum">     628 </span><span class="lineNoCov">          0 :         putchar (*s++);</span>
<span class="lineNum">     629 </span><span class="lineNoCov">          0 :       if (c != EOF &amp;&amp; c != '\n')</span>
<span class="lineNum">     630 </span><span class="lineNoCov">          0 :         put_space (in_column - out_column);</span>
<span class="lineNum">     631 </span><span class="lineNoCov">          0 :       if (c == EOF &amp;&amp; in_column &gt;= next_prefix_indent + prefix_length)</span>
<span class="lineNum">     632 </span>            :         putchar ('\n');
<span class="lineNum">     633 </span>            :     }
<span class="lineNum">     634 </span><span class="lineNoCov">          0 :   while (c != '\n' &amp;&amp; c != EOF)</span>
<span class="lineNum">     635 </span>            :     {
<span class="lineNum">     636 </span><span class="lineNoCov">          0 :       putchar (c);</span>
<span class="lineNum">     637 </span><span class="lineNoCov">          0 :       c = getc (f);</span>
<span class="lineNum">     638 </span>            :     }
<span class="lineNum">     639 </span><span class="lineNoCov">          0 :   return c;</span>
<span class="lineNum">     640 </span>            : }
<span class="lineNum">     641 </span>            : 
<span class="lineNum">     642 </span>            : /* Return true if a line whose first non-blank character after the
<span class="lineNum">     643 </span>            :    prefix (if any) is C could belong to the current paragraph,
<span class="lineNum">     644 </span>            :    otherwise false.  */
<span class="lineNum">     645 </span>            : 
<span class="lineNum">     646 </span>            : static bool
<span class="lineNum">     647 </span>            : same_para (int c)
<span class="lineNum">     648 </span>            : {
<span class="lineNum">     649 </span><span class="lineNoCov">          0 :   return (next_prefix_indent == prefix_indent</span>
<span class="lineNum">     650 </span><span class="lineNoCov">          0 :           &amp;&amp; in_column &gt;= next_prefix_indent + prefix_full_length</span>
<span class="lineNum">     651 </span><span class="lineNoCov">          0 :           &amp;&amp; c != '\n' &amp;&amp; c != EOF);</span>
<span class="lineNum">     652 </span>            : }
<span class="lineNum">     653 </span>            : 
<span class="lineNum">     654 </span>            : /* Read a line from input file F, given first non-blank character C
<span class="lineNum">     655 </span>            :    after the prefix, and the following indent, and break it into words.
<span class="lineNum">     656 </span>            :    A word is a maximal non-empty string of non-white characters.  A word
<span class="lineNum">     657 </span>            :    ending in [.?!][&quot;')\]]* and followed by end-of-line or at least two
<span class="lineNum">     658 </span>            :    spaces ends a sentence, as in emacs.
<span class="lineNum">     659 </span>            : 
<span class="lineNum">     660 </span>            :    Return the first non-blank character of the next line.  */
<a name="661"><span class="lineNum">     661 </span>            : </a>
<span class="lineNum">     662 </span>            : static int
<span class="lineNum">     663 </span><span class="lineNoCov">          0 : get_line (FILE *f, int c)</span>
<span class="lineNum">     664 </span>            : {
<span class="lineNum">     665 </span>            :   int start;
<span class="lineNum">     666 </span>            :   char *end_of_parabuf;
<span class="lineNum">     667 </span>            :   WORD *end_of_word;
<span class="lineNum">     668 </span>            : 
<span class="lineNum">     669 </span><span class="lineNoCov">          0 :   end_of_parabuf = &amp;parabuf[MAXCHARS];</span>
<span class="lineNum">     670 </span><span class="lineNoCov">          0 :   end_of_word = &amp;word[MAXWORDS - 2];</span>
<span class="lineNum">     671 </span>            : 
<span class="lineNum">     672 </span>            :   do
<span class="lineNum">     673 </span>            :     {                           /* for each word in a line */
<span class="lineNum">     674 </span>            : 
<span class="lineNum">     675 </span>            :       /* Scan word.  */
<span class="lineNum">     676 </span>            : 
<span class="lineNum">     677 </span><span class="lineNoCov">          0 :       word_limit-&gt;text = wptr;</span>
<span class="lineNum">     678 </span>            :       do
<span class="lineNum">     679 </span>            :         {
<span class="lineNum">     680 </span><span class="lineNoCov">          0 :           if (wptr == end_of_parabuf)</span>
<span class="lineNum">     681 </span>            :             {
<span class="lineNum">     682 </span><span class="lineNoCov">          0 :               set_other_indent (true);</span>
<span class="lineNum">     683 </span><span class="lineNoCov">          0 :               flush_paragraph ();</span>
<span class="lineNum">     684 </span>            :             }
<span class="lineNum">     685 </span><span class="lineNoCov">          0 :           *wptr++ = c;</span>
<span class="lineNum">     686 </span><span class="lineNoCov">          0 :           c = getc (f);</span>
<span class="lineNum">     687 </span>            :         }
<span class="lineNum">     688 </span><span class="lineNoCov">          0 :       while (c != EOF &amp;&amp; !isspace (c));</span>
<span class="lineNum">     689 </span><span class="lineNoCov">          0 :       in_column += word_limit-&gt;length = wptr - word_limit-&gt;text;</span>
<span class="lineNum">     690 </span><span class="lineNoCov">          0 :       check_punctuation (word_limit);</span>
<span class="lineNum">     691 </span>            : 
<span class="lineNum">     692 </span>            :       /* Scan inter-word space.  */
<span class="lineNum">     693 </span>            : 
<span class="lineNum">     694 </span><span class="lineNoCov">          0 :       start = in_column;</span>
<span class="lineNum">     695 </span><span class="lineNoCov">          0 :       c = get_space (f, c);</span>
<span class="lineNum">     696 </span><span class="lineNoCov">          0 :       word_limit-&gt;space = in_column - start;</span>
<span class="lineNum">     697 </span><span class="lineNoCov">          0 :       word_limit-&gt;final = (c == EOF</span>
<span class="lineNum">     698 </span><span class="lineNoCov">          0 :                            || (word_limit-&gt;period</span>
<span class="lineNum">     699 </span><span class="lineNoCov">          0 :                                &amp;&amp; (c == '\n' || word_limit-&gt;space &gt; 1)));</span>
<span class="lineNum">     700 </span><span class="lineNoCov">          0 :       if (c == '\n' || c == EOF || uniform)</span>
<span class="lineNum">     701 </span><span class="lineNoCov">          0 :         word_limit-&gt;space = word_limit-&gt;final ? 2 : 1;</span>
<span class="lineNum">     702 </span><span class="lineNoCov">          0 :       if (word_limit == end_of_word)</span>
<span class="lineNum">     703 </span>            :         {
<span class="lineNum">     704 </span><span class="lineNoCov">          0 :           set_other_indent (true);</span>
<span class="lineNum">     705 </span><span class="lineNoCov">          0 :           flush_paragraph ();</span>
<span class="lineNum">     706 </span>            :         }
<span class="lineNum">     707 </span><span class="lineNoCov">          0 :       word_limit++;</span>
<span class="lineNum">     708 </span>            :     }
<span class="lineNum">     709 </span><span class="lineNoCov">          0 :   while (c != '\n' &amp;&amp; c != EOF);</span>
<span class="lineNum">     710 </span><span class="lineNoCov">          0 :   return get_prefix (f);</span>
<span class="lineNum">     711 </span>            : }
<span class="lineNum">     712 </span>            : 
<span class="lineNum">     713 </span>            : /* Read a prefix from input file F.  Return either first non-matching
<span class="lineNum">     714 </span>            :    character, or first non-blank character after the prefix.  */
<a name="715"><span class="lineNum">     715 </span>            : </a>
<span class="lineNum">     716 </span>            : static int
<span class="lineNum">     717 </span><span class="lineNoCov">          0 : get_prefix (FILE *f)</span>
<span class="lineNum">     718 </span>            : {
<span class="lineNum">     719 </span>            :   int c;
<span class="lineNum">     720 </span>            : 
<span class="lineNum">     721 </span><span class="lineNoCov">          0 :   in_column = 0;</span>
<span class="lineNum">     722 </span><span class="lineNoCov">          0 :   c = get_space (f, getc (f));</span>
<span class="lineNum">     723 </span><span class="lineNoCov">          0 :   if (prefix_length == 0)</span>
<span class="lineNum">     724 </span><span class="lineNoCov">          0 :     next_prefix_indent = prefix_lead_space &lt; in_column ?</span>
<span class="lineNum">     725 </span><span class="lineNoCov">          0 :       prefix_lead_space : in_column;</span>
<span class="lineNum">     726 </span>            :   else
<span class="lineNum">     727 </span>            :     {
<span class="lineNum">     728 </span>            :       const char *p;
<span class="lineNum">     729 </span><span class="lineNoCov">          0 :       next_prefix_indent = in_column;</span>
<span class="lineNum">     730 </span><span class="lineNoCov">          0 :       for (p = prefix; *p != '\0'; p++)</span>
<span class="lineNum">     731 </span>            :         {
<span class="lineNum">     732 </span><span class="lineNoCov">          0 :           unsigned char pc = *p;</span>
<span class="lineNum">     733 </span><span class="lineNoCov">          0 :           if (c != pc)</span>
<span class="lineNum">     734 </span>            :             return c;
<span class="lineNum">     735 </span><span class="lineNoCov">          0 :           in_column++;</span>
<span class="lineNum">     736 </span><span class="lineNoCov">          0 :           c = getc (f);</span>
<span class="lineNum">     737 </span>            :         }
<span class="lineNum">     738 </span><span class="lineNoCov">          0 :       c = get_space (f, c);</span>
<span class="lineNum">     739 </span>            :     }
<span class="lineNum">     740 </span>            :   return c;
<span class="lineNum">     741 </span>            : }
<span class="lineNum">     742 </span>            : 
<span class="lineNum">     743 </span>            : /* Read blank characters from input file F, starting with C, and keeping
<span class="lineNum">     744 </span>            :    in_column up-to-date.  Return first non-blank character.  */
<a name="745"><span class="lineNum">     745 </span>            : </a>
<span class="lineNum">     746 </span>            : static int
<span class="lineNum">     747 </span><span class="lineNoCov">          0 : get_space (FILE *f, int c)</span>
<span class="lineNum">     748 </span>            : {
<span class="lineNum">     749 </span>            :   while (true)
<span class="lineNum">     750 </span>            :     {
<span class="lineNum">     751 </span><span class="lineNoCov">          0 :       if (c == ' ')</span>
<span class="lineNum">     752 </span><span class="lineNoCov">          0 :         in_column++;</span>
<span class="lineNum">     753 </span><span class="lineNoCov">          0 :       else if (c == '\t')</span>
<span class="lineNum">     754 </span>            :         {
<span class="lineNum">     755 </span><span class="lineNoCov">          0 :           tabs = true;</span>
<span class="lineNum">     756 </span><span class="lineNoCov">          0 :           in_column = (in_column / TABWIDTH + 1) * TABWIDTH;</span>
<span class="lineNum">     757 </span>            :         }
<span class="lineNum">     758 </span>            :       else
<span class="lineNum">     759 </span><span class="lineNoCov">          0 :         return c;</span>
<span class="lineNum">     760 </span><span class="lineNoCov">          0 :       c = getc (f);</span>
<span class="lineNum">     761 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">     762 </span>            : }
<span class="lineNum">     763 </span>            : 
<span class="lineNum">     764 </span>            : /* Set extra fields in word W describing any attached punctuation.  */
<a name="765"><span class="lineNum">     765 </span>            : </a>
<span class="lineNum">     766 </span>            : static void
<span class="lineNum">     767 </span><span class="lineNoCov">          0 : check_punctuation (WORD *w)</span>
<span class="lineNum">     768 </span>            : {
<span class="lineNum">     769 </span><span class="lineNoCov">          0 :   char const *start = w-&gt;text;</span>
<span class="lineNum">     770 </span><span class="lineNoCov">          0 :   char const *finish = start + (w-&gt;length - 1);</span>
<span class="lineNum">     771 </span><span class="lineNoCov">          0 :   unsigned char fin = *finish;</span>
<span class="lineNum">     772 </span>            : 
<span class="lineNum">     773 </span><span class="lineNoCov">          0 :   w-&gt;paren = isopen (*start);</span>
<span class="lineNum">     774 </span><span class="lineNoCov">          0 :   w-&gt;punct = !! ispunct (fin);</span>
<span class="lineNum">     775 </span><span class="lineNoCov">          0 :   while (start &lt; finish &amp;&amp; isclose (*finish))</span>
<span class="lineNum">     776 </span><span class="lineNoCov">          0 :     finish--;</span>
<span class="lineNum">     777 </span><span class="lineNoCov">          0 :   w-&gt;period = isperiod (*finish);</span>
<span class="lineNum">     778 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     779 </span>            : 
<span class="lineNum">     780 </span>            : /* Flush part of the paragraph to make room.  This function is called on
<span class="lineNum">     781 </span>            :    hitting the limit on the number of words or characters.  */
<a name="782"><span class="lineNum">     782 </span>            : </a>
<span class="lineNum">     783 </span>            : static void
<span class="lineNum">     784 </span><span class="lineNoCov">          0 : flush_paragraph (void)</span>
<span class="lineNum">     785 </span>            : {
<span class="lineNum">     786 </span>            :   WORD *split_point;
<span class="lineNum">     787 </span>            :   WORD *w;
<span class="lineNum">     788 </span>            :   int shift;
<span class="lineNum">     789 </span>            :   COST best_break;
<span class="lineNum">     790 </span>            : 
<span class="lineNum">     791 </span>            :   /* In the special case where it's all one word, just flush it.  */
<span class="lineNum">     792 </span>            : 
<span class="lineNum">     793 </span><span class="lineNoCov">          0 :   if (word_limit == word)</span>
<span class="lineNum">     794 </span>            :     {
<span class="lineNum">     795 </span><span class="lineNoCov">          0 :       fwrite (parabuf, sizeof *parabuf, wptr - parabuf, stdout);</span>
<span class="lineNum">     796 </span><span class="lineNoCov">          0 :       wptr = parabuf;</span>
<span class="lineNum">     797 </span><span class="lineNoCov">          0 :       return;</span>
<span class="lineNum">     798 </span>            :     }
<span class="lineNum">     799 </span>            : 
<span class="lineNum">     800 </span>            :   /* Otherwise:
<span class="lineNum">     801 </span>            :      - format what you have so far as a paragraph,
<span class="lineNum">     802 </span>            :      - find a low-cost line break near the end,
<span class="lineNum">     803 </span>            :      - output to there,
<span class="lineNum">     804 </span>            :      - make that the start of the paragraph.  */
<span class="lineNum">     805 </span>            : 
<span class="lineNum">     806 </span><span class="lineNoCov">          0 :   fmt_paragraph ();</span>
<span class="lineNum">     807 </span>            : 
<span class="lineNum">     808 </span>            :   /* Choose a good split point.  */
<span class="lineNum">     809 </span>            : 
<span class="lineNum">     810 </span><span class="lineNoCov">          0 :   split_point = word_limit;</span>
<span class="lineNum">     811 </span><span class="lineNoCov">          0 :   best_break = MAXCOST;</span>
<span class="lineNum">     812 </span><span class="lineNoCov">          0 :   for (w = word-&gt;next_break; w != word_limit; w = w-&gt;next_break)</span>
<span class="lineNum">     813 </span>            :     {
<span class="lineNum">     814 </span><span class="lineNoCov">          0 :       if (w-&gt;best_cost - w-&gt;next_break-&gt;best_cost &lt; best_break)</span>
<span class="lineNum">     815 </span>            :         {
<span class="lineNum">     816 </span><span class="lineNoCov">          0 :           split_point = w;</span>
<span class="lineNum">     817 </span><span class="lineNoCov">          0 :           best_break = w-&gt;best_cost - w-&gt;next_break-&gt;best_cost;</span>
<span class="lineNum">     818 </span>            :         }
<span class="lineNum">     819 </span><span class="lineNoCov">          0 :       if (best_break &lt;= MAXCOST - LINE_CREDIT)</span>
<span class="lineNum">     820 </span><span class="lineNoCov">          0 :         best_break += LINE_CREDIT;</span>
<span class="lineNum">     821 </span>            :     }
<span class="lineNum">     822 </span><span class="lineNoCov">          0 :   put_paragraph (split_point);</span>
<span class="lineNum">     823 </span>            : 
<span class="lineNum">     824 </span>            :   /* Copy text of words down to start of parabuf -- we use memmove because
<span class="lineNum">     825 </span>            :      the source and target may overlap.  */
<span class="lineNum">     826 </span>            : 
<span class="lineNum">     827 </span><span class="lineNoCov">          0 :   memmove (parabuf, split_point-&gt;text, wptr - split_point-&gt;text);</span>
<span class="lineNum">     828 </span><span class="lineNoCov">          0 :   shift = split_point-&gt;text - parabuf;</span>
<span class="lineNum">     829 </span><span class="lineNoCov">          0 :   wptr -= shift;</span>
<span class="lineNum">     830 </span>            : 
<span class="lineNum">     831 </span>            :   /* Adjust text pointers.  */
<span class="lineNum">     832 </span>            : 
<span class="lineNum">     833 </span><span class="lineNoCov">          0 :   for (w = split_point; w &lt;= word_limit; w++)</span>
<span class="lineNum">     834 </span><span class="lineNoCov">          0 :     w-&gt;text -= shift;</span>
<span class="lineNum">     835 </span>            : 
<span class="lineNum">     836 </span>            :   /* Copy words from split_point down to word -- we use memmove because
<span class="lineNum">     837 </span>            :      the source and target may overlap.  */
<span class="lineNum">     838 </span>            : 
<span class="lineNum">     839 </span><span class="lineNoCov">          0 :   memmove (word, split_point, (word_limit - split_point + 1) * sizeof *word);</span>
<span class="lineNum">     840 </span><span class="lineNoCov">          0 :   word_limit -= split_point - word;</span>
<span class="lineNum">     841 </span>            : }
<span class="lineNum">     842 </span>            : 
<span class="lineNum">     843 </span>            : /* Compute the optimal formatting for the whole paragraph by computing
<span class="lineNum">     844 </span>            :    and remembering the optimal formatting for each suffix from the empty
<span class="lineNum">     845 </span>            :    one to the whole paragraph.  */
<a name="846"><span class="lineNum">     846 </span>            : </a>
<span class="lineNum">     847 </span>            : static void
<span class="lineNum">     848 </span><span class="lineNoCov">          0 : fmt_paragraph (void)</span>
<span class="lineNum">     849 </span>            : {
<span class="lineNum">     850 </span>            :   WORD *start, *w;
<span class="lineNum">     851 </span>            :   int len;
<span class="lineNum">     852 </span>            :   COST wcost, best;
<span class="lineNum">     853 </span>            :   int saved_length;
<span class="lineNum">     854 </span>            : 
<span class="lineNum">     855 </span><span class="lineNoCov">          0 :   word_limit-&gt;best_cost = 0;</span>
<span class="lineNum">     856 </span><span class="lineNoCov">          0 :   saved_length = word_limit-&gt;length;</span>
<span class="lineNum">     857 </span><span class="lineNoCov">          0 :   word_limit-&gt;length = max_width;    /* sentinel */</span>
<span class="lineNum">     858 </span>            : 
<span class="lineNum">     859 </span><span class="lineNoCov">          0 :   for (start = word_limit - 1; start &gt;= word; start--)</span>
<span class="lineNum">     860 </span>            :     {
<span class="lineNum">     861 </span><span class="lineNoCov">          0 :       best = MAXCOST;</span>
<span class="lineNum">     862 </span><span class="lineNoCov">          0 :       len = start == word ? first_indent : other_indent;</span>
<span class="lineNum">     863 </span>            : 
<span class="lineNum">     864 </span>            :       /* At least one word, however long, in the line.  */
<span class="lineNum">     865 </span>            : 
<span class="lineNum">     866 </span><span class="lineNoCov">          0 :       w = start;</span>
<span class="lineNum">     867 </span><span class="lineNoCov">          0 :       len += w-&gt;length;</span>
<span class="lineNum">     868 </span>            :       do
<span class="lineNum">     869 </span>            :         {
<span class="lineNum">     870 </span><span class="lineNoCov">          0 :           w++;</span>
<span class="lineNum">     871 </span>            : 
<span class="lineNum">     872 </span>            :           /* Consider breaking before w.  */
<span class="lineNum">     873 </span>            : 
<span class="lineNum">     874 </span><span class="lineNoCov">          0 :           wcost = line_cost (w, len) + w-&gt;best_cost;</span>
<span class="lineNum">     875 </span><span class="lineNoCov">          0 :           if (start == word &amp;&amp; last_line_length &gt; 0)</span>
<span class="lineNum">     876 </span><span class="lineNoCov">          0 :             wcost += RAGGED_COST (len - last_line_length);</span>
<span class="lineNum">     877 </span><span class="lineNoCov">          0 :           if (wcost &lt; best)</span>
<span class="lineNum">     878 </span>            :             {
<span class="lineNum">     879 </span><span class="lineNoCov">          0 :               best = wcost;</span>
<span class="lineNum">     880 </span><span class="lineNoCov">          0 :               start-&gt;next_break = w;</span>
<span class="lineNum">     881 </span><span class="lineNoCov">          0 :               start-&gt;line_length = len;</span>
<span class="lineNum">     882 </span>            :             }
<span class="lineNum">     883 </span>            : 
<span class="lineNum">     884 </span>            :           /* This is a kludge to keep us from computing 'len' as the
<span class="lineNum">     885 </span>            :              sum of the sentinel length and some non-zero number.
<span class="lineNum">     886 </span>            :              Since the sentinel w-&gt;length may be INT_MAX, adding
<span class="lineNum">     887 </span>            :              to that would give a negative result.  */
<span class="lineNum">     888 </span><span class="lineNoCov">          0 :           if (w == word_limit)</span>
<span class="lineNum">     889 </span>            :             break;
<span class="lineNum">     890 </span>            : 
<span class="lineNum">     891 </span><span class="lineNoCov">          0 :           len += (w - 1)-&gt;space + w-&gt;length;      /* w &gt; start &gt;= word */</span>
<span class="lineNum">     892 </span>            :         }
<span class="lineNum">     893 </span><span class="lineNoCov">          0 :       while (len &lt; max_width);</span>
<span class="lineNum">     894 </span><span class="lineNoCov">          0 :       start-&gt;best_cost = best + base_cost (start);</span>
<span class="lineNum">     895 </span>            :     }
<span class="lineNum">     896 </span>            : 
<span class="lineNum">     897 </span><span class="lineNoCov">          0 :   word_limit-&gt;length = saved_length;</span>
<span class="lineNum">     898 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     899 </span>            : 
<span class="lineNum">     900 </span>            : /* Return the constant component of the cost of breaking before the
<span class="lineNum">     901 </span>            :    word THIS.  */
<a name="902"><span class="lineNum">     902 </span>            : </a>
<span class="lineNum">     903 </span>            : static COST
<span class="lineNum">     904 </span><span class="lineNoCov">          0 : base_cost (WORD *this)</span>
<span class="lineNum">     905 </span>            : {
<span class="lineNum">     906 </span>            :   COST cost;
<span class="lineNum">     907 </span>            : 
<span class="lineNum">     908 </span><span class="lineNoCov">          0 :   cost = LINE_COST;</span>
<span class="lineNum">     909 </span>            : 
<span class="lineNum">     910 </span><span class="lineNoCov">          0 :   if (this &gt; word)</span>
<span class="lineNum">     911 </span>            :     {
<span class="lineNum">     912 </span><span class="lineNoCov">          0 :       if ((this - 1)-&gt;period)</span>
<span class="lineNum">     913 </span>            :         {
<span class="lineNum">     914 </span><span class="lineNoCov">          0 :           if ((this - 1)-&gt;final)</span>
<span class="lineNum">     915 </span>            :             cost -= SENTENCE_BONUS;
<span class="lineNum">     916 </span>            :           else
<span class="lineNum">     917 </span><span class="lineNoCov">          0 :             cost += NOBREAK_COST;</span>
<span class="lineNum">     918 </span>            :         }
<span class="lineNum">     919 </span><span class="lineNoCov">          0 :       else if ((this - 1)-&gt;punct)</span>
<span class="lineNum">     920 </span>            :         cost -= PUNCT_BONUS;
<span class="lineNum">     921 </span><span class="lineNoCov">          0 :       else if (this &gt; word + 1 &amp;&amp; (this - 2)-&gt;final)</span>
<span class="lineNum">     922 </span><span class="lineNoCov">          0 :         cost += WIDOW_COST ((this - 1)-&gt;length);</span>
<span class="lineNum">     923 </span>            :     }
<span class="lineNum">     924 </span>            : 
<span class="lineNum">     925 </span><span class="lineNoCov">          0 :   if (this-&gt;paren)</span>
<span class="lineNum">     926 </span><span class="lineNoCov">          0 :     cost -= PAREN_BONUS;</span>
<span class="lineNum">     927 </span><span class="lineNoCov">          0 :   else if (this-&gt;final)</span>
<span class="lineNum">     928 </span><span class="lineNoCov">          0 :     cost += ORPHAN_COST (this-&gt;length);</span>
<span class="lineNum">     929 </span>            : 
<span class="lineNum">     930 </span><span class="lineNoCov">          0 :   return cost;</span>
<span class="lineNum">     931 </span>            : }
<span class="lineNum">     932 </span>            : 
<span class="lineNum">     933 </span>            : /* Return the component of the cost of breaking before word NEXT that
<span class="lineNum">     934 </span>            :    depends on LEN, the length of the line beginning there.  */
<span class="lineNum">     935 </span>            : 
<span class="lineNum">     936 </span>            : static COST
<span class="lineNum">     937 </span>            : line_cost (WORD *next, int len)
<span class="lineNum">     938 </span>            : {
<span class="lineNum">     939 </span>            :   int n;
<span class="lineNum">     940 </span>            :   COST cost;
<span class="lineNum">     941 </span>            : 
<span class="lineNum">     942 </span><span class="lineNoCov">          0 :   if (next == word_limit)</span>
<span class="lineNum">     943 </span>            :     return 0;
<span class="lineNum">     944 </span><span class="lineNoCov">          0 :   n = goal_width - len;</span>
<span class="lineNum">     945 </span><span class="lineNoCov">          0 :   cost = SHORT_COST (n);</span>
<span class="lineNum">     946 </span><span class="lineNoCov">          0 :   if (next-&gt;next_break != word_limit)</span>
<span class="lineNum">     947 </span>            :     {
<span class="lineNum">     948 </span><span class="lineNoCov">          0 :       n = len - next-&gt;line_length;</span>
<span class="lineNum">     949 </span><span class="lineNoCov">          0 :       cost += RAGGED_COST (n);</span>
<span class="lineNum">     950 </span>            :     }
<span class="lineNum">     951 </span>            :   return cost;
<span class="lineNum">     952 </span>            : }
<span class="lineNum">     953 </span>            : 
<span class="lineNum">     954 </span>            : /* Output to stdout a paragraph from word up to (but not including)
<span class="lineNum">     955 </span>            :    FINISH, which must be in the next_break chain from word.  */
<a name="956"><span class="lineNum">     956 </span>            : </a>
<span class="lineNum">     957 </span>            : static void
<span class="lineNum">     958 </span><span class="lineNoCov">          0 : put_paragraph (WORD *finish)</span>
<span class="lineNum">     959 </span>            : {
<span class="lineNum">     960 </span>            :   WORD *w;
<span class="lineNum">     961 </span>            : 
<span class="lineNum">     962 </span><span class="lineNoCov">          0 :   put_line (word, first_indent);</span>
<span class="lineNum">     963 </span><span class="lineNoCov">          0 :   for (w = word-&gt;next_break; w != finish; w = w-&gt;next_break)</span>
<span class="lineNum">     964 </span><span class="lineNoCov">          0 :     put_line (w, other_indent);</span>
<span class="lineNum">     965 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     966 </span>            : 
<span class="lineNum">     967 </span>            : /* Output to stdout the line beginning with word W, beginning in column
<span class="lineNum">     968 </span>            :    INDENT, including the prefix (if any).  */
<a name="969"><span class="lineNum">     969 </span>            : </a>
<span class="lineNum">     970 </span>            : static void
<span class="lineNum">     971 </span><span class="lineNoCov">          0 : put_line (WORD *w, int indent)</span>
<span class="lineNum">     972 </span>            : {
<span class="lineNum">     973 </span>            :   WORD *endline;
<span class="lineNum">     974 </span>            : 
<span class="lineNum">     975 </span><span class="lineNoCov">          0 :   out_column = 0;</span>
<span class="lineNum">     976 </span><span class="lineNoCov">          0 :   put_space (prefix_indent);</span>
<span class="lineNum">     977 </span><span class="lineNoCov">          0 :   fputs (prefix, stdout);</span>
<span class="lineNum">     978 </span><span class="lineNoCov">          0 :   out_column += prefix_length;</span>
<span class="lineNum">     979 </span><span class="lineNoCov">          0 :   put_space (indent - out_column);</span>
<span class="lineNum">     980 </span>            : 
<span class="lineNum">     981 </span><span class="lineNoCov">          0 :   endline = w-&gt;next_break - 1;</span>
<span class="lineNum">     982 </span><span class="lineNoCov">          0 :   for (; w != endline; w++)</span>
<span class="lineNum">     983 </span>            :     {
<span class="lineNum">     984 </span><span class="lineNoCov">          0 :       put_word (w);</span>
<span class="lineNum">     985 </span><span class="lineNoCov">          0 :       put_space (w-&gt;space);</span>
<span class="lineNum">     986 </span>            :     }
<span class="lineNum">     987 </span><span class="lineNoCov">          0 :   put_word (w);</span>
<span class="lineNum">     988 </span><span class="lineNoCov">          0 :   last_line_length = out_column;</span>
<span class="lineNum">     989 </span><span class="lineNoCov">          0 :   putchar ('\n');</span>
<span class="lineNum">     990 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     991 </span>            : 
<span class="lineNum">     992 </span>            : /* Output to stdout the word W.  */
<a name="993"><span class="lineNum">     993 </span>            : </a>
<span class="lineNum">     994 </span>            : static void
<span class="lineNum">     995 </span><span class="lineNoCov">          0 : put_word (WORD *w)</span>
<span class="lineNum">     996 </span>            : {
<span class="lineNum">     997 </span>            :   const char *s;
<span class="lineNum">     998 </span>            :   int n;
<span class="lineNum">     999 </span>            : 
<span class="lineNum">    1000 </span><span class="lineNoCov">          0 :   s = w-&gt;text;</span>
<span class="lineNum">    1001 </span><span class="lineNoCov">          0 :   for (n = w-&gt;length; n != 0; n--)</span>
<span class="lineNum">    1002 </span><span class="lineNoCov">          0 :     putchar (*s++);</span>
<span class="lineNum">    1003 </span><span class="lineNoCov">          0 :   out_column += w-&gt;length;</span>
<span class="lineNum">    1004 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    1005 </span>            : 
<span class="lineNum">    1006 </span>            : /* Output to stdout SPACE spaces, or equivalent tabs.  */
<a name="1007"><span class="lineNum">    1007 </span>            : </a>
<span class="lineNum">    1008 </span>            : static void
<span class="lineNum">    1009 </span><span class="lineNoCov">          0 : put_space (int space)</span>
<span class="lineNum">    1010 </span>            : {
<span class="lineNum">    1011 </span>            :   int space_target, tab_target;
<span class="lineNum">    1012 </span>            : 
<span class="lineNum">    1013 </span><span class="lineNoCov">          0 :   space_target = out_column + space;</span>
<span class="lineNum">    1014 </span><span class="lineNoCov">          0 :   if (tabs)</span>
<span class="lineNum">    1015 </span>            :     {
<span class="lineNum">    1016 </span><span class="lineNoCov">          0 :       tab_target = space_target / TABWIDTH * TABWIDTH;</span>
<span class="lineNum">    1017 </span><span class="lineNoCov">          0 :       if (out_column + 1 &lt; tab_target)</span>
<span class="lineNum">    1018 </span><span class="lineNoCov">          0 :         while (out_column &lt; tab_target)</span>
<span class="lineNum">    1019 </span>            :           {
<span class="lineNum">    1020 </span><span class="lineNoCov">          0 :             putchar ('\t');</span>
<span class="lineNum">    1021 </span><span class="lineNoCov">          0 :             out_column = (out_column / TABWIDTH + 1) * TABWIDTH;</span>
<span class="lineNum">    1022 </span>            :           }
<span class="lineNum">    1023 </span>            :     }
<span class="lineNum">    1024 </span><span class="lineNoCov">          0 :   while (out_column &lt; space_target)</span>
<span class="lineNum">    1025 </span>            :     {
<span class="lineNum">    1026 </span><span class="lineNoCov">          0 :       putchar (' ');</span>
<span class="lineNum">    1027 </span><span class="lineNoCov">          0 :       out_column++;</span>
<span class="lineNum">    1028 </span>            :     }
<span class="lineNum">    1029 </span><span class="lineNoCov">          0 : }</span>
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.12</a></td></tr>
  </table>
  <br>

</body>
</html>
