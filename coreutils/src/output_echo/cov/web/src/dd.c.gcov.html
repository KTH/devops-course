<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - trace.lcov_info_final - src/dd.c</title>
  <link rel="stylesheet" type="text/css" href="../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../index.html">top level</a> - <a href="index.html">src</a> - dd.c<span style="font-size: 80%;"> (source / <a href="dd.c.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">trace.lcov_info_final</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">0</td>
            <td class="headerCovTableEntry">771</td>
            <td class="headerCovTableEntryLo">0.0 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2019-04-22 20:19:38</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">0</td>
            <td class="headerCovTableEntry">34</td>
            <td class="headerCovTableEntryLo">0.0 %</td>
          </tr>
          <tr><td><img src="../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : /* dd -- convert a file while copying it.</a>
<span class="lineNum">       2 </span>            :    Copyright (C) 1985-2016 Free Software Foundation, Inc.
<span class="lineNum">       3 </span>            : 
<span class="lineNum">       4 </span>            :    This program is free software: you can redistribute it and/or modify
<span class="lineNum">       5 </span>            :    it under the terms of the GNU General Public License as published by
<span class="lineNum">       6 </span>            :    the Free Software Foundation, either version 3 of the License, or
<span class="lineNum">       7 </span>            :    (at your option) any later version.
<span class="lineNum">       8 </span>            : 
<span class="lineNum">       9 </span>            :    This program is distributed in the hope that it will be useful,
<span class="lineNum">      10 </span>            :    but WITHOUT ANY WARRANTY; without even the implied warranty of
<span class="lineNum">      11 </span>            :    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
<span class="lineNum">      12 </span>            :    GNU General Public License for more details.
<span class="lineNum">      13 </span>            : 
<span class="lineNum">      14 </span>            :    You should have received a copy of the GNU General Public License
<span class="lineNum">      15 </span>            :    along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.  */
<span class="lineNum">      16 </span>            : 
<span class="lineNum">      17 </span>            : /* Written by Paul Rubin, David MacKenzie, and Stuart Kemp. */
<span class="lineNum">      18 </span>            : 
<span class="lineNum">      19 </span>            : #include &lt;config.h&gt;
<span class="lineNum">      20 </span>            : 
<span class="lineNum">      21 </span>            : #define SWAB_ALIGN_OFFSET 2
<span class="lineNum">      22 </span>            : 
<span class="lineNum">      23 </span>            : #include &lt;sys/types.h&gt;
<span class="lineNum">      24 </span>            : #include &lt;signal.h&gt;
<span class="lineNum">      25 </span>            : #include &lt;getopt.h&gt;
<span class="lineNum">      26 </span>            : 
<span class="lineNum">      27 </span>            : #include &quot;system.h&quot;
<span class="lineNum">      28 </span>            : #include &quot;close-stream.h&quot;
<span class="lineNum">      29 </span>            : #include &quot;error.h&quot;
<span class="lineNum">      30 </span>            : #include &quot;fd-reopen.h&quot;
<span class="lineNum">      31 </span>            : #include &quot;gethrxtime.h&quot;
<span class="lineNum">      32 </span>            : #include &quot;human.h&quot;
<span class="lineNum">      33 </span>            : #include &quot;long-options.h&quot;
<span class="lineNum">      34 </span>            : #include &quot;quote.h&quot;
<span class="lineNum">      35 </span>            : #include &quot;verror.h&quot;
<span class="lineNum">      36 </span>            : #include &quot;xstrtol.h&quot;
<span class="lineNum">      37 </span>            : #include &quot;xtime.h&quot;
<span class="lineNum">      38 </span>            : 
<span class="lineNum">      39 </span>            : /* The official name of this program (e.g., no 'g' prefix).  */
<span class="lineNum">      40 </span>            : #define PROGRAM_NAME &quot;dd&quot;
<span class="lineNum">      41 </span>            : 
<span class="lineNum">      42 </span>            : #define AUTHORS \
<span class="lineNum">      43 </span>            :   proper_name (&quot;Paul Rubin&quot;), \
<span class="lineNum">      44 </span>            :   proper_name (&quot;David MacKenzie&quot;), \
<span class="lineNum">      45 </span>            :   proper_name (&quot;Stuart Kemp&quot;)
<span class="lineNum">      46 </span>            : 
<span class="lineNum">      47 </span>            : /* Use SA_NOCLDSTOP as a proxy for whether the sigaction machinery is
<span class="lineNum">      48 </span>            :    present.  */
<span class="lineNum">      49 </span>            : #ifndef SA_NOCLDSTOP
<span class="lineNum">      50 </span>            : # define SA_NOCLDSTOP 0
<span class="lineNum">      51 </span>            : # define sigprocmask(How, Set, Oset) /* empty */
<span class="lineNum">      52 </span>            : # define sigset_t int
<span class="lineNum">      53 </span>            : # if ! HAVE_SIGINTERRUPT
<span class="lineNum">      54 </span>            : #  define siginterrupt(sig, flag) /* empty */
<span class="lineNum">      55 </span>            : # endif
<span class="lineNum">      56 </span>            : #endif
<span class="lineNum">      57 </span>            : 
<span class="lineNum">      58 </span>            : /* NonStop circa 2011 lacks SA_RESETHAND; see Bug#9076.  */
<span class="lineNum">      59 </span>            : #ifndef SA_RESETHAND
<span class="lineNum">      60 </span>            : # define SA_RESETHAND 0
<span class="lineNum">      61 </span>            : #endif
<span class="lineNum">      62 </span>            : 
<span class="lineNum">      63 </span>            : #ifndef SIGINFO
<span class="lineNum">      64 </span>            : # define SIGINFO SIGUSR1
<span class="lineNum">      65 </span>            : #endif
<span class="lineNum">      66 </span>            : 
<span class="lineNum">      67 </span>            : /* This may belong in GNULIB's fcntl module instead.
<span class="lineNum">      68 </span>            :    Define O_CIO to 0 if it is not supported by this OS. */
<span class="lineNum">      69 </span>            : #ifndef O_CIO
<span class="lineNum">      70 </span>            : # define O_CIO 0
<span class="lineNum">      71 </span>            : #endif
<span class="lineNum">      72 </span>            : 
<span class="lineNum">      73 </span>            : /* On AIX 5.1 and AIX 5.2, O_NOCACHE is defined via &lt;fcntl.h&gt;
<span class="lineNum">      74 </span>            :    and would interfere with our use of that name, below.  */
<span class="lineNum">      75 </span>            : #undef O_NOCACHE
<span class="lineNum">      76 </span>            : 
<span class="lineNum">      77 </span>            : #if ! HAVE_FDATASYNC
<span class="lineNum">      78 </span>            : # define fdatasync(fd) (errno = ENOSYS, -1)
<span class="lineNum">      79 </span>            : #endif
<span class="lineNum">      80 </span>            : 
<span class="lineNum">      81 </span>            : #define output_char(c)                          \
<span class="lineNum">      82 </span>            :   do                                            \
<span class="lineNum">      83 </span>            :     {                                           \
<span class="lineNum">      84 </span>            :       obuf[oc++] = (c);                         \
<span class="lineNum">      85 </span>            :       if (oc &gt;= output_blocksize)            \
<span class="lineNum">      86 </span>            :         write_output ();                        \
<span class="lineNum">      87 </span>            :     }                                           \
<span class="lineNum">      88 </span>            :   while (0)
<span class="lineNum">      89 </span>            : 
<span class="lineNum">      90 </span>            : /* Default input and output blocksize. */
<span class="lineNum">      91 </span>            : #define DEFAULT_BLOCKSIZE 512
<span class="lineNum">      92 </span>            : 
<span class="lineNum">      93 </span>            : /* How many bytes to add to the input and output block sizes before invoking
<span class="lineNum">      94 </span>            :    malloc.  See dd_copy for details.  INPUT_BLOCK_SLOP must be no less than
<span class="lineNum">      95 </span>            :    OUTPUT_BLOCK_SLOP.  */
<span class="lineNum">      96 </span>            : #define INPUT_BLOCK_SLOP (2 * SWAB_ALIGN_OFFSET + 2 * page_size - 1)
<span class="lineNum">      97 </span>            : #define OUTPUT_BLOCK_SLOP (page_size - 1)
<span class="lineNum">      98 </span>            : 
<span class="lineNum">      99 </span>            : /* Maximum blocksize for the given SLOP.
<span class="lineNum">     100 </span>            :    Keep it smaller than SIZE_MAX - SLOP, so that we can
<span class="lineNum">     101 </span>            :    allocate buffers that size.  Keep it smaller than SSIZE_MAX, for
<span class="lineNum">     102 </span>            :    the benefit of system calls like &quot;read&quot;.  And keep it smaller than
<span class="lineNum">     103 </span>            :    OFF_T_MAX, for the benefit of the large-offset seek code.  */
<span class="lineNum">     104 </span>            : #define MAX_BLOCKSIZE(slop) MIN (SIZE_MAX - (slop), MIN (SSIZE_MAX, OFF_T_MAX))
<span class="lineNum">     105 </span>            : 
<span class="lineNum">     106 </span>            : /* Conversions bit masks. */
<span class="lineNum">     107 </span>            : enum
<span class="lineNum">     108 </span>            :   {
<span class="lineNum">     109 </span>            :     C_ASCII = 01,
<span class="lineNum">     110 </span>            : 
<span class="lineNum">     111 </span>            :     C_EBCDIC = 02,
<span class="lineNum">     112 </span>            :     C_IBM = 04,
<span class="lineNum">     113 </span>            :     C_BLOCK = 010,
<span class="lineNum">     114 </span>            :     C_UNBLOCK = 020,
<span class="lineNum">     115 </span>            :     C_LCASE = 040,
<span class="lineNum">     116 </span>            :     C_UCASE = 0100,
<span class="lineNum">     117 </span>            :     C_SWAB = 0200,
<span class="lineNum">     118 </span>            :     C_NOERROR = 0400,
<span class="lineNum">     119 </span>            :     C_NOTRUNC = 01000,
<span class="lineNum">     120 </span>            :     C_SYNC = 02000,
<span class="lineNum">     121 </span>            : 
<span class="lineNum">     122 </span>            :     /* Use separate input and output buffers, and combine partial
<span class="lineNum">     123 </span>            :        input blocks. */
<span class="lineNum">     124 </span>            :     C_TWOBUFS = 04000,
<span class="lineNum">     125 </span>            : 
<span class="lineNum">     126 </span>            :     C_NOCREAT = 010000,
<span class="lineNum">     127 </span>            :     C_EXCL = 020000,
<span class="lineNum">     128 </span>            :     C_FDATASYNC = 040000,
<span class="lineNum">     129 </span>            :     C_FSYNC = 0100000,
<span class="lineNum">     130 </span>            : 
<span class="lineNum">     131 </span>            :     C_SPARSE = 0200000
<span class="lineNum">     132 </span>            :   };
<span class="lineNum">     133 </span>            : 
<span class="lineNum">     134 </span>            : /* Status levels.  */
<span class="lineNum">     135 </span>            : enum
<span class="lineNum">     136 </span>            :   {
<span class="lineNum">     137 </span>            :     STATUS_NONE = 1,
<span class="lineNum">     138 </span>            :     STATUS_NOXFER = 2,
<span class="lineNum">     139 </span>            :     STATUS_DEFAULT = 3,
<span class="lineNum">     140 </span>            :     STATUS_PROGRESS = 4
<span class="lineNum">     141 </span>            :   };
<span class="lineNum">     142 </span>            : 
<span class="lineNum">     143 </span>            : /* The name of the input file, or NULL for the standard input. */
<span class="lineNum">     144 </span>            : static char const *input_file = NULL;
<span class="lineNum">     145 </span>            : 
<span class="lineNum">     146 </span>            : /* The name of the output file, or NULL for the standard output. */
<span class="lineNum">     147 </span>            : static char const *output_file = NULL;
<span class="lineNum">     148 </span>            : 
<span class="lineNum">     149 </span>            : /* The page size on this host.  */
<span class="lineNum">     150 </span>            : static size_t page_size;
<span class="lineNum">     151 </span>            : 
<span class="lineNum">     152 </span>            : /* The number of bytes in which atomic reads are done. */
<span class="lineNum">     153 </span>            : static size_t input_blocksize = 0;
<span class="lineNum">     154 </span>            : 
<span class="lineNum">     155 </span>            : /* The number of bytes in which atomic writes are done. */
<span class="lineNum">     156 </span>            : static size_t output_blocksize = 0;
<span class="lineNum">     157 </span>            : 
<span class="lineNum">     158 </span>            : /* Conversion buffer size, in bytes.  0 prevents conversions. */
<span class="lineNum">     159 </span>            : static size_t conversion_blocksize = 0;
<span class="lineNum">     160 </span>            : 
<span class="lineNum">     161 </span>            : /* Skip this many records of 'input_blocksize' bytes before input. */
<span class="lineNum">     162 </span>            : static uintmax_t skip_records = 0;
<span class="lineNum">     163 </span>            : 
<span class="lineNum">     164 </span>            : /* Skip this many bytes before input in addition of 'skip_records'
<span class="lineNum">     165 </span>            :    records.  */
<span class="lineNum">     166 </span>            : static size_t skip_bytes = 0;
<span class="lineNum">     167 </span>            : 
<span class="lineNum">     168 </span>            : /* Skip this many records of 'output_blocksize' bytes before output. */
<span class="lineNum">     169 </span>            : static uintmax_t seek_records = 0;
<span class="lineNum">     170 </span>            : 
<span class="lineNum">     171 </span>            : /* Skip this many bytes in addition to 'seek_records' records before
<span class="lineNum">     172 </span>            :    output.  */
<span class="lineNum">     173 </span>            : static uintmax_t seek_bytes = 0;
<span class="lineNum">     174 </span>            : 
<span class="lineNum">     175 </span>            : /* Whether the final output was done with a seek (rather than a write).  */
<span class="lineNum">     176 </span>            : static bool final_op_was_seek;
<span class="lineNum">     177 </span>            : 
<span class="lineNum">     178 </span>            : /* Copy only this many records.  The default is effectively infinity.  */
<span class="lineNum">     179 </span>            : static uintmax_t max_records = (uintmax_t) -1;
<span class="lineNum">     180 </span>            : 
<span class="lineNum">     181 </span>            : /* Copy this many bytes in addition to 'max_records' records.  */
<span class="lineNum">     182 </span>            : static size_t max_bytes = 0;
<span class="lineNum">     183 </span>            : 
<span class="lineNum">     184 </span>            : /* Bit vector of conversions to apply. */
<span class="lineNum">     185 </span>            : static int conversions_mask = 0;
<span class="lineNum">     186 </span>            : 
<span class="lineNum">     187 </span>            : /* Open flags for the input and output files.  */
<span class="lineNum">     188 </span>            : static int input_flags = 0;
<span class="lineNum">     189 </span>            : static int output_flags = 0;
<span class="lineNum">     190 </span>            : 
<span class="lineNum">     191 </span>            : /* Status flags for what is printed to stderr.  */
<span class="lineNum">     192 </span>            : static int status_level = STATUS_DEFAULT;
<span class="lineNum">     193 </span>            : 
<span class="lineNum">     194 </span>            : /* If nonzero, filter characters through the translation table.  */
<span class="lineNum">     195 </span>            : static bool translation_needed = false;
<span class="lineNum">     196 </span>            : 
<span class="lineNum">     197 </span>            : /* Number of partial blocks written. */
<span class="lineNum">     198 </span>            : static uintmax_t w_partial = 0;
<span class="lineNum">     199 </span>            : 
<span class="lineNum">     200 </span>            : /* Number of full blocks written. */
<span class="lineNum">     201 </span>            : static uintmax_t w_full = 0;
<span class="lineNum">     202 </span>            : 
<span class="lineNum">     203 </span>            : /* Number of partial blocks read. */
<span class="lineNum">     204 </span>            : static uintmax_t r_partial = 0;
<span class="lineNum">     205 </span>            : 
<span class="lineNum">     206 </span>            : /* Number of full blocks read. */
<span class="lineNum">     207 </span>            : static uintmax_t r_full = 0;
<span class="lineNum">     208 </span>            : 
<span class="lineNum">     209 </span>            : /* Number of bytes written.  */
<span class="lineNum">     210 </span>            : static uintmax_t w_bytes = 0;
<span class="lineNum">     211 </span>            : 
<span class="lineNum">     212 </span>            : /* Time that dd started.  */
<span class="lineNum">     213 </span>            : static xtime_t start_time;
<span class="lineNum">     214 </span>            : 
<span class="lineNum">     215 </span>            : /* Next time to report periodic progress.  */
<span class="lineNum">     216 </span>            : static xtime_t next_time;
<span class="lineNum">     217 </span>            : 
<span class="lineNum">     218 </span>            : /* If positive, the number of bytes output in the current progress line.  */
<span class="lineNum">     219 </span>            : static int progress_len;
<span class="lineNum">     220 </span>            : 
<span class="lineNum">     221 </span>            : /* True if input is seekable.  */
<span class="lineNum">     222 </span>            : static bool input_seekable;
<span class="lineNum">     223 </span>            : 
<span class="lineNum">     224 </span>            : /* Error number corresponding to initial attempt to lseek input.
<span class="lineNum">     225 </span>            :    If ESPIPE, do not issue any more diagnostics about it.  */
<span class="lineNum">     226 </span>            : static int input_seek_errno;
<span class="lineNum">     227 </span>            : 
<span class="lineNum">     228 </span>            : /* File offset of the input, in bytes, along with a flag recording
<span class="lineNum">     229 </span>            :    whether it overflowed.  */
<span class="lineNum">     230 </span>            : static uintmax_t input_offset;
<span class="lineNum">     231 </span>            : static bool input_offset_overflow;
<span class="lineNum">     232 </span>            : 
<span class="lineNum">     233 </span>            : /* True if a partial read should be diagnosed.  */
<span class="lineNum">     234 </span>            : static bool warn_partial_read;
<span class="lineNum">     235 </span>            : 
<span class="lineNum">     236 </span>            : /* Records truncated by conv=block. */
<span class="lineNum">     237 </span>            : static uintmax_t r_truncate = 0;
<span class="lineNum">     238 </span>            : 
<span class="lineNum">     239 </span>            : /* Output representation of newline and space characters.
<span class="lineNum">     240 </span>            :    They change if we're converting to EBCDIC.  */
<span class="lineNum">     241 </span>            : static char newline_character = '\n';
<span class="lineNum">     242 </span>            : static char space_character = ' ';
<span class="lineNum">     243 </span>            : 
<span class="lineNum">     244 </span>            : /* Input buffer. */
<span class="lineNum">     245 </span>            : static char *ibuf;
<span class="lineNum">     246 </span>            : 
<span class="lineNum">     247 </span>            : /* Output buffer. */
<span class="lineNum">     248 </span>            : static char *obuf;
<span class="lineNum">     249 </span>            : 
<span class="lineNum">     250 </span>            : /* Current index into 'obuf'. */
<span class="lineNum">     251 </span>            : static size_t oc = 0;
<span class="lineNum">     252 </span>            : 
<span class="lineNum">     253 </span>            : /* Index into current line, for 'conv=block' and 'conv=unblock'.  */
<span class="lineNum">     254 </span>            : static size_t col = 0;
<span class="lineNum">     255 </span>            : 
<span class="lineNum">     256 </span>            : /* The set of signals that are caught.  */
<span class="lineNum">     257 </span>            : static sigset_t caught_signals;
<span class="lineNum">     258 </span>            : 
<span class="lineNum">     259 </span>            : /* If nonzero, the value of the pending fatal signal.  */
<span class="lineNum">     260 </span>            : static sig_atomic_t volatile interrupt_signal;
<span class="lineNum">     261 </span>            : 
<span class="lineNum">     262 </span>            : /* A count of the number of pending info signals that have been received.  */
<span class="lineNum">     263 </span>            : static sig_atomic_t volatile info_signal_count;
<span class="lineNum">     264 </span>            : 
<span class="lineNum">     265 </span>            : /* Whether to discard cache for input or output.  */
<span class="lineNum">     266 </span>            : static bool i_nocache, o_nocache;
<span class="lineNum">     267 </span>            : 
<span class="lineNum">     268 </span>            : /* Function used for read (to handle iflag=fullblock parameter).  */
<span class="lineNum">     269 </span>            : static ssize_t (*iread_fnc) (int fd, char *buf, size_t size);
<span class="lineNum">     270 </span>            : 
<span class="lineNum">     271 </span>            : /* A longest symbol in the struct symbol_values tables below.  */
<span class="lineNum">     272 </span>            : #define LONGEST_SYMBOL &quot;count_bytes&quot;
<span class="lineNum">     273 </span>            : 
<span class="lineNum">     274 </span>            : /* A symbol and the corresponding integer value.  */
<span class="lineNum">     275 </span>            : struct symbol_value
<span class="lineNum">     276 </span>            : {
<span class="lineNum">     277 </span>            :   char symbol[sizeof LONGEST_SYMBOL];
<span class="lineNum">     278 </span>            :   int value;
<span class="lineNum">     279 </span>            : };
<span class="lineNum">     280 </span>            : 
<span class="lineNum">     281 </span>            : /* Conversion symbols, for conv=&quot;...&quot;.  */
<span class="lineNum">     282 </span>            : static struct symbol_value const conversions[] =
<span class="lineNum">     283 </span>            : {
<span class="lineNum">     284 </span>            :   {&quot;ascii&quot;, C_ASCII | C_UNBLOCK | C_TWOBUFS}, /* EBCDIC to ASCII. */
<span class="lineNum">     285 </span>            :   {&quot;ebcdic&quot;, C_EBCDIC | C_BLOCK | C_TWOBUFS}, /* ASCII to EBCDIC. */
<span class="lineNum">     286 </span>            :   {&quot;ibm&quot;, C_IBM | C_BLOCK | C_TWOBUFS},       /* Different ASCII to EBCDIC. */
<span class="lineNum">     287 </span>            :   {&quot;block&quot;, C_BLOCK | C_TWOBUFS},     /* Variable to fixed length records. */
<span class="lineNum">     288 </span>            :   {&quot;unblock&quot;, C_UNBLOCK | C_TWOBUFS}, /* Fixed to variable length records. */
<span class="lineNum">     289 </span>            :   {&quot;lcase&quot;, C_LCASE | C_TWOBUFS},     /* Translate upper to lower case. */
<span class="lineNum">     290 </span>            :   {&quot;ucase&quot;, C_UCASE | C_TWOBUFS},     /* Translate lower to upper case. */
<span class="lineNum">     291 </span>            :   {&quot;sparse&quot;, C_SPARSE},               /* Try to sparsely write output. */
<span class="lineNum">     292 </span>            :   {&quot;swab&quot;, C_SWAB | C_TWOBUFS},       /* Swap bytes of input. */
<span class="lineNum">     293 </span>            :   {&quot;noerror&quot;, C_NOERROR},     /* Ignore i/o errors. */
<span class="lineNum">     294 </span>            :   {&quot;nocreat&quot;, C_NOCREAT},     /* Do not create output file.  */
<span class="lineNum">     295 </span>            :   {&quot;excl&quot;, C_EXCL},           /* Fail if the output file already exists.  */
<span class="lineNum">     296 </span>            :   {&quot;notrunc&quot;, C_NOTRUNC},     /* Do not truncate output file. */
<span class="lineNum">     297 </span>            :   {&quot;sync&quot;, C_SYNC},           /* Pad input records to ibs with NULs. */
<span class="lineNum">     298 </span>            :   {&quot;fdatasync&quot;, C_FDATASYNC}, /* Synchronize output data before finishing.  */
<span class="lineNum">     299 </span>            :   {&quot;fsync&quot;, C_FSYNC},         /* Also synchronize output metadata.  */
<span class="lineNum">     300 </span>            :   {&quot;&quot;, 0}
<span class="lineNum">     301 </span>            : };
<span class="lineNum">     302 </span>            : 
<span class="lineNum">     303 </span>            : #define FFS_MASK(x) ((x) ^ ((x) &amp; ((x) - 1)))
<span class="lineNum">     304 </span>            : enum
<span class="lineNum">     305 </span>            :   {
<span class="lineNum">     306 </span>            :     /* Compute a value that's bitwise disjoint from the union
<span class="lineNum">     307 </span>            :        of all O_ values.  */
<span class="lineNum">     308 </span>            :     v = ~(0
<span class="lineNum">     309 </span>            :           | O_APPEND
<span class="lineNum">     310 </span>            :           | O_BINARY
<span class="lineNum">     311 </span>            :           | O_CIO
<span class="lineNum">     312 </span>            :           | O_DIRECT
<span class="lineNum">     313 </span>            :           | O_DIRECTORY
<span class="lineNum">     314 </span>            :           | O_DSYNC
<span class="lineNum">     315 </span>            :           | O_NOATIME
<span class="lineNum">     316 </span>            :           | O_NOCTTY
<span class="lineNum">     317 </span>            :           | O_NOFOLLOW
<span class="lineNum">     318 </span>            :           | O_NOLINKS
<span class="lineNum">     319 </span>            :           | O_NONBLOCK
<span class="lineNum">     320 </span>            :           | O_SYNC
<span class="lineNum">     321 </span>            :           | O_TEXT
<span class="lineNum">     322 </span>            :           ),
<span class="lineNum">     323 </span>            : 
<span class="lineNum">     324 </span>            :     /* Use its lowest bits for private flags.  */
<span class="lineNum">     325 </span>            :     O_FULLBLOCK = FFS_MASK (v),
<span class="lineNum">     326 </span>            :     v2 = v ^ O_FULLBLOCK,
<span class="lineNum">     327 </span>            : 
<span class="lineNum">     328 </span>            :     O_NOCACHE = FFS_MASK (v2),
<span class="lineNum">     329 </span>            :     v3 = v2 ^ O_NOCACHE,
<span class="lineNum">     330 </span>            : 
<span class="lineNum">     331 </span>            :     O_COUNT_BYTES = FFS_MASK (v3),
<span class="lineNum">     332 </span>            :     v4 = v3 ^ O_COUNT_BYTES,
<span class="lineNum">     333 </span>            : 
<span class="lineNum">     334 </span>            :     O_SKIP_BYTES = FFS_MASK (v4),
<span class="lineNum">     335 </span>            :     v5 = v4 ^ O_SKIP_BYTES,
<span class="lineNum">     336 </span>            : 
<span class="lineNum">     337 </span>            :     O_SEEK_BYTES = FFS_MASK (v5)
<span class="lineNum">     338 </span>            :   };
<span class="lineNum">     339 </span>            : 
<span class="lineNum">     340 </span>            : /* Ensure that we got something.  */
<span class="lineNum">     341 </span>            : verify (O_FULLBLOCK != 0);
<span class="lineNum">     342 </span>            : verify (O_NOCACHE != 0);
<span class="lineNum">     343 </span>            : verify (O_COUNT_BYTES != 0);
<span class="lineNum">     344 </span>            : verify (O_SKIP_BYTES != 0);
<span class="lineNum">     345 </span>            : verify (O_SEEK_BYTES != 0);
<span class="lineNum">     346 </span>            : 
<span class="lineNum">     347 </span>            : #define MULTIPLE_BITS_SET(i) (((i) &amp; ((i) - 1)) != 0)
<span class="lineNum">     348 </span>            : 
<span class="lineNum">     349 </span>            : /* Ensure that this is a single-bit value.  */
<span class="lineNum">     350 </span>            : verify ( ! MULTIPLE_BITS_SET (O_FULLBLOCK));
<span class="lineNum">     351 </span>            : verify ( ! MULTIPLE_BITS_SET (O_NOCACHE));
<span class="lineNum">     352 </span>            : verify ( ! MULTIPLE_BITS_SET (O_COUNT_BYTES));
<span class="lineNum">     353 </span>            : verify ( ! MULTIPLE_BITS_SET (O_SKIP_BYTES));
<span class="lineNum">     354 </span>            : verify ( ! MULTIPLE_BITS_SET (O_SEEK_BYTES));
<span class="lineNum">     355 </span>            : 
<span class="lineNum">     356 </span>            : /* Flags, for iflag=&quot;...&quot; and oflag=&quot;...&quot;.  */
<span class="lineNum">     357 </span>            : static struct symbol_value const flags[] =
<span class="lineNum">     358 </span>            : {
<span class="lineNum">     359 </span>            :   {&quot;append&quot;,    O_APPEND},
<span class="lineNum">     360 </span>            :   {&quot;binary&quot;,    O_BINARY},
<span class="lineNum">     361 </span>            :   {&quot;cio&quot;,       O_CIO},
<span class="lineNum">     362 </span>            :   {&quot;direct&quot;,    O_DIRECT},
<span class="lineNum">     363 </span>            :   {&quot;directory&quot;,   O_DIRECTORY},
<span class="lineNum">     364 </span>            :   {&quot;dsync&quot;,     O_DSYNC},
<span class="lineNum">     365 </span>            :   {&quot;noatime&quot;,   O_NOATIME},
<span class="lineNum">     366 </span>            :   {&quot;nocache&quot;,   O_NOCACHE},   /* Discard cache.  */
<span class="lineNum">     367 </span>            :   {&quot;noctty&quot;,    O_NOCTTY},
<span class="lineNum">     368 </span>            :   {&quot;nofollow&quot;,          HAVE_WORKING_O_NOFOLLOW ? O_NOFOLLOW : 0},
<span class="lineNum">     369 </span>            :   {&quot;nolinks&quot;,   O_NOLINKS},
<span class="lineNum">     370 </span>            :   {&quot;nonblock&quot;,          O_NONBLOCK},
<span class="lineNum">     371 </span>            :   {&quot;sync&quot;,      O_SYNC},
<span class="lineNum">     372 </span>            :   {&quot;text&quot;,      O_TEXT},
<span class="lineNum">     373 </span>            :   {&quot;fullblock&quot;,   O_FULLBLOCK}, /* Accumulate full blocks from input.  */
<span class="lineNum">     374 </span>            :   {&quot;count_bytes&quot;, O_COUNT_BYTES},
<span class="lineNum">     375 </span>            :   {&quot;skip_bytes&quot;,  O_SKIP_BYTES},
<span class="lineNum">     376 </span>            :   {&quot;seek_bytes&quot;,  O_SEEK_BYTES},
<span class="lineNum">     377 </span>            :   {&quot;&quot;,                0}
<span class="lineNum">     378 </span>            : };
<span class="lineNum">     379 </span>            : 
<span class="lineNum">     380 </span>            : /* Status, for status=&quot;...&quot;.  */
<span class="lineNum">     381 </span>            : static struct symbol_value const statuses[] =
<span class="lineNum">     382 </span>            : {
<span class="lineNum">     383 </span>            :   {&quot;none&quot;,    STATUS_NONE},
<span class="lineNum">     384 </span>            :   {&quot;noxfer&quot;,  STATUS_NOXFER},
<span class="lineNum">     385 </span>            :   {&quot;progress&quot;,        STATUS_PROGRESS},
<span class="lineNum">     386 </span>            :   {&quot;&quot;,                0}
<span class="lineNum">     387 </span>            : };
<span class="lineNum">     388 </span>            : 
<span class="lineNum">     389 </span>            : /* Translation table formed by applying successive transformations. */
<span class="lineNum">     390 </span>            : static unsigned char trans_table[256];
<span class="lineNum">     391 </span>            : 
<span class="lineNum">     392 </span>            : /* Standard translation tables, taken from POSIX 1003.1-2013.
<span class="lineNum">     393 </span>            :    Beware of imitations; there are lots of ASCII&lt;-&gt;EBCDIC tables
<span class="lineNum">     394 </span>            :    floating around the net, perhaps valid for some applications but
<span class="lineNum">     395 </span>            :    not correct here.  */
<span class="lineNum">     396 </span>            : 
<span class="lineNum">     397 </span>            : static char const ascii_to_ebcdic[] =
<span class="lineNum">     398 </span>            : {
<span class="lineNum">     399 </span>            :   '\000', '\001', '\002', '\003', '\067', '\055', '\056', '\057',
<span class="lineNum">     400 </span>            :   '\026', '\005', '\045', '\013', '\014', '\015', '\016', '\017',
<span class="lineNum">     401 </span>            :   '\020', '\021', '\022', '\023', '\074', '\075', '\062', '\046',
<span class="lineNum">     402 </span>            :   '\030', '\031', '\077', '\047', '\034', '\035', '\036', '\037',
<span class="lineNum">     403 </span>            :   '\100', '\132', '\177', '\173', '\133', '\154', '\120', '\175',
<span class="lineNum">     404 </span>            :   '\115', '\135', '\134', '\116', '\153', '\140', '\113', '\141',
<span class="lineNum">     405 </span>            :   '\360', '\361', '\362', '\363', '\364', '\365', '\366', '\367',
<span class="lineNum">     406 </span>            :   '\370', '\371', '\172', '\136', '\114', '\176', '\156', '\157',
<span class="lineNum">     407 </span>            :   '\174', '\301', '\302', '\303', '\304', '\305', '\306', '\307',
<span class="lineNum">     408 </span>            :   '\310', '\311', '\321', '\322', '\323', '\324', '\325', '\326',
<span class="lineNum">     409 </span>            :   '\327', '\330', '\331', '\342', '\343', '\344', '\345', '\346',
<span class="lineNum">     410 </span>            :   '\347', '\350', '\351', '\255', '\340', '\275', '\232', '\155',
<span class="lineNum">     411 </span>            :   '\171', '\201', '\202', '\203', '\204', '\205', '\206', '\207',
<span class="lineNum">     412 </span>            :   '\210', '\211', '\221', '\222', '\223', '\224', '\225', '\226',
<span class="lineNum">     413 </span>            :   '\227', '\230', '\231', '\242', '\243', '\244', '\245', '\246',
<span class="lineNum">     414 </span>            :   '\247', '\250', '\251', '\300', '\117', '\320', '\137', '\007',
<span class="lineNum">     415 </span>            :   '\040', '\041', '\042', '\043', '\044', '\025', '\006', '\027',
<span class="lineNum">     416 </span>            :   '\050', '\051', '\052', '\053', '\054', '\011', '\012', '\033',
<span class="lineNum">     417 </span>            :   '\060', '\061', '\032', '\063', '\064', '\065', '\066', '\010',
<span class="lineNum">     418 </span>            :   '\070', '\071', '\072', '\073', '\004', '\024', '\076', '\341',
<span class="lineNum">     419 </span>            :   '\101', '\102', '\103', '\104', '\105', '\106', '\107', '\110',
<span class="lineNum">     420 </span>            :   '\111', '\121', '\122', '\123', '\124', '\125', '\126', '\127',
<span class="lineNum">     421 </span>            :   '\130', '\131', '\142', '\143', '\144', '\145', '\146', '\147',
<span class="lineNum">     422 </span>            :   '\150', '\151', '\160', '\161', '\162', '\163', '\164', '\165',
<span class="lineNum">     423 </span>            :   '\166', '\167', '\170', '\200', '\212', '\213', '\214', '\215',
<span class="lineNum">     424 </span>            :   '\216', '\217', '\220', '\152', '\233', '\234', '\235', '\236',
<span class="lineNum">     425 </span>            :   '\237', '\240', '\252', '\253', '\254', '\112', '\256', '\257',
<span class="lineNum">     426 </span>            :   '\260', '\261', '\262', '\263', '\264', '\265', '\266', '\267',
<span class="lineNum">     427 </span>            :   '\270', '\271', '\272', '\273', '\274', '\241', '\276', '\277',
<span class="lineNum">     428 </span>            :   '\312', '\313', '\314', '\315', '\316', '\317', '\332', '\333',
<span class="lineNum">     429 </span>            :   '\334', '\335', '\336', '\337', '\352', '\353', '\354', '\355',
<span class="lineNum">     430 </span>            :   '\356', '\357', '\372', '\373', '\374', '\375', '\376', '\377'
<span class="lineNum">     431 </span>            : };
<span class="lineNum">     432 </span>            : 
<span class="lineNum">     433 </span>            : static char const ascii_to_ibm[] =
<span class="lineNum">     434 </span>            : {
<span class="lineNum">     435 </span>            :   '\000', '\001', '\002', '\003', '\067', '\055', '\056', '\057',
<span class="lineNum">     436 </span>            :   '\026', '\005', '\045', '\013', '\014', '\015', '\016', '\017',
<span class="lineNum">     437 </span>            :   '\020', '\021', '\022', '\023', '\074', '\075', '\062', '\046',
<span class="lineNum">     438 </span>            :   '\030', '\031', '\077', '\047', '\034', '\035', '\036', '\037',
<span class="lineNum">     439 </span>            :   '\100', '\132', '\177', '\173', '\133', '\154', '\120', '\175',
<span class="lineNum">     440 </span>            :   '\115', '\135', '\134', '\116', '\153', '\140', '\113', '\141',
<span class="lineNum">     441 </span>            :   '\360', '\361', '\362', '\363', '\364', '\365', '\366', '\367',
<span class="lineNum">     442 </span>            :   '\370', '\371', '\172', '\136', '\114', '\176', '\156', '\157',
<span class="lineNum">     443 </span>            :   '\174', '\301', '\302', '\303', '\304', '\305', '\306', '\307',
<span class="lineNum">     444 </span>            :   '\310', '\311', '\321', '\322', '\323', '\324', '\325', '\326',
<span class="lineNum">     445 </span>            :   '\327', '\330', '\331', '\342', '\343', '\344', '\345', '\346',
<span class="lineNum">     446 </span>            :   '\347', '\350', '\351', '\255', '\340', '\275', '\137', '\155',
<span class="lineNum">     447 </span>            :   '\171', '\201', '\202', '\203', '\204', '\205', '\206', '\207',
<span class="lineNum">     448 </span>            :   '\210', '\211', '\221', '\222', '\223', '\224', '\225', '\226',
<span class="lineNum">     449 </span>            :   '\227', '\230', '\231', '\242', '\243', '\244', '\245', '\246',
<span class="lineNum">     450 </span>            :   '\247', '\250', '\251', '\300', '\117', '\320', '\241', '\007',
<span class="lineNum">     451 </span>            :   '\040', '\041', '\042', '\043', '\044', '\025', '\006', '\027',
<span class="lineNum">     452 </span>            :   '\050', '\051', '\052', '\053', '\054', '\011', '\012', '\033',
<span class="lineNum">     453 </span>            :   '\060', '\061', '\032', '\063', '\064', '\065', '\066', '\010',
<span class="lineNum">     454 </span>            :   '\070', '\071', '\072', '\073', '\004', '\024', '\076', '\341',
<span class="lineNum">     455 </span>            :   '\101', '\102', '\103', '\104', '\105', '\106', '\107', '\110',
<span class="lineNum">     456 </span>            :   '\111', '\121', '\122', '\123', '\124', '\125', '\126', '\127',
<span class="lineNum">     457 </span>            :   '\130', '\131', '\142', '\143', '\144', '\145', '\146', '\147',
<span class="lineNum">     458 </span>            :   '\150', '\151', '\160', '\161', '\162', '\163', '\164', '\165',
<span class="lineNum">     459 </span>            :   '\166', '\167', '\170', '\200', '\212', '\213', '\214', '\215',
<span class="lineNum">     460 </span>            :   '\216', '\217', '\220', '\232', '\233', '\234', '\235', '\236',
<span class="lineNum">     461 </span>            :   '\237', '\240', '\252', '\253', '\254', '\255', '\256', '\257',
<span class="lineNum">     462 </span>            :   '\260', '\261', '\262', '\263', '\264', '\265', '\266', '\267',
<span class="lineNum">     463 </span>            :   '\270', '\271', '\272', '\273', '\274', '\275', '\276', '\277',
<span class="lineNum">     464 </span>            :   '\312', '\313', '\314', '\315', '\316', '\317', '\332', '\333',
<span class="lineNum">     465 </span>            :   '\334', '\335', '\336', '\337', '\352', '\353', '\354', '\355',
<span class="lineNum">     466 </span>            :   '\356', '\357', '\372', '\373', '\374', '\375', '\376', '\377'
<span class="lineNum">     467 </span>            : };
<span class="lineNum">     468 </span>            : 
<span class="lineNum">     469 </span>            : static char const ebcdic_to_ascii[] =
<span class="lineNum">     470 </span>            : {
<span class="lineNum">     471 </span>            :   '\000', '\001', '\002', '\003', '\234', '\011', '\206', '\177',
<span class="lineNum">     472 </span>            :   '\227', '\215', '\216', '\013', '\014', '\015', '\016', '\017',
<span class="lineNum">     473 </span>            :   '\020', '\021', '\022', '\023', '\235', '\205', '\010', '\207',
<span class="lineNum">     474 </span>            :   '\030', '\031', '\222', '\217', '\034', '\035', '\036', '\037',
<span class="lineNum">     475 </span>            :   '\200', '\201', '\202', '\203', '\204', '\012', '\027', '\033',
<span class="lineNum">     476 </span>            :   '\210', '\211', '\212', '\213', '\214', '\005', '\006', '\007',
<span class="lineNum">     477 </span>            :   '\220', '\221', '\026', '\223', '\224', '\225', '\226', '\004',
<span class="lineNum">     478 </span>            :   '\230', '\231', '\232', '\233', '\024', '\025', '\236', '\032',
<span class="lineNum">     479 </span>            :   '\040', '\240', '\241', '\242', '\243', '\244', '\245', '\246',
<span class="lineNum">     480 </span>            :   '\247', '\250', '\325', '\056', '\074', '\050', '\053', '\174',
<span class="lineNum">     481 </span>            :   '\046', '\251', '\252', '\253', '\254', '\255', '\256', '\257',
<span class="lineNum">     482 </span>            :   '\260', '\261', '\041', '\044', '\052', '\051', '\073', '\176',
<span class="lineNum">     483 </span>            :   '\055', '\057', '\262', '\263', '\264', '\265', '\266', '\267',
<span class="lineNum">     484 </span>            :   '\270', '\271', '\313', '\054', '\045', '\137', '\076', '\077',
<span class="lineNum">     485 </span>            :   '\272', '\273', '\274', '\275', '\276', '\277', '\300', '\301',
<span class="lineNum">     486 </span>            :   '\302', '\140', '\072', '\043', '\100', '\047', '\075', '\042',
<span class="lineNum">     487 </span>            :   '\303', '\141', '\142', '\143', '\144', '\145', '\146', '\147',
<span class="lineNum">     488 </span>            :   '\150', '\151', '\304', '\305', '\306', '\307', '\310', '\311',
<span class="lineNum">     489 </span>            :   '\312', '\152', '\153', '\154', '\155', '\156', '\157', '\160',
<span class="lineNum">     490 </span>            :   '\161', '\162', '\136', '\314', '\315', '\316', '\317', '\320',
<span class="lineNum">     491 </span>            :   '\321', '\345', '\163', '\164', '\165', '\166', '\167', '\170',
<span class="lineNum">     492 </span>            :   '\171', '\172', '\322', '\323', '\324', '\133', '\326', '\327',
<span class="lineNum">     493 </span>            :   '\330', '\331', '\332', '\333', '\334', '\335', '\336', '\337',
<span class="lineNum">     494 </span>            :   '\340', '\341', '\342', '\343', '\344', '\135', '\346', '\347',
<span class="lineNum">     495 </span>            :   '\173', '\101', '\102', '\103', '\104', '\105', '\106', '\107',
<span class="lineNum">     496 </span>            :   '\110', '\111', '\350', '\351', '\352', '\353', '\354', '\355',
<span class="lineNum">     497 </span>            :   '\175', '\112', '\113', '\114', '\115', '\116', '\117', '\120',
<span class="lineNum">     498 </span>            :   '\121', '\122', '\356', '\357', '\360', '\361', '\362', '\363',
<span class="lineNum">     499 </span>            :   '\134', '\237', '\123', '\124', '\125', '\126', '\127', '\130',
<span class="lineNum">     500 </span>            :   '\131', '\132', '\364', '\365', '\366', '\367', '\370', '\371',
<span class="lineNum">     501 </span>            :   '\060', '\061', '\062', '\063', '\064', '\065', '\066', '\067',
<span class="lineNum">     502 </span>            :   '\070', '\071', '\372', '\373', '\374', '\375', '\376', '\377'
<span class="lineNum">     503 </span>            : };
<span class="lineNum">     504 </span>            : 
<span class="lineNum">     505 </span>            : /* True if we need to close the standard output *stream*.  */
<span class="lineNum">     506 </span>            : static bool close_stdout_required = true;
<span class="lineNum">     507 </span>            : 
<span class="lineNum">     508 </span>            : /* The only reason to close the standard output *stream* is if
<span class="lineNum">     509 </span>            :    parse_long_options fails (as it does for --help or --version).
<span class="lineNum">     510 </span>            :    In any other case, dd uses only the STDOUT_FILENO file descriptor,
<span class="lineNum">     511 </span>            :    and the &quot;cleanup&quot; function calls &quot;close (STDOUT_FILENO)&quot;.
<span class="lineNum">     512 </span>            :    Closing the file descriptor and then letting the usual atexit-run
<span class="lineNum">     513 </span>            :    close_stdout function call &quot;fclose (stdout)&quot; would result in a
<span class="lineNum">     514 </span>            :    harmless failure of the close syscall (with errno EBADF).
<span class="lineNum">     515 </span>            :    This function serves solely to avoid the unnecessary close_stdout
<span class="lineNum">     516 </span>            :    call, once parse_long_options has succeeded.
<span class="lineNum">     517 </span>            :    Meanwhile, we guarantee that the standard error stream is flushed,
<a name="518"><span class="lineNum">     518 </span>            :    by inlining the last half of close_stdout as needed.  */</a>
<span class="lineNum">     519 </span>            : static void
<span class="lineNum">     520 </span><span class="lineNoCov">          0 : maybe_close_stdout (void)</span>
<span class="lineNum">     521 </span>            : {
<span class="lineNum">     522 </span><span class="lineNoCov">          0 :   if (close_stdout_required)</span>
<span class="lineNum">     523 </span><span class="lineNoCov">          0 :     close_stdout ();</span>
<span class="lineNum">     524 </span><span class="lineNoCov">          0 :   else if (close_stream (stderr) != 0)</span>
<span class="lineNum">     525 </span><span class="lineNoCov">          0 :     _exit (EXIT_FAILURE);</span>
<span class="lineNum">     526 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     527 </span>            : 
<span class="lineNum">     528 </span>            : /* Like error() but handle any pending newline.  */
<a name="529"><span class="lineNum">     529 </span>            : </a>
<span class="lineNum">     530 </span>            : static void _GL_ATTRIBUTE_FORMAT ((__printf__, 3, 4))
<span class="lineNum">     531 </span><span class="lineNoCov">          0 : nl_error (int status, int errnum, const char *fmt, ...)</span>
<span class="lineNum">     532 </span>            : {
<span class="lineNum">     533 </span><span class="lineNoCov">          0 :   if (0 &lt; progress_len)</span>
<span class="lineNum">     534 </span>            :     {
<span class="lineNum">     535 </span><span class="lineNoCov">          0 :       fputc ('\n', stderr);</span>
<span class="lineNum">     536 </span><span class="lineNoCov">          0 :       progress_len = 0;</span>
<span class="lineNum">     537 </span>            :     }
<span class="lineNum">     538 </span>            : 
<span class="lineNum">     539 </span>            :   va_list ap;
<span class="lineNum">     540 </span><span class="lineNoCov">          0 :   va_start (ap, fmt);</span>
<span class="lineNum">     541 </span><span class="lineNoCov">          0 :   verror (status, errnum, fmt, ap);</span>
<span class="lineNum">     542 </span><span class="lineNoCov">          0 :   va_end (ap);</span>
<span class="lineNum">     543 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     544 </span>            : 
<span class="lineNum">     545 </span>            : #define error nl_error
<a name="546"><span class="lineNum">     546 </span>            : </a>
<span class="lineNum">     547 </span>            : void
<span class="lineNum">     548 </span><span class="lineNoCov">          0 : usage (int status)</span>
<span class="lineNum">     549 </span>            : {
<span class="lineNum">     550 </span><span class="lineNoCov">          0 :   if (status != EXIT_SUCCESS)</span>
<span class="lineNum">     551 </span><span class="lineNoCov">          0 :     emit_try_help ();</span>
<span class="lineNum">     552 </span>            :   else
<span class="lineNum">     553 </span>            :     {
<span class="lineNum">     554 </span><span class="lineNoCov">          0 :       printf (_(&quot;\</span>
<span class="lineNum">     555 </span>            : Usage: %s [OPERAND]...\n\
<span class="lineNum">     556 </span>            :   or:  %s OPTION\n\
<span class="lineNum">     557 </span>            : &quot;),
<span class="lineNum">     558 </span>            :               program_name, program_name);
<span class="lineNum">     559 </span><span class="lineNoCov">          0 :       fputs (_(&quot;\</span>
<span class="lineNum">     560 </span>            : Copy a file, converting and formatting according to the operands.\n\
<span class="lineNum">     561 </span>            : \n\
<span class="lineNum">     562 </span>            :   bs=BYTES        read and write up to BYTES bytes at a time\n\
<span class="lineNum">     563 </span>            :   cbs=BYTES       convert BYTES bytes at a time\n\
<span class="lineNum">     564 </span>            :   conv=CONVS      convert the file as per the comma separated symbol list\n\
<span class="lineNum">     565 </span>            :   count=N         copy only N input blocks\n\
<span class="lineNum">     566 </span>            :   ibs=BYTES       read up to BYTES bytes at a time (default: 512)\n\
<span class="lineNum">     567 </span>            : &quot;), stdout);
<span class="lineNum">     568 </span><span class="lineNoCov">          0 :       fputs (_(&quot;\</span>
<span class="lineNum">     569 </span>            :   if=FILE         read from FILE instead of stdin\n\
<span class="lineNum">     570 </span>            :   iflag=FLAGS     read as per the comma separated symbol list\n\
<span class="lineNum">     571 </span>            :   obs=BYTES       write BYTES bytes at a time (default: 512)\n\
<span class="lineNum">     572 </span>            :   of=FILE         write to FILE instead of stdout\n\
<span class="lineNum">     573 </span>            :   oflag=FLAGS     write as per the comma separated symbol list\n\
<span class="lineNum">     574 </span>            :   seek=N          skip N obs-sized blocks at start of output\n\
<span class="lineNum">     575 </span>            :   skip=N          skip N ibs-sized blocks at start of input\n\
<span class="lineNum">     576 </span>            :   status=LEVEL    The LEVEL of information to print to stderr;\n\
<span class="lineNum">     577 </span>            :                   'none' suppresses everything but error messages,\n\
<span class="lineNum">     578 </span>            :                   'noxfer' suppresses the final transfer statistics,\n\
<span class="lineNum">     579 </span>            :                   'progress' shows periodic transfer statistics\n\
<span class="lineNum">     580 </span>            : &quot;), stdout);
<span class="lineNum">     581 </span><span class="lineNoCov">          0 :       fputs (_(&quot;\</span>
<span class="lineNum">     582 </span>            : \n\
<span class="lineNum">     583 </span>            : N and BYTES may be followed by the following multiplicative suffixes:\n\
<span class="lineNum">     584 </span>            : c =1, w =2, b =512, kB =1000, K =1024, MB =1000*1000, M =1024*1024, xM =M\n\
<span class="lineNum">     585 </span>            : GB =1000*1000*1000, G =1024*1024*1024, and so on for T, P, E, Z, Y.\n\
<span class="lineNum">     586 </span>            : \n\
<span class="lineNum">     587 </span>            : Each CONV symbol may be:\n\
<span class="lineNum">     588 </span>            : \n\
<span class="lineNum">     589 </span>            : &quot;), stdout);
<span class="lineNum">     590 </span><span class="lineNoCov">          0 :       fputs (_(&quot;\</span>
<span class="lineNum">     591 </span>            :   ascii     from EBCDIC to ASCII\n\
<span class="lineNum">     592 </span>            :   ebcdic    from ASCII to EBCDIC\n\
<span class="lineNum">     593 </span>            :   ibm       from ASCII to alternate EBCDIC\n\
<span class="lineNum">     594 </span>            :   block     pad newline-terminated records with spaces to cbs-size\n\
<span class="lineNum">     595 </span>            :   unblock   replace trailing spaces in cbs-size records with newline\n\
<span class="lineNum">     596 </span>            :   lcase     change upper case to lower case\n\
<span class="lineNum">     597 </span>            :   ucase     change lower case to upper case\n\
<span class="lineNum">     598 </span>            :   sparse    try to seek rather than write the output for NUL input blocks\n\
<span class="lineNum">     599 </span>            :   swab      swap every pair of input bytes\n\
<span class="lineNum">     600 </span>            :   sync      pad every input block with NULs to ibs-size; when used\n\
<span class="lineNum">     601 </span>            :             with block or unblock, pad with spaces rather than NULs\n\
<span class="lineNum">     602 </span>            : &quot;), stdout);
<span class="lineNum">     603 </span><span class="lineNoCov">          0 :       fputs (_(&quot;\</span>
<span class="lineNum">     604 </span>            :   excl      fail if the output file already exists\n\
<span class="lineNum">     605 </span>            :   nocreat   do not create the output file\n\
<span class="lineNum">     606 </span>            :   notrunc   do not truncate the output file\n\
<span class="lineNum">     607 </span>            :   noerror   continue after read errors\n\
<span class="lineNum">     608 </span>            :   fdatasync  physically write output file data before finishing\n\
<span class="lineNum">     609 </span>            :   fsync     likewise, but also write metadata\n\
<span class="lineNum">     610 </span>            : &quot;), stdout);
<span class="lineNum">     611 </span><span class="lineNoCov">          0 :       fputs (_(&quot;\</span>
<span class="lineNum">     612 </span>            : \n\
<span class="lineNum">     613 </span>            : Each FLAG symbol may be:\n\
<span class="lineNum">     614 </span>            : \n\
<span class="lineNum">     615 </span>            :   append    append mode (makes sense only for output; conv=notrunc suggested)\n\
<span class="lineNum">     616 </span>            : &quot;), stdout);
<span class="lineNum">     617 </span>            :       if (O_CIO)
<span class="lineNum">     618 </span>            :         fputs (_(&quot;  cio       use concurrent I/O for data\n&quot;), stdout);
<span class="lineNum">     619 </span>            :       if (O_DIRECT)
<span class="lineNum">     620 </span><span class="lineNoCov">          0 :         fputs (_(&quot;  direct    use direct I/O for data\n&quot;), stdout);</span>
<span class="lineNum">     621 </span>            :       if (O_DIRECTORY)
<span class="lineNum">     622 </span><span class="lineNoCov">          0 :         fputs (_(&quot;  directory  fail unless a directory\n&quot;), stdout);</span>
<span class="lineNum">     623 </span>            :       if (O_DSYNC)
<span class="lineNum">     624 </span><span class="lineNoCov">          0 :         fputs (_(&quot;  dsync     use synchronized I/O for data\n&quot;), stdout);</span>
<span class="lineNum">     625 </span>            :       if (O_SYNC)
<span class="lineNum">     626 </span><span class="lineNoCov">          0 :         fputs (_(&quot;  sync      likewise, but also for metadata\n&quot;), stdout);</span>
<span class="lineNum">     627 </span><span class="lineNoCov">          0 :       fputs (_(&quot;  fullblock  accumulate full blocks of input (iflag only)\n&quot;),</span>
<span class="lineNum">     628 </span>            :              stdout);
<span class="lineNum">     629 </span>            :       if (O_NONBLOCK)
<span class="lineNum">     630 </span><span class="lineNoCov">          0 :         fputs (_(&quot;  nonblock  use non-blocking I/O\n&quot;), stdout);</span>
<span class="lineNum">     631 </span>            :       if (O_NOATIME)
<span class="lineNum">     632 </span><span class="lineNoCov">          0 :         fputs (_(&quot;  noatime   do not update access time\n&quot;), stdout);</span>
<span class="lineNum">     633 </span>            : #if HAVE_POSIX_FADVISE
<span class="lineNum">     634 </span>            :       if (O_NOCACHE)
<span class="lineNum">     635 </span><span class="lineNoCov">          0 :         fputs (_(&quot;  nocache   Request to drop cache.  See also oflag=sync\n&quot;),</span>
<span class="lineNum">     636 </span>            :                stdout);
<span class="lineNum">     637 </span>            : #endif
<span class="lineNum">     638 </span>            :       if (O_NOCTTY)
<span class="lineNum">     639 </span><span class="lineNoCov">          0 :         fputs (_(&quot;  noctty    do not assign controlling terminal from file\n&quot;),</span>
<span class="lineNum">     640 </span>            :                stdout);
<span class="lineNum">     641 </span>            :       if (HAVE_WORKING_O_NOFOLLOW)
<span class="lineNum">     642 </span><span class="lineNoCov">          0 :         fputs (_(&quot;  nofollow  do not follow symlinks\n&quot;), stdout);</span>
<span class="lineNum">     643 </span>            :       if (O_NOLINKS)
<span class="lineNum">     644 </span>            :         fputs (_(&quot;  nolinks   fail if multiply-linked\n&quot;), stdout);
<span class="lineNum">     645 </span>            :       if (O_BINARY)
<span class="lineNum">     646 </span>            :         fputs (_(&quot;  binary    use binary I/O for data\n&quot;), stdout);
<span class="lineNum">     647 </span>            :       if (O_TEXT)
<span class="lineNum">     648 </span>            :         fputs (_(&quot;  text      use text I/O for data\n&quot;), stdout);
<span class="lineNum">     649 </span>            :       if (O_COUNT_BYTES)
<span class="lineNum">     650 </span><span class="lineNoCov">          0 :         fputs (_(&quot;  count_bytes  treat 'count=N' as a byte count (iflag only)\n\</span>
<span class="lineNum">     651 </span>            : &quot;), stdout);
<span class="lineNum">     652 </span>            :       if (O_SKIP_BYTES)
<span class="lineNum">     653 </span><span class="lineNoCov">          0 :         fputs (_(&quot;  skip_bytes  treat 'skip=N' as a byte count (iflag only)\n\</span>
<span class="lineNum">     654 </span>            : &quot;), stdout);
<span class="lineNum">     655 </span>            :       if (O_SEEK_BYTES)
<span class="lineNum">     656 </span><span class="lineNoCov">          0 :         fputs (_(&quot;  seek_bytes  treat 'seek=N' as a byte count (oflag only)\n\</span>
<span class="lineNum">     657 </span>            : &quot;), stdout);
<span class="lineNum">     658 </span>            : 
<span class="lineNum">     659 </span>            :       {
<span class="lineNum">     660 </span><span class="lineNoCov">          0 :         printf (_(&quot;\</span>
<span class="lineNum">     661 </span>            : \n\
<span class="lineNum">     662 </span>            : Sending a %s signal to a running 'dd' process makes it\n\
<span class="lineNum">     663 </span>            : print I/O statistics to standard error and then resume copying.\n\
<span class="lineNum">     664 </span>            : \n\
<span class="lineNum">     665 </span>            : Options are:\n\
<span class="lineNum">     666 </span>            : \n\
<span class="lineNum">     667 </span>            : &quot;), SIGINFO == SIGUSR1 ? &quot;USR1&quot; : &quot;INFO&quot;);
<span class="lineNum">     668 </span>            :       }
<span class="lineNum">     669 </span>            : 
<span class="lineNum">     670 </span><span class="lineNoCov">          0 :       fputs (HELP_OPTION_DESCRIPTION, stdout);</span>
<span class="lineNum">     671 </span><span class="lineNoCov">          0 :       fputs (VERSION_OPTION_DESCRIPTION, stdout);</span>
<span class="lineNum">     672 </span><span class="lineNoCov">          0 :       emit_ancillary_info (PROGRAM_NAME);</span>
<span class="lineNum">     673 </span>            :     }
<span class="lineNum">     674 </span><span class="lineNoCov">          0 :   exit (status);</span>
<span class="lineNum">     675 </span>            : }
<span class="lineNum">     676 </span>            : 
<span class="lineNum">     677 </span>            : /* Common options to use when displaying sizes and rates.  */
<span class="lineNum">     678 </span>            : 
<span class="lineNum">     679 </span>            : enum { human_opts = (human_autoscale | human_round_to_nearest
<span class="lineNum">     680 </span>            :                      | human_space_before_unit | human_SI | human_B) };
<span class="lineNum">     681 </span>            : 
<span class="lineNum">     682 </span>            : /* Ensure input buffer IBUF is allocated.  */
<a name="683"><span class="lineNum">     683 </span>            : </a>
<span class="lineNum">     684 </span>            : static void
<span class="lineNum">     685 </span><span class="lineNoCov">          0 : alloc_ibuf (void)</span>
<span class="lineNum">     686 </span>            : {
<span class="lineNum">     687 </span><span class="lineNoCov">          0 :   if (ibuf)</span>
<span class="lineNum">     688 </span>            :     return;
<span class="lineNum">     689 </span>            : 
<span class="lineNum">     690 </span><span class="lineNoCov">          0 :   char *real_buf = malloc (input_blocksize + INPUT_BLOCK_SLOP);</span>
<span class="lineNum">     691 </span><span class="lineNoCov">          0 :   if (!real_buf)</span>
<span class="lineNum">     692 </span>            :     {
<span class="lineNum">     693 </span><span class="lineNoCov">          0 :       uintmax_t ibs = input_blocksize;</span>
<span class="lineNum">     694 </span>            :       char hbuf[LONGEST_HUMAN_READABLE + 1];
<span class="lineNum">     695 </span><span class="lineNoCov">          0 :       error (EXIT_FAILURE, 0,</span>
<span class="lineNum">     696 </span><span class="lineNoCov">          0 :              _(&quot;memory exhausted by input buffer of size %&quot;PRIuMAX</span>
<span class="lineNum">     697 </span>            :                &quot; bytes (%s)&quot;),
<span class="lineNum">     698 </span>            :              ibs,
<span class="lineNum">     699 </span>            :              human_readable (input_blocksize, hbuf,
<span class="lineNum">     700 </span>            :                              human_opts | human_base_1024, 1, 1));
<span class="lineNum">     701 </span>            :     }
<span class="lineNum">     702 </span>            : 
<span class="lineNum">     703 </span><span class="lineNoCov">          0 :   real_buf += SWAB_ALIGN_OFFSET;        /* allow space for swab */</span>
<span class="lineNum">     704 </span>            : 
<span class="lineNum">     705 </span><span class="lineNoCov">          0 :   ibuf = ptr_align (real_buf, page_size);</span>
<span class="lineNum">     706 </span>            : }
<span class="lineNum">     707 </span>            : 
<span class="lineNum">     708 </span>            : /* Ensure output buffer OBUF is allocated/initialized.  */
<a name="709"><span class="lineNum">     709 </span>            : </a>
<span class="lineNum">     710 </span>            : static void
<span class="lineNum">     711 </span><span class="lineNoCov">          0 : alloc_obuf (void)</span>
<span class="lineNum">     712 </span>            : {
<span class="lineNum">     713 </span><span class="lineNoCov">          0 :   if (obuf)</span>
<span class="lineNum">     714 </span>            :     return;
<span class="lineNum">     715 </span>            : 
<span class="lineNum">     716 </span><span class="lineNoCov">          0 :   if (conversions_mask &amp; C_TWOBUFS)</span>
<span class="lineNum">     717 </span>            :     {
<span class="lineNum">     718 </span>            :       /* Page-align the output buffer, too.  */
<span class="lineNum">     719 </span><span class="lineNoCov">          0 :       char *real_obuf = malloc (output_blocksize + OUTPUT_BLOCK_SLOP);</span>
<span class="lineNum">     720 </span><span class="lineNoCov">          0 :       if (!real_obuf)</span>
<span class="lineNum">     721 </span>            :         {
<span class="lineNum">     722 </span><span class="lineNoCov">          0 :           uintmax_t obs = output_blocksize;</span>
<span class="lineNum">     723 </span>            :           char hbuf[LONGEST_HUMAN_READABLE + 1];
<span class="lineNum">     724 </span><span class="lineNoCov">          0 :           error (EXIT_FAILURE, 0,</span>
<span class="lineNum">     725 </span><span class="lineNoCov">          0 :                  _(&quot;memory exhausted by output buffer of size %&quot;PRIuMAX</span>
<span class="lineNum">     726 </span>            :                    &quot; bytes (%s)&quot;),
<span class="lineNum">     727 </span>            :                  obs,
<span class="lineNum">     728 </span>            :                  human_readable (output_blocksize, hbuf,
<span class="lineNum">     729 </span>            :                                  human_opts | human_base_1024, 1, 1));
<span class="lineNum">     730 </span>            :         }
<span class="lineNum">     731 </span><span class="lineNoCov">          0 :       obuf = ptr_align (real_obuf, page_size);</span>
<span class="lineNum">     732 </span>            :     }
<span class="lineNum">     733 </span>            :   else
<span class="lineNum">     734 </span>            :     {
<span class="lineNum">     735 </span><span class="lineNoCov">          0 :       alloc_ibuf ();</span>
<span class="lineNum">     736 </span><span class="lineNoCov">          0 :       obuf = ibuf;</span>
<span class="lineNum">     737 </span>            :     }
<span class="lineNum">     738 </span>            : }
<span class="lineNum">     739 </span>            : 
<span class="lineNum">     740 </span>            : static void
<span class="lineNum">     741 </span>            : translate_charset (char const *new_trans)
<span class="lineNum">     742 </span>            : {
<span class="lineNum">     743 </span>            :   int i;
<span class="lineNum">     744 </span>            : 
<span class="lineNum">     745 </span><span class="lineNoCov">          0 :   for (i = 0; i &lt; 256; i++)</span>
<span class="lineNum">     746 </span><span class="lineNoCov">          0 :     trans_table[i] = new_trans[trans_table[i]];</span>
<span class="lineNum">     747 </span><span class="lineNoCov">          0 :   translation_needed = true;</span>
<span class="lineNum">     748 </span>            : }
<span class="lineNum">     749 </span>            : 
<span class="lineNum">     750 </span>            : /* Return true if I has more than one bit set.  I must be nonnegative.  */
<span class="lineNum">     751 </span>            : 
<span class="lineNum">     752 </span>            : static inline bool
<span class="lineNum">     753 </span>            : multiple_bits_set (int i)
<span class="lineNum">     754 </span>            : {
<span class="lineNum">     755 </span><span class="lineNoCov">          0 :   return MULTIPLE_BITS_SET (i);</span>
<span class="lineNum">     756 </span>            : }
<span class="lineNum">     757 </span>            : 
<span class="lineNum">     758 </span>            : static bool
<span class="lineNum">     759 </span>            : abbreviation_lacks_prefix (char const *message)
<span class="lineNum">     760 </span>            : {
<span class="lineNum">     761 </span><span class="lineNoCov">          0 :   return message[strlen (message) - 2] == ' ';</span>
<span class="lineNum">     762 </span>            : }
<span class="lineNum">     763 </span>            : 
<span class="lineNum">     764 </span>            : /* Print transfer statistics.  */
<a name="765"><span class="lineNum">     765 </span>            : </a>
<span class="lineNum">     766 </span>            : static void
<span class="lineNum">     767 </span><span class="lineNoCov">          0 : print_xfer_stats (xtime_t progress_time)</span>
<span class="lineNum">     768 </span>            : {
<span class="lineNum">     769 </span><span class="lineNoCov">          0 :   xtime_t now = progress_time ? progress_time : gethrxtime ();</span>
<span class="lineNum">     770 </span>            :   char hbuf[3][LONGEST_HUMAN_READABLE + 1];
<span class="lineNum">     771 </span>            :   double delta_s;
<span class="lineNum">     772 </span>            :   char const *bytes_per_second;
<span class="lineNum">     773 </span><span class="lineNoCov">          0 :   char const *si = human_readable (w_bytes, hbuf[0], human_opts, 1, 1);</span>
<span class="lineNum">     774 </span><span class="lineNoCov">          0 :   char const *iec = human_readable (w_bytes, hbuf[1],</span>
<span class="lineNum">     775 </span>            :                                     human_opts | human_base_1024, 1, 1);
<span class="lineNum">     776 </span>            : 
<span class="lineNum">     777 </span>            :   /* Use integer arithmetic to compute the transfer rate,
<span class="lineNum">     778 </span>            :      since that makes it easy to use SI abbreviations.  */
<span class="lineNum">     779 </span><span class="lineNoCov">          0 :   if (start_time &lt; now)</span>
<span class="lineNum">     780 </span>            :     {
<span class="lineNum">     781 </span><span class="lineNoCov">          0 :       double XTIME_PRECISIONe0 = XTIME_PRECISION;</span>
<span class="lineNum">     782 </span><span class="lineNoCov">          0 :       uintmax_t delta_xtime = now;</span>
<span class="lineNum">     783 </span><span class="lineNoCov">          0 :       delta_xtime -= start_time;</span>
<span class="lineNum">     784 </span><span class="lineNoCov">          0 :       delta_s = delta_xtime / XTIME_PRECISIONe0;</span>
<span class="lineNum">     785 </span><span class="lineNoCov">          0 :       bytes_per_second = human_readable (w_bytes, hbuf[2], human_opts,</span>
<span class="lineNum">     786 </span>            :                                          XTIME_PRECISION, delta_xtime);
<span class="lineNum">     787 </span>            :     }
<span class="lineNum">     788 </span>            :   else
<span class="lineNum">     789 </span>            :     {
<span class="lineNum">     790 </span><span class="lineNoCov">          0 :       delta_s = 0;</span>
<span class="lineNum">     791 </span><span class="lineNoCov">          0 :       bytes_per_second = _(&quot;Infinity B&quot;);</span>
<span class="lineNum">     792 </span>            :     }
<span class="lineNum">     793 </span>            : 
<span class="lineNum">     794 </span><span class="lineNoCov">          0 :   if (progress_time)</span>
<span class="lineNum">     795 </span><span class="lineNoCov">          0 :     fputc ('\r', stderr);</span>
<span class="lineNum">     796 </span>            : 
<span class="lineNum">     797 </span>            :   /* TRANSLATORS: The instances of &quot;s&quot; in the following formats are
<span class="lineNum">     798 </span>            :      the SI symbol &quot;s&quot; (meaning second), and should not be translated.
<span class="lineNum">     799 </span>            :      The strings use SI symbols for better internationalization even
<span class="lineNum">     800 </span>            :      though they may be a bit more confusing in English.  If one of
<span class="lineNum">     801 </span>            :      these formats A looks shorter on the screen than another format
<span class="lineNum">     802 </span>            :      B, then A's string length should be less than B's, and appending
<span class="lineNum">     803 </span>            :      strlen (B) - strlen (A) spaces to A should make it appear to be
<span class="lineNum">     804 </span>            :      at least as long as B.  */
<span class="lineNum">     805 </span>            : 
<span class="lineNum">     806 </span><span class="lineNoCov">          0 :   int stats_len</span>
<span class="lineNum">     807 </span><span class="lineNoCov">          0 :     = (abbreviation_lacks_prefix (si)</span>
<span class="lineNum">     808 </span><span class="lineNoCov">          0 :        ? fprintf (stderr,</span>
<span class="lineNum">     809 </span><span class="lineNoCov">          0 :                   ngettext (&quot;%&quot;PRIuMAX&quot; byte copied, %g s, %s/s&quot;,</span>
<span class="lineNum">     810 </span>            :                             &quot;%&quot;PRIuMAX&quot; bytes copied, %g s, %s/s&quot;,
<span class="lineNum">     811 </span>            :                             select_plural (w_bytes)),
<span class="lineNum">     812 </span>            :                   w_bytes, delta_s, bytes_per_second)
<span class="lineNum">     813 </span><span class="lineNoCov">          0 :        : abbreviation_lacks_prefix (iec)</span>
<span class="lineNum">     814 </span><span class="lineNoCov">          0 :        ? fprintf (stderr,</span>
<span class="lineNum">     815 </span><span class="lineNoCov">          0 :                   _(&quot;%&quot;PRIuMAX&quot; bytes (%s) copied, %g s, %s/s&quot;),</span>
<span class="lineNum">     816 </span>            :                   w_bytes, si, delta_s, bytes_per_second)
<span class="lineNum">     817 </span><span class="lineNoCov">          0 :        : fprintf (stderr,</span>
<span class="lineNum">     818 </span><span class="lineNoCov">          0 :                   _(&quot;%&quot;PRIuMAX&quot; bytes (%s, %s) copied, %g s, %s/s&quot;),</span>
<span class="lineNum">     819 </span>            :                   w_bytes, si, iec, delta_s, bytes_per_second));
<span class="lineNum">     820 </span>            : 
<span class="lineNum">     821 </span><span class="lineNoCov">          0 :   if (progress_time)</span>
<span class="lineNum">     822 </span>            :     {
<span class="lineNum">     823 </span><span class="lineNoCov">          0 :       if (0 &lt;= stats_len &amp;&amp; stats_len &lt; progress_len)</span>
<span class="lineNum">     824 </span><span class="lineNoCov">          0 :         fprintf (stderr, &quot;%*s&quot;, progress_len - stats_len, &quot;&quot;);</span>
<span class="lineNum">     825 </span><span class="lineNoCov">          0 :       progress_len = stats_len;</span>
<span class="lineNum">     826 </span>            :     }
<span class="lineNum">     827 </span>            :   else
<span class="lineNum">     828 </span><span class="lineNoCov">          0 :     fputc ('\n', stderr);</span>
<span class="lineNum">     829 </span><span class="lineNoCov">          0 : }</span>
<a name="830"><span class="lineNum">     830 </span>            : </a>
<span class="lineNum">     831 </span>            : static void
<span class="lineNum">     832 </span><span class="lineNoCov">          0 : print_stats (void)</span>
<span class="lineNum">     833 </span>            : {
<span class="lineNum">     834 </span><span class="lineNoCov">          0 :   if (status_level == STATUS_NONE)</span>
<span class="lineNum">     835 </span>            :     return;
<span class="lineNum">     836 </span>            : 
<span class="lineNum">     837 </span><span class="lineNoCov">          0 :   if (0 &lt; progress_len)</span>
<span class="lineNum">     838 </span>            :     {
<span class="lineNum">     839 </span><span class="lineNoCov">          0 :       fputc ('\n', stderr);</span>
<span class="lineNum">     840 </span><span class="lineNoCov">          0 :       progress_len = 0;</span>
<span class="lineNum">     841 </span>            :     }
<span class="lineNum">     842 </span>            : 
<span class="lineNum">     843 </span><span class="lineNoCov">          0 :   fprintf (stderr,</span>
<span class="lineNum">     844 </span><span class="lineNoCov">          0 :            _(&quot;%&quot;PRIuMAX&quot;+%&quot;PRIuMAX&quot; records in\n&quot;</span>
<span class="lineNum">     845 </span>            :              &quot;%&quot;PRIuMAX&quot;+%&quot;PRIuMAX&quot; records out\n&quot;),
<span class="lineNum">     846 </span>            :            r_full, r_partial, w_full, w_partial);
<span class="lineNum">     847 </span>            : 
<span class="lineNum">     848 </span><span class="lineNoCov">          0 :   if (r_truncate != 0)</span>
<span class="lineNum">     849 </span><span class="lineNoCov">          0 :     fprintf (stderr,</span>
<span class="lineNum">     850 </span><span class="lineNoCov">          0 :              ngettext (&quot;%&quot;PRIuMAX&quot; truncated record\n&quot;,</span>
<span class="lineNum">     851 </span>            :                        &quot;%&quot;PRIuMAX&quot; truncated records\n&quot;,
<span class="lineNum">     852 </span>            :                        select_plural (r_truncate)),
<span class="lineNum">     853 </span>            :              r_truncate);
<span class="lineNum">     854 </span>            : 
<span class="lineNum">     855 </span><span class="lineNoCov">          0 :   if (status_level == STATUS_NOXFER)</span>
<span class="lineNum">     856 </span>            :     return;
<span class="lineNum">     857 </span>            : 
<span class="lineNum">     858 </span><span class="lineNoCov">          0 :   print_xfer_stats (0);</span>
<span class="lineNum">     859 </span>            : }
<span class="lineNum">     860 </span>            : 
<span class="lineNum">     861 </span>            : /* An ordinary signal was received; arrange for the program to exit.  */
<a name="862"><span class="lineNum">     862 </span>            : </a>
<span class="lineNum">     863 </span>            : static void
<span class="lineNum">     864 </span><span class="lineNoCov">          0 : interrupt_handler (int sig)</span>
<span class="lineNum">     865 </span>            : {
<span class="lineNum">     866 </span>            :   if (! SA_RESETHAND)
<span class="lineNum">     867 </span>            :     signal (sig, SIG_DFL);
<span class="lineNum">     868 </span><span class="lineNoCov">          0 :   interrupt_signal = sig;</span>
<span class="lineNum">     869 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     870 </span>            : 
<span class="lineNum">     871 </span>            : /* An info signal was received; arrange for the program to print status.  */
<a name="872"><span class="lineNum">     872 </span>            : </a>
<span class="lineNum">     873 </span>            : static void
<span class="lineNum">     874 </span><span class="lineNoCov">          0 : siginfo_handler (int sig)</span>
<span class="lineNum">     875 </span>            : {
<span class="lineNum">     876 </span>            :   if (! SA_NOCLDSTOP)
<span class="lineNum">     877 </span>            :     signal (sig, siginfo_handler);
<span class="lineNum">     878 </span><span class="lineNoCov">          0 :   info_signal_count++;</span>
<span class="lineNum">     879 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     880 </span>            : 
<span class="lineNum">     881 </span>            : /* Install the signal handlers.  */
<a name="882"><span class="lineNum">     882 </span>            : </a>
<span class="lineNum">     883 </span>            : static void
<span class="lineNum">     884 </span><span class="lineNoCov">          0 : install_signal_handlers (void)</span>
<span class="lineNum">     885 </span>            : {
<span class="lineNum">     886 </span><span class="lineNoCov">          0 :   bool catch_siginfo = ! (SIGINFO == SIGUSR1 &amp;&amp; getenv (&quot;POSIXLY_CORRECT&quot;));</span>
<span class="lineNum">     887 </span>            : 
<span class="lineNum">     888 </span>            : #if SA_NOCLDSTOP
<span class="lineNum">     889 </span>            : 
<span class="lineNum">     890 </span>            :   struct sigaction act;
<span class="lineNum">     891 </span><span class="lineNoCov">          0 :   sigemptyset (&amp;caught_signals);</span>
<span class="lineNum">     892 </span><span class="lineNoCov">          0 :   if (catch_siginfo)</span>
<span class="lineNum">     893 </span><span class="lineNoCov">          0 :     sigaddset (&amp;caught_signals, SIGINFO);</span>
<span class="lineNum">     894 </span><span class="lineNoCov">          0 :   sigaction (SIGINT, NULL, &amp;act);</span>
<span class="lineNum">     895 </span><span class="lineNoCov">          0 :   if (act.sa_handler != SIG_IGN)</span>
<span class="lineNum">     896 </span><span class="lineNoCov">          0 :     sigaddset (&amp;caught_signals, SIGINT);</span>
<span class="lineNum">     897 </span><span class="lineNoCov">          0 :   act.sa_mask = caught_signals;</span>
<span class="lineNum">     898 </span>            : 
<span class="lineNum">     899 </span><span class="lineNoCov">          0 :   if (sigismember (&amp;caught_signals, SIGINFO))</span>
<span class="lineNum">     900 </span>            :     {
<span class="lineNum">     901 </span><span class="lineNoCov">          0 :       act.sa_handler = siginfo_handler;</span>
<span class="lineNum">     902 </span>            :       /* Note we don't use SA_RESTART here and instead
<span class="lineNum">     903 </span>            :          handle EINTR explicitly in iftruncate() etc.
<span class="lineNum">     904 </span>            :          to avoid blocking on noncommitted read()/write() calls.  */
<span class="lineNum">     905 </span><span class="lineNoCov">          0 :       act.sa_flags = 0;</span>
<span class="lineNum">     906 </span><span class="lineNoCov">          0 :       sigaction (SIGINFO, &amp;act, NULL);</span>
<span class="lineNum">     907 </span>            :     }
<span class="lineNum">     908 </span>            : 
<span class="lineNum">     909 </span><span class="lineNoCov">          0 :   if (sigismember (&amp;caught_signals, SIGINT))</span>
<span class="lineNum">     910 </span>            :     {
<span class="lineNum">     911 </span><span class="lineNoCov">          0 :       act.sa_handler = interrupt_handler;</span>
<span class="lineNum">     912 </span><span class="lineNoCov">          0 :       act.sa_flags = SA_NODEFER | SA_RESETHAND;</span>
<span class="lineNum">     913 </span><span class="lineNoCov">          0 :       sigaction (SIGINT, &amp;act, NULL);</span>
<span class="lineNum">     914 </span>            :     }
<span class="lineNum">     915 </span>            : 
<span class="lineNum">     916 </span>            : #else
<span class="lineNum">     917 </span>            : 
<span class="lineNum">     918 </span>            :   if (catch_siginfo)
<span class="lineNum">     919 </span>            :     {
<span class="lineNum">     920 </span>            :       signal (SIGINFO, siginfo_handler);
<span class="lineNum">     921 </span>            :       siginterrupt (SIGINFO, 1);
<span class="lineNum">     922 </span>            :     }
<span class="lineNum">     923 </span>            :   if (signal (SIGINT, SIG_IGN) != SIG_IGN)
<span class="lineNum">     924 </span>            :     {
<span class="lineNum">     925 </span>            :       signal (SIGINT, interrupt_handler);
<span class="lineNum">     926 </span>            :       siginterrupt (SIGINT, 1);
<span class="lineNum">     927 </span>            :     }
<span class="lineNum">     928 </span>            : #endif
<span class="lineNum">     929 </span><span class="lineNoCov">          0 : }</span>
<a name="930"><span class="lineNum">     930 </span>            : </a>
<span class="lineNum">     931 </span>            : static void
<span class="lineNum">     932 </span><span class="lineNoCov">          0 : cleanup (void)</span>
<span class="lineNum">     933 </span>            : {
<span class="lineNum">     934 </span><span class="lineNoCov">          0 :   if (close (STDIN_FILENO) &lt; 0)</span>
<span class="lineNum">     935 </span><span class="lineNoCov">          0 :     error (EXIT_FAILURE, errno,</span>
<span class="lineNum">     936 </span><span class="lineNoCov">          0 :            _(&quot;closing input file %s&quot;), quoteaf (input_file));</span>
<span class="lineNum">     937 </span>            : 
<span class="lineNum">     938 </span>            :   /* Don't remove this call to close, even though close_stdout
<span class="lineNum">     939 </span>            :      closes standard output.  This close is necessary when cleanup
<span class="lineNum">     940 </span>            :      is called as part of a signal handler.  */
<span class="lineNum">     941 </span><span class="lineNoCov">          0 :   if (close (STDOUT_FILENO) &lt; 0)</span>
<span class="lineNum">     942 </span><span class="lineNoCov">          0 :     error (EXIT_FAILURE, errno,</span>
<span class="lineNum">     943 </span><span class="lineNoCov">          0 :            _(&quot;closing output file %s&quot;), quoteaf (output_file));</span>
<span class="lineNum">     944 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     945 </span>            : 
<span class="lineNum">     946 </span>            : /* Process any pending signals.  If signals are caught, this function
<span class="lineNum">     947 </span>            :    should be called periodically.  Ideally there should never be an
<span class="lineNum">     948 </span>            :    unbounded amount of time when signals are not being processed.  */
<a name="949"><span class="lineNum">     949 </span>            : </a>
<span class="lineNum">     950 </span>            : static void
<span class="lineNum">     951 </span><span class="lineNoCov">          0 : process_signals (void)</span>
<span class="lineNum">     952 </span>            : {
<span class="lineNum">     953 </span><span class="lineNoCov">          0 :   while (interrupt_signal || info_signal_count)</span>
<span class="lineNum">     954 </span>            :     {
<span class="lineNum">     955 </span>            :       int interrupt;
<span class="lineNum">     956 </span>            :       int infos;
<span class="lineNum">     957 </span>            :       sigset_t oldset;
<span class="lineNum">     958 </span>            : 
<span class="lineNum">     959 </span><span class="lineNoCov">          0 :       sigprocmask (SIG_BLOCK, &amp;caught_signals, &amp;oldset);</span>
<span class="lineNum">     960 </span>            : 
<span class="lineNum">     961 </span>            :       /* Reload interrupt_signal and info_signal_count, in case a new
<span class="lineNum">     962 </span>            :          signal was handled before sigprocmask took effect.  */
<span class="lineNum">     963 </span><span class="lineNoCov">          0 :       interrupt = interrupt_signal;</span>
<span class="lineNum">     964 </span><span class="lineNoCov">          0 :       infos = info_signal_count;</span>
<span class="lineNum">     965 </span>            : 
<span class="lineNum">     966 </span><span class="lineNoCov">          0 :       if (infos)</span>
<span class="lineNum">     967 </span><span class="lineNoCov">          0 :         info_signal_count = infos - 1;</span>
<span class="lineNum">     968 </span>            : 
<span class="lineNum">     969 </span><span class="lineNoCov">          0 :       sigprocmask (SIG_SETMASK, &amp;oldset, NULL);</span>
<span class="lineNum">     970 </span>            : 
<span class="lineNum">     971 </span><span class="lineNoCov">          0 :       if (interrupt)</span>
<span class="lineNum">     972 </span><span class="lineNoCov">          0 :         cleanup ();</span>
<span class="lineNum">     973 </span><span class="lineNoCov">          0 :       print_stats ();</span>
<span class="lineNum">     974 </span><span class="lineNoCov">          0 :       if (interrupt)</span>
<span class="lineNum">     975 </span><span class="lineNoCov">          0 :         raise (interrupt);</span>
<span class="lineNum">     976 </span>            :     }
<span class="lineNum">     977 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     978 </span>            : 
<span class="lineNum">     979 </span>            : static void
<span class="lineNum">     980 </span>            : finish_up (void)
<span class="lineNum">     981 </span>            : {
<span class="lineNum">     982 </span><span class="lineNoCov">          0 :   cleanup ();</span>
<span class="lineNum">     983 </span><span class="lineNoCov">          0 :   print_stats ();</span>
<span class="lineNum">     984 </span><span class="lineNoCov">          0 :   process_signals ();</span>
<span class="lineNum">     985 </span>            : }
<a name="986"><span class="lineNum">     986 </span>            : </a>
<span class="lineNum">     987 </span>            : static void ATTRIBUTE_NORETURN
<span class="lineNum">     988 </span><span class="lineNoCov">          0 : quit (int code)</span>
<span class="lineNum">     989 </span>            : {
<span class="lineNum">     990 </span>            :   finish_up ();
<span class="lineNum">     991 </span><span class="lineNoCov">          0 :   exit (code);</span>
<span class="lineNum">     992 </span>            : }
<span class="lineNum">     993 </span>            : 
<span class="lineNum">     994 </span>            : /* Return LEN rounded down to a multiple of PAGE_SIZE
<span class="lineNum">     995 </span>            :    while storing the remainder internally per FD.
<span class="lineNum">     996 </span>            :    Pass LEN == 0 to get the current remainder.  */
<span class="lineNum">     997 </span>            : 
<span class="lineNum">     998 </span>            : static off_t
<span class="lineNum">     999 </span>            : cache_round (int fd, off_t len)
<span class="lineNum">    1000 </span>            : {
<span class="lineNum">    1001 </span>            :   static off_t i_pending, o_pending;
<span class="lineNum">    1002 </span><span class="lineNoCov">          0 :   off_t *pending = (fd == STDIN_FILENO ? &amp;i_pending : &amp;o_pending);</span>
<span class="lineNum">    1003 </span>            : 
<span class="lineNum">    1004 </span><span class="lineNoCov">          0 :   if (len)</span>
<span class="lineNum">    1005 </span>            :     {
<span class="lineNum">    1006 </span><span class="lineNoCov">          0 :       uintmax_t c_pending = *pending + len;</span>
<span class="lineNum">    1007 </span><span class="lineNoCov">          0 :       *pending = c_pending % page_size;</span>
<span class="lineNum">    1008 </span><span class="lineNoCov">          0 :       if (c_pending &gt; *pending)</span>
<span class="lineNum">    1009 </span><span class="lineNoCov">          0 :         len = c_pending - *pending;</span>
<span class="lineNum">    1010 </span>            :       else
<span class="lineNum">    1011 </span>            :         len = 0;
<span class="lineNum">    1012 </span>            :     }
<span class="lineNum">    1013 </span>            :   else
<span class="lineNum">    1014 </span><span class="lineNoCov">          0 :     len = *pending;</span>
<span class="lineNum">    1015 </span>            : 
<span class="lineNum">    1016 </span>            :   return len;
<span class="lineNum">    1017 </span>            : }
<span class="lineNum">    1018 </span>            : 
<span class="lineNum">    1019 </span>            : /* Discard the cache from the current offset of either
<span class="lineNum">    1020 </span>            :    STDIN_FILENO or STDOUT_FILENO.
<span class="lineNum">    1021 </span>            :    Return true on success.  */
<a name="1022"><span class="lineNum">    1022 </span>            : </a>
<span class="lineNum">    1023 </span>            : static bool
<span class="lineNum">    1024 </span><span class="lineNoCov">          0 : invalidate_cache (int fd, off_t len)</span>
<span class="lineNum">    1025 </span>            : {
<span class="lineNum">    1026 </span><span class="lineNoCov">          0 :   int adv_ret = -1;</span>
<span class="lineNum">    1027 </span>            : 
<span class="lineNum">    1028 </span>            :   /* Minimize syscalls.  */
<span class="lineNum">    1029 </span><span class="lineNoCov">          0 :   off_t clen = cache_round (fd, len);</span>
<span class="lineNum">    1030 </span><span class="lineNoCov">          0 :   if (len &amp;&amp; !clen)</span>
<span class="lineNum">    1031 </span>            :     return true; /* Don't advise this time.  */
<span class="lineNum">    1032 </span><span class="lineNoCov">          0 :   if (!len &amp;&amp; !clen &amp;&amp; max_records)</span>
<span class="lineNum">    1033 </span>            :     return true; /* Nothing pending.  */
<span class="lineNum">    1034 </span><span class="lineNoCov">          0 :   off_t pending = len ? cache_round (fd, 0) : 0;</span>
<span class="lineNum">    1035 </span>            : 
<span class="lineNum">    1036 </span><span class="lineNoCov">          0 :   if (fd == STDIN_FILENO)</span>
<span class="lineNum">    1037 </span>            :     {
<span class="lineNum">    1038 </span><span class="lineNoCov">          0 :       if (input_seekable)</span>
<span class="lineNum">    1039 </span>            :         {
<span class="lineNum">    1040 </span>            :           /* Note we're being careful here to only invalidate what
<span class="lineNum">    1041 </span>            :              we've read, so as not to dump any read ahead cache.  */
<span class="lineNum">    1042 </span>            : #if HAVE_POSIX_FADVISE
<span class="lineNum">    1043 </span><span class="lineNoCov">          0 :             adv_ret = posix_fadvise (fd, input_offset - clen - pending, clen,</span>
<span class="lineNum">    1044 </span>            :                                      POSIX_FADV_DONTNEED);
<span class="lineNum">    1045 </span>            : #else
<span class="lineNum">    1046 </span>            :             errno = ENOTSUP;
<span class="lineNum">    1047 </span>            : #endif
<span class="lineNum">    1048 </span>            :         }
<span class="lineNum">    1049 </span>            :       else
<span class="lineNum">    1050 </span><span class="lineNoCov">          0 :         errno = ESPIPE;</span>
<span class="lineNum">    1051 </span>            :     }
<span class="lineNum">    1052 </span><span class="lineNoCov">          0 :   else if (fd == STDOUT_FILENO)</span>
<span class="lineNum">    1053 </span>            :     {
<span class="lineNum">    1054 </span>            :       static off_t output_offset = -2;
<span class="lineNum">    1055 </span>            : 
<span class="lineNum">    1056 </span><span class="lineNoCov">          0 :       if (output_offset != -1)</span>
<span class="lineNum">    1057 </span>            :         {
<span class="lineNum">    1058 </span><span class="lineNoCov">          0 :           if (0 &gt; output_offset)</span>
<span class="lineNum">    1059 </span>            :             {
<span class="lineNum">    1060 </span><span class="lineNoCov">          0 :               output_offset = lseek (fd, 0, SEEK_CUR);</span>
<span class="lineNum">    1061 </span><span class="lineNoCov">          0 :               output_offset -= clen + pending;</span>
<span class="lineNum">    1062 </span>            :             }
<span class="lineNum">    1063 </span><span class="lineNoCov">          0 :           if (0 &lt;= output_offset)</span>
<span class="lineNum">    1064 </span>            :             {
<span class="lineNum">    1065 </span>            : #if HAVE_POSIX_FADVISE
<span class="lineNum">    1066 </span><span class="lineNoCov">          0 :               adv_ret = posix_fadvise (fd, output_offset, clen,</span>
<span class="lineNum">    1067 </span>            :                                        POSIX_FADV_DONTNEED);
<span class="lineNum">    1068 </span>            : #else
<span class="lineNum">    1069 </span>            :               errno = ENOTSUP;
<span class="lineNum">    1070 </span>            : #endif
<span class="lineNum">    1071 </span><span class="lineNoCov">          0 :               output_offset += clen + pending;</span>
<span class="lineNum">    1072 </span>            :             }
<span class="lineNum">    1073 </span>            :         }
<span class="lineNum">    1074 </span>            :     }
<span class="lineNum">    1075 </span>            : 
<span class="lineNum">    1076 </span><span class="lineNoCov">          0 :   return adv_ret != -1 ? true : false;</span>
<span class="lineNum">    1077 </span>            : }
<span class="lineNum">    1078 </span>            : 
<span class="lineNum">    1079 </span>            : /* Read from FD into the buffer BUF of size SIZE, processing any
<span class="lineNum">    1080 </span>            :    signals that arrive before bytes are read.  Return the number of
<span class="lineNum">    1081 </span>            :    bytes read if successful, -1 (setting errno) on failure.  */
<a name="1082"><span class="lineNum">    1082 </span>            : </a>
<span class="lineNum">    1083 </span>            : static ssize_t
<span class="lineNum">    1084 </span><span class="lineNoCov">          0 : iread (int fd, char *buf, size_t size)</span>
<span class="lineNum">    1085 </span>            : {
<span class="lineNum">    1086 </span>            :   ssize_t nread;
<span class="lineNum">    1087 </span>            : 
<span class="lineNum">    1088 </span>            :   do
<span class="lineNum">    1089 </span>            :     {
<span class="lineNum">    1090 </span><span class="lineNoCov">          0 :       process_signals ();</span>
<span class="lineNum">    1091 </span><span class="lineNoCov">          0 :       nread = read (fd, buf, size);</span>
<span class="lineNum">    1092 </span>            :     }
<span class="lineNum">    1093 </span><span class="lineNoCov">          0 :   while (nread &lt; 0 &amp;&amp; errno == EINTR);</span>
<span class="lineNum">    1094 </span>            : 
<span class="lineNum">    1095 </span>            :   /* Short read may be due to received signal.  */
<span class="lineNum">    1096 </span><span class="lineNoCov">          0 :   if (0 &lt; nread &amp;&amp; nread &lt; size)</span>
<span class="lineNum">    1097 </span><span class="lineNoCov">          0 :     process_signals ();</span>
<span class="lineNum">    1098 </span>            : 
<span class="lineNum">    1099 </span><span class="lineNoCov">          0 :   if (0 &lt; nread &amp;&amp; warn_partial_read)</span>
<span class="lineNum">    1100 </span>            :     {
<span class="lineNum">    1101 </span>            :       static ssize_t prev_nread;
<span class="lineNum">    1102 </span>            : 
<span class="lineNum">    1103 </span><span class="lineNoCov">          0 :       if (0 &lt; prev_nread &amp;&amp; prev_nread &lt; size)</span>
<span class="lineNum">    1104 </span>            :         {
<span class="lineNum">    1105 </span><span class="lineNoCov">          0 :           uintmax_t prev = prev_nread;</span>
<span class="lineNum">    1106 </span><span class="lineNoCov">          0 :           if (status_level != STATUS_NONE)</span>
<span class="lineNum">    1107 </span><span class="lineNoCov">          0 :             error (0, 0, ngettext ((&quot;warning: partial read (%&quot;PRIuMAX&quot; byte); &quot;</span>
<span class="lineNum">    1108 </span>            :                                     &quot;suggest iflag=fullblock&quot;),
<span class="lineNum">    1109 </span>            :                                    (&quot;warning: partial read (%&quot;PRIuMAX&quot; bytes); &quot;
<span class="lineNum">    1110 </span>            :                                     &quot;suggest iflag=fullblock&quot;),
<span class="lineNum">    1111 </span>            :                                    select_plural (prev)),
<span class="lineNum">    1112 </span>            :                    prev);
<span class="lineNum">    1113 </span><span class="lineNoCov">          0 :           warn_partial_read = false;</span>
<span class="lineNum">    1114 </span>            :         }
<span class="lineNum">    1115 </span>            : 
<span class="lineNum">    1116 </span><span class="lineNoCov">          0 :       prev_nread = nread;</span>
<span class="lineNum">    1117 </span>            :     }
<span class="lineNum">    1118 </span>            : 
<span class="lineNum">    1119 </span><span class="lineNoCov">          0 :   return nread;</span>
<span class="lineNum">    1120 </span>            : }
<span class="lineNum">    1121 </span>            : 
<a name="1122"><span class="lineNum">    1122 </span>            : /* Wrapper around iread function to accumulate full blocks.  */</a>
<span class="lineNum">    1123 </span>            : static ssize_t
<span class="lineNum">    1124 </span><span class="lineNoCov">          0 : iread_fullblock (int fd, char *buf, size_t size)</span>
<span class="lineNum">    1125 </span>            : {
<span class="lineNum">    1126 </span><span class="lineNoCov">          0 :   ssize_t nread = 0;</span>
<span class="lineNum">    1127 </span>            : 
<span class="lineNum">    1128 </span><span class="lineNoCov">          0 :   while (0 &lt; size)</span>
<span class="lineNum">    1129 </span>            :     {
<span class="lineNum">    1130 </span><span class="lineNoCov">          0 :       ssize_t ncurr = iread (fd, buf, size);</span>
<span class="lineNum">    1131 </span><span class="lineNoCov">          0 :       if (ncurr &lt; 0)</span>
<span class="lineNum">    1132 </span>            :         return ncurr;
<span class="lineNum">    1133 </span><span class="lineNoCov">          0 :       if (ncurr == 0)</span>
<span class="lineNum">    1134 </span>            :         break;
<span class="lineNum">    1135 </span><span class="lineNoCov">          0 :       nread += ncurr;</span>
<span class="lineNum">    1136 </span><span class="lineNoCov">          0 :       buf   += ncurr;</span>
<span class="lineNum">    1137 </span><span class="lineNoCov">          0 :       size  -= ncurr;</span>
<span class="lineNum">    1138 </span>            :     }
<span class="lineNum">    1139 </span>            : 
<span class="lineNum">    1140 </span>            :   return nread;
<span class="lineNum">    1141 </span>            : }
<span class="lineNum">    1142 </span>            : 
<span class="lineNum">    1143 </span>            : /* Write to FD the buffer BUF of size SIZE, processing any signals
<span class="lineNum">    1144 </span>            :    that arrive.  Return the number of bytes written, setting errno if
<span class="lineNum">    1145 </span>            :    this is less than SIZE.  Keep trying if there are partial
<span class="lineNum">    1146 </span>            :    writes.  */
<a name="1147"><span class="lineNum">    1147 </span>            : </a>
<span class="lineNum">    1148 </span>            : static size_t
<span class="lineNum">    1149 </span><span class="lineNoCov">          0 : iwrite (int fd, char const *buf, size_t size)</span>
<span class="lineNum">    1150 </span>            : {
<span class="lineNum">    1151 </span><span class="lineNoCov">          0 :   size_t total_written = 0;</span>
<span class="lineNum">    1152 </span>            : 
<span class="lineNum">    1153 </span><span class="lineNoCov">          0 :   if ((output_flags &amp; O_DIRECT) &amp;&amp; size &lt; output_blocksize)</span>
<span class="lineNum">    1154 </span>            :     {
<span class="lineNum">    1155 </span><span class="lineNoCov">          0 :       int old_flags = fcntl (STDOUT_FILENO, F_GETFL);</span>
<span class="lineNum">    1156 </span><span class="lineNoCov">          0 :       if (fcntl (STDOUT_FILENO, F_SETFL, old_flags &amp; ~O_DIRECT) != 0</span>
<span class="lineNum">    1157 </span><span class="lineNoCov">          0 :           &amp;&amp; status_level != STATUS_NONE)</span>
<span class="lineNum">    1158 </span><span class="lineNoCov">          0 :         error (0, errno, _(&quot;failed to turn off O_DIRECT: %s&quot;),</span>
<span class="lineNum">    1159 </span>            :                quotef (output_file));
<span class="lineNum">    1160 </span>            : 
<span class="lineNum">    1161 </span>            :       /* Since we have just turned off O_DIRECT for the final write,
<span class="lineNum">    1162 </span>            :          here we try to preserve some of its semantics.  First, use
<span class="lineNum">    1163 </span>            :          posix_fadvise to tell the system not to pollute the buffer
<span class="lineNum">    1164 </span>            :          cache with this data.  Don't bother to diagnose lseek or
<span class="lineNum">    1165 </span>            :          posix_fadvise failure. */
<span class="lineNum">    1166 </span><span class="lineNoCov">          0 :       invalidate_cache (STDOUT_FILENO, 0);</span>
<span class="lineNum">    1167 </span>            : 
<span class="lineNum">    1168 </span>            :       /* Attempt to ensure that that final block is committed
<span class="lineNum">    1169 </span>            :          to disk as quickly as possible.  */
<span class="lineNum">    1170 </span><span class="lineNoCov">          0 :       conversions_mask |= C_FSYNC;</span>
<span class="lineNum">    1171 </span>            :     }
<span class="lineNum">    1172 </span>            : 
<span class="lineNum">    1173 </span><span class="lineNoCov">          0 :   while (total_written &lt; size)</span>
<span class="lineNum">    1174 </span>            :     {
<span class="lineNum">    1175 </span><span class="lineNoCov">          0 :       ssize_t nwritten = 0;</span>
<span class="lineNum">    1176 </span><span class="lineNoCov">          0 :       process_signals ();</span>
<span class="lineNum">    1177 </span>            : 
<span class="lineNum">    1178 </span>            :       /* Perform a seek for a NUL block if sparse output is enabled.  */
<span class="lineNum">    1179 </span><span class="lineNoCov">          0 :       final_op_was_seek = false;</span>
<span class="lineNum">    1180 </span><span class="lineNoCov">          0 :       if ((conversions_mask &amp; C_SPARSE) &amp;&amp; is_nul (buf, size))</span>
<span class="lineNum">    1181 </span>            :         {
<span class="lineNum">    1182 </span><span class="lineNoCov">          0 :           if (lseek (fd, size, SEEK_CUR) &lt; 0)</span>
<span class="lineNum">    1183 </span>            :             {
<span class="lineNum">    1184 </span><span class="lineNoCov">          0 :               conversions_mask &amp;= ~C_SPARSE;</span>
<span class="lineNum">    1185 </span>            :               /* Don't warn about the advisory sparse request.  */
<span class="lineNum">    1186 </span>            :             }
<span class="lineNum">    1187 </span>            :           else
<span class="lineNum">    1188 </span>            :             {
<span class="lineNum">    1189 </span><span class="lineNoCov">          0 :               final_op_was_seek = true;</span>
<span class="lineNum">    1190 </span><span class="lineNoCov">          0 :               nwritten = size;</span>
<span class="lineNum">    1191 </span>            :             }
<span class="lineNum">    1192 </span>            :         }
<span class="lineNum">    1193 </span>            : 
<span class="lineNum">    1194 </span><span class="lineNoCov">          0 :       if (!nwritten)</span>
<span class="lineNum">    1195 </span><span class="lineNoCov">          0 :         nwritten = write (fd, buf + total_written, size - total_written);</span>
<span class="lineNum">    1196 </span>            : 
<span class="lineNum">    1197 </span><span class="lineNoCov">          0 :       if (nwritten &lt; 0)</span>
<span class="lineNum">    1198 </span>            :         {
<span class="lineNum">    1199 </span><span class="lineNoCov">          0 :           if (errno != EINTR)</span>
<span class="lineNum">    1200 </span>            :             break;
<span class="lineNum">    1201 </span>            :         }
<span class="lineNum">    1202 </span><span class="lineNoCov">          0 :       else if (nwritten == 0)</span>
<span class="lineNum">    1203 </span>            :         {
<span class="lineNum">    1204 </span>            :           /* Some buggy drivers return 0 when one tries to write beyond
<span class="lineNum">    1205 </span>            :              a device's end.  (Example: Linux kernel 1.2.13 on /dev/fd0.)
<span class="lineNum">    1206 </span>            :              Set errno to ENOSPC so they get a sensible diagnostic.  */
<span class="lineNum">    1207 </span><span class="lineNoCov">          0 :           errno = ENOSPC;</span>
<span class="lineNum">    1208 </span><span class="lineNoCov">          0 :           break;</span>
<span class="lineNum">    1209 </span>            :         }
<span class="lineNum">    1210 </span>            :       else
<span class="lineNum">    1211 </span><span class="lineNoCov">          0 :         total_written += nwritten;</span>
<span class="lineNum">    1212 </span>            :     }
<span class="lineNum">    1213 </span>            : 
<span class="lineNum">    1214 </span><span class="lineNoCov">          0 :   if (o_nocache &amp;&amp; total_written)</span>
<span class="lineNum">    1215 </span><span class="lineNoCov">          0 :     invalidate_cache (fd, total_written);</span>
<span class="lineNum">    1216 </span>            : 
<span class="lineNum">    1217 </span><span class="lineNoCov">          0 :   return total_written;</span>
<span class="lineNum">    1218 </span>            : }
<span class="lineNum">    1219 </span>            : 
<span class="lineNum">    1220 </span>            : /* Write, then empty, the output buffer 'obuf'. */
<a name="1221"><span class="lineNum">    1221 </span>            : </a>
<span class="lineNum">    1222 </span>            : static void
<span class="lineNum">    1223 </span><span class="lineNoCov">          0 : write_output (void)</span>
<span class="lineNum">    1224 </span>            : {
<span class="lineNum">    1225 </span><span class="lineNoCov">          0 :   size_t nwritten = iwrite (STDOUT_FILENO, obuf, output_blocksize);</span>
<span class="lineNum">    1226 </span><span class="lineNoCov">          0 :   w_bytes += nwritten;</span>
<span class="lineNum">    1227 </span><span class="lineNoCov">          0 :   if (nwritten != output_blocksize)</span>
<span class="lineNum">    1228 </span>            :     {
<span class="lineNum">    1229 </span><span class="lineNoCov">          0 :       error (0, errno, _(&quot;writing to %s&quot;), quoteaf (output_file));</span>
<span class="lineNum">    1230 </span><span class="lineNoCov">          0 :       if (nwritten != 0)</span>
<span class="lineNum">    1231 </span><span class="lineNoCov">          0 :         w_partial++;</span>
<span class="lineNum">    1232 </span><span class="lineNoCov">          0 :       quit (EXIT_FAILURE);</span>
<span class="lineNum">    1233 </span>            :     }
<span class="lineNum">    1234 </span>            :   else
<span class="lineNum">    1235 </span><span class="lineNoCov">          0 :     w_full++;</span>
<span class="lineNum">    1236 </span><span class="lineNoCov">          0 :   oc = 0;</span>
<span class="lineNum">    1237 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    1238 </span>            : 
<span class="lineNum">    1239 </span>            : /* Restart on EINTR from fd_reopen().  */
<a name="1240"><span class="lineNum">    1240 </span>            : </a>
<span class="lineNum">    1241 </span>            : static int
<span class="lineNum">    1242 </span><span class="lineNoCov">          0 : ifd_reopen (int desired_fd, char const *file, int flag, mode_t mode)</span>
<span class="lineNum">    1243 </span>            : {
<span class="lineNum">    1244 </span>            :   int ret;
<span class="lineNum">    1245 </span>            : 
<span class="lineNum">    1246 </span>            :   do
<span class="lineNum">    1247 </span>            :     {
<span class="lineNum">    1248 </span><span class="lineNoCov">          0 :       process_signals ();</span>
<span class="lineNum">    1249 </span><span class="lineNoCov">          0 :       ret = fd_reopen (desired_fd, file, flag, mode);</span>
<span class="lineNum">    1250 </span>            :     }
<span class="lineNum">    1251 </span><span class="lineNoCov">          0 :   while (ret &lt; 0 &amp;&amp; errno == EINTR);</span>
<span class="lineNum">    1252 </span>            : 
<span class="lineNum">    1253 </span><span class="lineNoCov">          0 :   return ret;</span>
<span class="lineNum">    1254 </span>            : }
<span class="lineNum">    1255 </span>            : 
<span class="lineNum">    1256 </span>            : /* Restart on EINTR from ftruncate().  */
<a name="1257"><span class="lineNum">    1257 </span>            : </a>
<span class="lineNum">    1258 </span>            : static int
<span class="lineNum">    1259 </span><span class="lineNoCov">          0 : iftruncate (int fd, off_t length)</span>
<span class="lineNum">    1260 </span>            : {
<span class="lineNum">    1261 </span>            :   int ret;
<span class="lineNum">    1262 </span>            : 
<span class="lineNum">    1263 </span>            :   do
<span class="lineNum">    1264 </span>            :     {
<span class="lineNum">    1265 </span><span class="lineNoCov">          0 :       process_signals ();</span>
<span class="lineNum">    1266 </span><span class="lineNoCov">          0 :       ret = ftruncate (fd, length);</span>
<span class="lineNum">    1267 </span>            :     }
<span class="lineNum">    1268 </span><span class="lineNoCov">          0 :   while (ret &lt; 0 &amp;&amp; errno == EINTR);</span>
<span class="lineNum">    1269 </span>            : 
<span class="lineNum">    1270 </span><span class="lineNoCov">          0 :   return ret;</span>
<span class="lineNum">    1271 </span>            : }
<span class="lineNum">    1272 </span>            : 
<span class="lineNum">    1273 </span>            : /* Return true if STR is of the form &quot;PATTERN&quot; or &quot;PATTERNDELIM...&quot;.  */
<span class="lineNum">    1274 </span>            : 
<span class="lineNum">    1275 </span>            : static bool _GL_ATTRIBUTE_PURE
<span class="lineNum">    1276 </span>            : operand_matches (char const *str, char const *pattern, char delim)
<span class="lineNum">    1277 </span>            : {
<span class="lineNum">    1278 </span><span class="lineNoCov">          0 :   while (*pattern)</span>
<span class="lineNum">    1279 </span><span class="lineNoCov">          0 :     if (*str++ != *pattern++)</span>
<span class="lineNum">    1280 </span>            :       return false;
<span class="lineNum">    1281 </span><span class="lineNoCov">          0 :   return !*str || *str == delim;</span>
<span class="lineNum">    1282 </span>            : }
<span class="lineNum">    1283 </span>            : 
<span class="lineNum">    1284 </span>            : /* Interpret one &quot;conv=...&quot; or similar operand STR according to the
<span class="lineNum">    1285 </span>            :    symbols in TABLE, returning the flags specified.  If the operand
<span class="lineNum">    1286 </span>            :    cannot be parsed, use ERROR_MSGID to generate a diagnostic.  */
<a name="1287"><span class="lineNum">    1287 </span>            : </a>
<span class="lineNum">    1288 </span>            : static int
<span class="lineNum">    1289 </span><span class="lineNoCov">          0 : parse_symbols (char const *str, struct symbol_value const *table,</span>
<span class="lineNum">    1290 </span>            :                bool exclusive, char const *error_msgid)
<span class="lineNum">    1291 </span>            : {
<span class="lineNum">    1292 </span><span class="lineNoCov">          0 :   int value = 0;</span>
<span class="lineNum">    1293 </span>            : 
<span class="lineNum">    1294 </span>            :   while (true)
<span class="lineNum">    1295 </span>            :     {
<span class="lineNum">    1296 </span><span class="lineNoCov">          0 :       char const *strcomma = strchr (str, ',');</span>
<span class="lineNum">    1297 </span>            :       struct symbol_value const *entry;
<span class="lineNum">    1298 </span>            : 
<span class="lineNum">    1299 </span><span class="lineNoCov">          0 :       for (entry = table;</span>
<span class="lineNum">    1300 </span><span class="lineNoCov">          0 :            ! (operand_matches (str, entry-&gt;symbol, ',') &amp;&amp; entry-&gt;value);</span>
<span class="lineNum">    1301 </span><span class="lineNoCov">          0 :            entry++)</span>
<span class="lineNum">    1302 </span>            :         {
<span class="lineNum">    1303 </span><span class="lineNoCov">          0 :           if (! entry-&gt;symbol[0])</span>
<span class="lineNum">    1304 </span>            :             {
<span class="lineNum">    1305 </span><span class="lineNoCov">          0 :               size_t slen = strcomma ? strcomma - str : strlen (str);</span>
<span class="lineNum">    1306 </span><span class="lineNoCov">          0 :               error (0, 0, &quot;%s: %s&quot;, _(error_msgid),</span>
<span class="lineNum">    1307 </span>            :                      quotearg_n_style_mem (0, locale_quoting_style, str, slen));
<span class="lineNum">    1308 </span><span class="lineNoCov">          0 :               usage (EXIT_FAILURE);</span>
<span class="lineNum">    1309 </span>            :             }
<span class="lineNum">    1310 </span>            :         }
<span class="lineNum">    1311 </span>            : 
<span class="lineNum">    1312 </span><span class="lineNoCov">          0 :       if (exclusive)</span>
<span class="lineNum">    1313 </span>            :         value = entry-&gt;value;
<span class="lineNum">    1314 </span>            :       else
<span class="lineNum">    1315 </span><span class="lineNoCov">          0 :         value |= entry-&gt;value;</span>
<span class="lineNum">    1316 </span><span class="lineNoCov">          0 :       if (!strcomma)</span>
<span class="lineNum">    1317 </span>            :         break;
<span class="lineNum">    1318 </span><span class="lineNoCov">          0 :       str = strcomma + 1;</span>
<span class="lineNum">    1319 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">    1320 </span>            : 
<span class="lineNum">    1321 </span><span class="lineNoCov">          0 :   return value;</span>
<span class="lineNum">    1322 </span>            : }
<span class="lineNum">    1323 </span>            : 
<span class="lineNum">    1324 </span>            : /* Return the value of STR, interpreted as a non-negative decimal integer,
<span class="lineNum">    1325 </span>            :    optionally multiplied by various values.
<span class="lineNum">    1326 </span>            :    Set *INVALID to a nonzero error value if STR does not represent a
<span class="lineNum">    1327 </span>            :    number in this format.  */
<a name="1328"><span class="lineNum">    1328 </span>            : </a>
<span class="lineNum">    1329 </span>            : static uintmax_t
<span class="lineNum">    1330 </span><span class="lineNoCov">          0 : parse_integer (const char *str, strtol_error *invalid)</span>
<span class="lineNum">    1331 </span>            : {
<span class="lineNum">    1332 </span>            :   uintmax_t n;
<span class="lineNum">    1333 </span>            :   char *suffix;
<span class="lineNum">    1334 </span><span class="lineNoCov">          0 :   strtol_error e = xstrtoumax (str, &amp;suffix, 10, &amp;n, &quot;bcEGkKMPTwYZ0&quot;);</span>
<span class="lineNum">    1335 </span>            : 
<span class="lineNum">    1336 </span><span class="lineNoCov">          0 :   if (e == LONGINT_INVALID_SUFFIX_CHAR &amp;&amp; *suffix == 'x')</span>
<span class="lineNum">    1337 </span><span class="lineNoCov">          0 :     {</span>
<span class="lineNum">    1338 </span><span class="lineNoCov">          0 :       uintmax_t multiplier = parse_integer (suffix + 1, invalid);</span>
<span class="lineNum">    1339 </span>            : 
<span class="lineNum">    1340 </span><span class="lineNoCov">          0 :       if (multiplier != 0 &amp;&amp; n * multiplier / multiplier != n)</span>
<span class="lineNum">    1341 </span>            :         {
<span class="lineNum">    1342 </span><span class="lineNoCov">          0 :           *invalid = LONGINT_OVERFLOW;</span>
<span class="lineNum">    1343 </span><span class="lineNoCov">          0 :           return 0;</span>
<span class="lineNum">    1344 </span>            :         }
<span class="lineNum">    1345 </span>            : 
<span class="lineNum">    1346 </span><span class="lineNoCov">          0 :       n *= multiplier;</span>
<span class="lineNum">    1347 </span>            :     }
<span class="lineNum">    1348 </span><span class="lineNoCov">          0 :   else if (e != LONGINT_OK)</span>
<span class="lineNum">    1349 </span>            :     {
<span class="lineNum">    1350 </span><span class="lineNoCov">          0 :       *invalid = e;</span>
<span class="lineNum">    1351 </span><span class="lineNoCov">          0 :       return 0;</span>
<span class="lineNum">    1352 </span>            :     }
<span class="lineNum">    1353 </span>            : 
<span class="lineNum">    1354 </span><span class="lineNoCov">          0 :   return n;</span>
<span class="lineNum">    1355 </span>            : }
<span class="lineNum">    1356 </span>            : 
<span class="lineNum">    1357 </span>            : /* OPERAND is of the form &quot;X=...&quot;.  Return true if X is NAME.  */
<span class="lineNum">    1358 </span>            : 
<span class="lineNum">    1359 </span>            : static bool _GL_ATTRIBUTE_PURE
<span class="lineNum">    1360 </span>            : operand_is (char const *operand, char const *name)
<span class="lineNum">    1361 </span>            : {
<span class="lineNum">    1362 </span><span class="lineNoCov">          0 :   return operand_matches (operand, name, '=');</span>
<span class="lineNum">    1363 </span>            : }
<a name="1364"><span class="lineNum">    1364 </span>            : </a>
<span class="lineNum">    1365 </span>            : static void
<span class="lineNum">    1366 </span><span class="lineNoCov">          0 : scanargs (int argc, char *const *argv)</span>
<span class="lineNum">    1367 </span>            : {
<span class="lineNum">    1368 </span>            :   int i;
<span class="lineNum">    1369 </span><span class="lineNoCov">          0 :   size_t blocksize = 0;</span>
<span class="lineNum">    1370 </span><span class="lineNoCov">          0 :   uintmax_t count = (uintmax_t) -1;</span>
<span class="lineNum">    1371 </span><span class="lineNoCov">          0 :   uintmax_t skip = 0;</span>
<span class="lineNum">    1372 </span><span class="lineNoCov">          0 :   uintmax_t seek = 0;</span>
<span class="lineNum">    1373 </span>            : 
<span class="lineNum">    1374 </span><span class="lineNoCov">          0 :   for (i = optind; i &lt; argc; i++)</span>
<span class="lineNum">    1375 </span>            :     {
<span class="lineNum">    1376 </span><span class="lineNoCov">          0 :       char const *name = argv[i];</span>
<span class="lineNum">    1377 </span><span class="lineNoCov">          0 :       char const *val = strchr (name, '=');</span>
<span class="lineNum">    1378 </span>            : 
<span class="lineNum">    1379 </span><span class="lineNoCov">          0 :       if (val == NULL)</span>
<span class="lineNum">    1380 </span>            :         {
<span class="lineNum">    1381 </span><span class="lineNoCov">          0 :           error (0, 0, _(&quot;unrecognized operand %s&quot;),</span>
<span class="lineNum">    1382 </span>            :                  quote (name));
<span class="lineNum">    1383 </span><span class="lineNoCov">          0 :           usage (EXIT_FAILURE);</span>
<span class="lineNum">    1384 </span>            :         }
<span class="lineNum">    1385 </span><span class="lineNoCov">          0 :       val++;</span>
<span class="lineNum">    1386 </span>            : 
<span class="lineNum">    1387 </span><span class="lineNoCov">          0 :       if (operand_is (name, &quot;if&quot;))</span>
<span class="lineNum">    1388 </span><span class="lineNoCov">          0 :         input_file = val;</span>
<span class="lineNum">    1389 </span><span class="lineNoCov">          0 :       else if (operand_is (name, &quot;of&quot;))</span>
<span class="lineNum">    1390 </span><span class="lineNoCov">          0 :         output_file = val;</span>
<span class="lineNum">    1391 </span><span class="lineNoCov">          0 :       else if (operand_is (name, &quot;conv&quot;))</span>
<span class="lineNum">    1392 </span><span class="lineNoCov">          0 :         conversions_mask |= parse_symbols (val, conversions, false,</span>
<span class="lineNum">    1393 </span>            :                                            N_(&quot;invalid conversion&quot;));
<span class="lineNum">    1394 </span><span class="lineNoCov">          0 :       else if (operand_is (name, &quot;iflag&quot;))</span>
<span class="lineNum">    1395 </span><span class="lineNoCov">          0 :         input_flags |= parse_symbols (val, flags, false,</span>
<span class="lineNum">    1396 </span>            :                                       N_(&quot;invalid input flag&quot;));
<span class="lineNum">    1397 </span><span class="lineNoCov">          0 :       else if (operand_is (name, &quot;oflag&quot;))</span>
<span class="lineNum">    1398 </span><span class="lineNoCov">          0 :         output_flags |= parse_symbols (val, flags, false,</span>
<span class="lineNum">    1399 </span>            :                                        N_(&quot;invalid output flag&quot;));
<span class="lineNum">    1400 </span><span class="lineNoCov">          0 :       else if (operand_is (name, &quot;status&quot;))</span>
<span class="lineNum">    1401 </span><span class="lineNoCov">          0 :         status_level = parse_symbols (val, statuses, true,</span>
<span class="lineNum">    1402 </span>            :                                       N_(&quot;invalid status level&quot;));
<span class="lineNum">    1403 </span>            :       else
<span class="lineNum">    1404 </span>            :         {
<span class="lineNum">    1405 </span><span class="lineNoCov">          0 :           strtol_error invalid = LONGINT_OK;</span>
<span class="lineNum">    1406 </span><span class="lineNoCov">          0 :           uintmax_t n = parse_integer (val, &amp;invalid);</span>
<span class="lineNum">    1407 </span><span class="lineNoCov">          0 :           uintmax_t n_min = 0;</span>
<span class="lineNum">    1408 </span><span class="lineNoCov">          0 :           uintmax_t n_max = UINTMAX_MAX;</span>
<span class="lineNum">    1409 </span>            : 
<span class="lineNum">    1410 </span><span class="lineNoCov">          0 :           if (operand_is (name, &quot;ibs&quot;))</span>
<span class="lineNum">    1411 </span>            :             {
<span class="lineNum">    1412 </span><span class="lineNoCov">          0 :               n_min = 1;</span>
<span class="lineNum">    1413 </span><span class="lineNoCov">          0 :               n_max = MAX_BLOCKSIZE (INPUT_BLOCK_SLOP);</span>
<span class="lineNum">    1414 </span><span class="lineNoCov">          0 :               input_blocksize = n;</span>
<span class="lineNum">    1415 </span>            :             }
<span class="lineNum">    1416 </span><span class="lineNoCov">          0 :           else if (operand_is (name, &quot;obs&quot;))</span>
<span class="lineNum">    1417 </span>            :             {
<span class="lineNum">    1418 </span><span class="lineNoCov">          0 :               n_min = 1;</span>
<span class="lineNum">    1419 </span><span class="lineNoCov">          0 :               n_max = MAX_BLOCKSIZE (OUTPUT_BLOCK_SLOP);</span>
<span class="lineNum">    1420 </span><span class="lineNoCov">          0 :               output_blocksize = n;</span>
<span class="lineNum">    1421 </span>            :             }
<span class="lineNum">    1422 </span><span class="lineNoCov">          0 :           else if (operand_is (name, &quot;bs&quot;))</span>
<span class="lineNum">    1423 </span>            :             {
<span class="lineNum">    1424 </span><span class="lineNoCov">          0 :               n_min = 1;</span>
<span class="lineNum">    1425 </span><span class="lineNoCov">          0 :               n_max = MAX_BLOCKSIZE (INPUT_BLOCK_SLOP);</span>
<span class="lineNum">    1426 </span><span class="lineNoCov">          0 :               blocksize = n;</span>
<span class="lineNum">    1427 </span>            :             }
<span class="lineNum">    1428 </span><span class="lineNoCov">          0 :           else if (operand_is (name, &quot;cbs&quot;))</span>
<span class="lineNum">    1429 </span>            :             {
<span class="lineNum">    1430 </span><span class="lineNoCov">          0 :               n_min = 1;</span>
<span class="lineNum">    1431 </span><span class="lineNoCov">          0 :               n_max = SIZE_MAX;</span>
<span class="lineNum">    1432 </span><span class="lineNoCov">          0 :               conversion_blocksize = n;</span>
<span class="lineNum">    1433 </span>            :             }
<span class="lineNum">    1434 </span><span class="lineNoCov">          0 :           else if (operand_is (name, &quot;skip&quot;))</span>
<span class="lineNum">    1435 </span>            :             skip = n;
<span class="lineNum">    1436 </span><span class="lineNoCov">          0 :           else if (operand_is (name, &quot;seek&quot;))</span>
<span class="lineNum">    1437 </span>            :             seek = n;
<span class="lineNum">    1438 </span><span class="lineNoCov">          0 :           else if (operand_is (name, &quot;count&quot;))</span>
<span class="lineNum">    1439 </span>            :             count = n;
<span class="lineNum">    1440 </span>            :           else
<span class="lineNum">    1441 </span>            :             {
<span class="lineNum">    1442 </span><span class="lineNoCov">          0 :               error (0, 0, _(&quot;unrecognized operand %s&quot;),</span>
<span class="lineNum">    1443 </span>            :                      quote (name));
<span class="lineNum">    1444 </span><span class="lineNoCov">          0 :               usage (EXIT_FAILURE);</span>
<span class="lineNum">    1445 </span>            :             }
<span class="lineNum">    1446 </span>            : 
<span class="lineNum">    1447 </span><span class="lineNoCov">          0 :           if (n &lt; n_min)</span>
<span class="lineNum">    1448 </span><span class="lineNoCov">          0 :             invalid = LONGINT_INVALID;</span>
<span class="lineNum">    1449 </span><span class="lineNoCov">          0 :           else if (n_max &lt; n)</span>
<span class="lineNum">    1450 </span><span class="lineNoCov">          0 :             invalid = LONGINT_OVERFLOW;</span>
<span class="lineNum">    1451 </span>            : 
<span class="lineNum">    1452 </span><span class="lineNoCov">          0 :           if (invalid != LONGINT_OK)</span>
<span class="lineNum">    1453 </span><span class="lineNoCov">          0 :             error (EXIT_FAILURE, invalid == LONGINT_OVERFLOW ? EOVERFLOW : 0,</span>
<span class="lineNum">    1454 </span>            :                    &quot;%s: %s&quot;, _(&quot;invalid number&quot;), quote (val));
<span class="lineNum">    1455 </span>            :         }
<span class="lineNum">    1456 </span>            :     }
<span class="lineNum">    1457 </span>            : 
<span class="lineNum">    1458 </span><span class="lineNoCov">          0 :   if (blocksize)</span>
<span class="lineNum">    1459 </span><span class="lineNoCov">          0 :     input_blocksize = output_blocksize = blocksize;</span>
<span class="lineNum">    1460 </span>            :   else
<span class="lineNum">    1461 </span>            :     {
<span class="lineNum">    1462 </span>            :       /* POSIX says dd aggregates partial reads into
<span class="lineNum">    1463 </span>            :          output_blocksize if bs= is not specified.  */
<span class="lineNum">    1464 </span><span class="lineNoCov">          0 :       conversions_mask |= C_TWOBUFS;</span>
<span class="lineNum">    1465 </span>            :     }
<span class="lineNum">    1466 </span>            : 
<span class="lineNum">    1467 </span><span class="lineNoCov">          0 :   if (input_blocksize == 0)</span>
<span class="lineNum">    1468 </span><span class="lineNoCov">          0 :     input_blocksize = DEFAULT_BLOCKSIZE;</span>
<span class="lineNum">    1469 </span><span class="lineNoCov">          0 :   if (output_blocksize == 0)</span>
<span class="lineNum">    1470 </span><span class="lineNoCov">          0 :     output_blocksize = DEFAULT_BLOCKSIZE;</span>
<span class="lineNum">    1471 </span><span class="lineNoCov">          0 :   if (conversion_blocksize == 0)</span>
<span class="lineNum">    1472 </span><span class="lineNoCov">          0 :     conversions_mask &amp;= ~(C_BLOCK | C_UNBLOCK);</span>
<span class="lineNum">    1473 </span>            : 
<span class="lineNum">    1474 </span><span class="lineNoCov">          0 :   if (input_flags &amp; (O_DSYNC | O_SYNC))</span>
<span class="lineNum">    1475 </span><span class="lineNoCov">          0 :     input_flags |= O_RSYNC;</span>
<span class="lineNum">    1476 </span>            : 
<span class="lineNum">    1477 </span><span class="lineNoCov">          0 :   if (output_flags &amp; O_FULLBLOCK)</span>
<span class="lineNum">    1478 </span>            :     {
<span class="lineNum">    1479 </span><span class="lineNoCov">          0 :       error (0, 0, &quot;%s: %s&quot;, _(&quot;invalid output flag&quot;), quote (&quot;fullblock&quot;));</span>
<span class="lineNum">    1480 </span><span class="lineNoCov">          0 :       usage (EXIT_FAILURE);</span>
<span class="lineNum">    1481 </span>            :     }
<span class="lineNum">    1482 </span>            : 
<span class="lineNum">    1483 </span><span class="lineNoCov">          0 :   if (input_flags &amp; O_SEEK_BYTES)</span>
<span class="lineNum">    1484 </span>            :     {
<span class="lineNum">    1485 </span><span class="lineNoCov">          0 :       error (0, 0, &quot;%s: %s&quot;, _(&quot;invalid input flag&quot;), quote (&quot;seek_bytes&quot;));</span>
<span class="lineNum">    1486 </span><span class="lineNoCov">          0 :       usage (EXIT_FAILURE);</span>
<span class="lineNum">    1487 </span>            :     }
<span class="lineNum">    1488 </span>            : 
<span class="lineNum">    1489 </span><span class="lineNoCov">          0 :   if (output_flags &amp; (O_COUNT_BYTES | O_SKIP_BYTES))</span>
<span class="lineNum">    1490 </span>            :     {
<span class="lineNum">    1491 </span><span class="lineNoCov">          0 :       error (0, 0, &quot;%s: %s&quot;, _(&quot;invalid output flag&quot;),</span>
<span class="lineNum">    1492 </span><span class="lineNoCov">          0 :              quote (output_flags &amp; O_COUNT_BYTES</span>
<span class="lineNum">    1493 </span>            :                     ? &quot;count_bytes&quot; : &quot;skip_bytes&quot;));
<span class="lineNum">    1494 </span><span class="lineNoCov">          0 :       usage (EXIT_FAILURE);</span>
<span class="lineNum">    1495 </span>            :     }
<span class="lineNum">    1496 </span>            : 
<span class="lineNum">    1497 </span><span class="lineNoCov">          0 :   if (input_flags &amp; O_SKIP_BYTES &amp;&amp; skip != 0)</span>
<span class="lineNum">    1498 </span>            :     {
<span class="lineNum">    1499 </span><span class="lineNoCov">          0 :       skip_records = skip / input_blocksize;</span>
<span class="lineNum">    1500 </span><span class="lineNoCov">          0 :       skip_bytes = skip % input_blocksize;</span>
<span class="lineNum">    1501 </span>            :     }
<span class="lineNum">    1502 </span><span class="lineNoCov">          0 :   else if (skip != 0)</span>
<span class="lineNum">    1503 </span><span class="lineNoCov">          0 :     skip_records = skip;</span>
<span class="lineNum">    1504 </span>            : 
<span class="lineNum">    1505 </span><span class="lineNoCov">          0 :   if (input_flags &amp; O_COUNT_BYTES &amp;&amp; count != (uintmax_t) -1)</span>
<span class="lineNum">    1506 </span>            :     {
<span class="lineNum">    1507 </span><span class="lineNoCov">          0 :       max_records = count / input_blocksize;</span>
<span class="lineNum">    1508 </span><span class="lineNoCov">          0 :       max_bytes = count % input_blocksize;</span>
<span class="lineNum">    1509 </span>            :     }
<span class="lineNum">    1510 </span><span class="lineNoCov">          0 :   else if (count != (uintmax_t) -1)</span>
<span class="lineNum">    1511 </span><span class="lineNoCov">          0 :     max_records = count;</span>
<span class="lineNum">    1512 </span>            : 
<span class="lineNum">    1513 </span><span class="lineNoCov">          0 :   if (output_flags &amp; O_SEEK_BYTES &amp;&amp; seek != 0)</span>
<span class="lineNum">    1514 </span>            :     {
<span class="lineNum">    1515 </span><span class="lineNoCov">          0 :       seek_records = seek / output_blocksize;</span>
<span class="lineNum">    1516 </span><span class="lineNoCov">          0 :       seek_bytes = seek % output_blocksize;</span>
<span class="lineNum">    1517 </span>            :     }
<span class="lineNum">    1518 </span><span class="lineNoCov">          0 :   else if (seek != 0)</span>
<span class="lineNum">    1519 </span><span class="lineNoCov">          0 :     seek_records = seek;</span>
<span class="lineNum">    1520 </span>            : 
<span class="lineNum">    1521 </span>            :   /* Warn about partial reads if bs=SIZE is given and iflag=fullblock
<span class="lineNum">    1522 </span>            :      is not, and if counting or skipping bytes or using direct I/O.
<span class="lineNum">    1523 </span>            :      This helps to avoid confusion with miscounts, and to avoid issues
<span class="lineNum">    1524 </span>            :      with direct I/O on GNU/Linux.  */
<span class="lineNum">    1525 </span><span class="lineNoCov">          0 :   warn_partial_read =</span>
<span class="lineNum">    1526 </span><span class="lineNoCov">          0 :     (! (conversions_mask &amp; C_TWOBUFS) &amp;&amp; ! (input_flags &amp; O_FULLBLOCK)</span>
<span class="lineNum">    1527 </span><span class="lineNoCov">          0 :      &amp;&amp; (skip_records</span>
<span class="lineNum">    1528 </span><span class="lineNoCov">          0 :          || (0 &lt; max_records &amp;&amp; max_records &lt; (uintmax_t) -1)</span>
<span class="lineNum">    1529 </span><span class="lineNoCov">          0 :          || (input_flags | output_flags) &amp; O_DIRECT));</span>
<span class="lineNum">    1530 </span>            : 
<span class="lineNum">    1531 </span><span class="lineNoCov">          0 :   iread_fnc = ((input_flags &amp; O_FULLBLOCK)</span>
<span class="lineNum">    1532 </span>            :                ? iread_fullblock
<span class="lineNum">    1533 </span><span class="lineNoCov">          0 :                : iread);</span>
<span class="lineNum">    1534 </span><span class="lineNoCov">          0 :   input_flags &amp;= ~O_FULLBLOCK;</span>
<span class="lineNum">    1535 </span>            : 
<span class="lineNum">    1536 </span><span class="lineNoCov">          0 :   if (multiple_bits_set (conversions_mask &amp; (C_ASCII | C_EBCDIC | C_IBM)))</span>
<span class="lineNum">    1537 </span><span class="lineNoCov">          0 :     error (EXIT_FAILURE, 0, _(&quot;cannot combine any two of {ascii,ebcdic,ibm}&quot;));</span>
<span class="lineNum">    1538 </span><span class="lineNoCov">          0 :   if (multiple_bits_set (conversions_mask &amp; (C_BLOCK | C_UNBLOCK)))</span>
<span class="lineNum">    1539 </span><span class="lineNoCov">          0 :     error (EXIT_FAILURE, 0, _(&quot;cannot combine block and unblock&quot;));</span>
<span class="lineNum">    1540 </span><span class="lineNoCov">          0 :   if (multiple_bits_set (conversions_mask &amp; (C_LCASE | C_UCASE)))</span>
<span class="lineNum">    1541 </span><span class="lineNoCov">          0 :     error (EXIT_FAILURE, 0, _(&quot;cannot combine lcase and ucase&quot;));</span>
<span class="lineNum">    1542 </span><span class="lineNoCov">          0 :   if (multiple_bits_set (conversions_mask &amp; (C_EXCL | C_NOCREAT)))</span>
<span class="lineNum">    1543 </span><span class="lineNoCov">          0 :     error (EXIT_FAILURE, 0, _(&quot;cannot combine excl and nocreat&quot;));</span>
<span class="lineNum">    1544 </span><span class="lineNoCov">          0 :   if (multiple_bits_set (input_flags &amp; (O_DIRECT | O_NOCACHE))</span>
<span class="lineNum">    1545 </span><span class="lineNoCov">          0 :       || multiple_bits_set (output_flags &amp; (O_DIRECT | O_NOCACHE)))</span>
<span class="lineNum">    1546 </span><span class="lineNoCov">          0 :     error (EXIT_FAILURE, 0, _(&quot;cannot combine direct and nocache&quot;));</span>
<span class="lineNum">    1547 </span>            : 
<span class="lineNum">    1548 </span><span class="lineNoCov">          0 :   if (input_flags &amp; O_NOCACHE)</span>
<span class="lineNum">    1549 </span>            :     {
<span class="lineNum">    1550 </span><span class="lineNoCov">          0 :       i_nocache = true;</span>
<span class="lineNum">    1551 </span><span class="lineNoCov">          0 :       input_flags &amp;= ~O_NOCACHE;</span>
<span class="lineNum">    1552 </span>            :     }
<span class="lineNum">    1553 </span><span class="lineNoCov">          0 :   if (output_flags &amp; O_NOCACHE)</span>
<span class="lineNum">    1554 </span>            :     {
<span class="lineNum">    1555 </span><span class="lineNoCov">          0 :       o_nocache = true;</span>
<span class="lineNum">    1556 </span><span class="lineNoCov">          0 :       output_flags &amp;= ~O_NOCACHE;</span>
<span class="lineNum">    1557 </span>            :     }
<span class="lineNum">    1558 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    1559 </span>            : 
<span class="lineNum">    1560 </span>            : /* Fix up translation table. */
<a name="1561"><span class="lineNum">    1561 </span>            : </a>
<span class="lineNum">    1562 </span>            : static void
<span class="lineNum">    1563 </span><span class="lineNoCov">          0 : apply_translations (void)</span>
<span class="lineNum">    1564 </span>            : {
<span class="lineNum">    1565 </span>            :   int i;
<span class="lineNum">    1566 </span>            : 
<span class="lineNum">    1567 </span><span class="lineNoCov">          0 :   if (conversions_mask &amp; C_ASCII)</span>
<span class="lineNum">    1568 </span>            :     translate_charset (ebcdic_to_ascii);
<span class="lineNum">    1569 </span>            : 
<span class="lineNum">    1570 </span><span class="lineNoCov">          0 :   if (conversions_mask &amp; C_UCASE)</span>
<span class="lineNum">    1571 </span>            :     {
<span class="lineNum">    1572 </span><span class="lineNoCov">          0 :       for (i = 0; i &lt; 256; i++)</span>
<span class="lineNum">    1573 </span><span class="lineNoCov">          0 :         trans_table[i] = toupper (trans_table[i]);</span>
<span class="lineNum">    1574 </span><span class="lineNoCov">          0 :       translation_needed = true;</span>
<span class="lineNum">    1575 </span>            :     }
<span class="lineNum">    1576 </span><span class="lineNoCov">          0 :   else if (conversions_mask &amp; C_LCASE)</span>
<span class="lineNum">    1577 </span>            :     {
<span class="lineNum">    1578 </span><span class="lineNoCov">          0 :       for (i = 0; i &lt; 256; i++)</span>
<span class="lineNum">    1579 </span><span class="lineNoCov">          0 :         trans_table[i] = tolower (trans_table[i]);</span>
<span class="lineNum">    1580 </span><span class="lineNoCov">          0 :       translation_needed = true;</span>
<span class="lineNum">    1581 </span>            :     }
<span class="lineNum">    1582 </span>            : 
<span class="lineNum">    1583 </span><span class="lineNoCov">          0 :   if (conversions_mask &amp; C_EBCDIC)</span>
<span class="lineNum">    1584 </span>            :     {
<span class="lineNum">    1585 </span><span class="lineNoCov">          0 :       translate_charset (ascii_to_ebcdic);</span>
<span class="lineNum">    1586 </span><span class="lineNoCov">          0 :       newline_character = ascii_to_ebcdic['\n'];</span>
<span class="lineNum">    1587 </span><span class="lineNoCov">          0 :       space_character = ascii_to_ebcdic[' '];</span>
<span class="lineNum">    1588 </span>            :     }
<span class="lineNum">    1589 </span><span class="lineNoCov">          0 :   else if (conversions_mask &amp; C_IBM)</span>
<span class="lineNum">    1590 </span>            :     {
<span class="lineNum">    1591 </span><span class="lineNoCov">          0 :       translate_charset (ascii_to_ibm);</span>
<span class="lineNum">    1592 </span><span class="lineNoCov">          0 :       newline_character = ascii_to_ibm['\n'];</span>
<span class="lineNum">    1593 </span><span class="lineNoCov">          0 :       space_character = ascii_to_ibm[' '];</span>
<span class="lineNum">    1594 </span>            :     }
<span class="lineNum">    1595 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    1596 </span>            : 
<span class="lineNum">    1597 </span>            : /* Apply the character-set translations specified by the user
<span class="lineNum">    1598 </span>            :    to the NREAD bytes in BUF.  */
<span class="lineNum">    1599 </span>            : 
<span class="lineNum">    1600 </span>            : static void
<span class="lineNum">    1601 </span>            : translate_buffer (char *buf, size_t nread)
<span class="lineNum">    1602 </span>            : {
<span class="lineNum">    1603 </span>            :   char *cp;
<span class="lineNum">    1604 </span>            :   size_t i;
<span class="lineNum">    1605 </span>            : 
<span class="lineNum">    1606 </span><span class="lineNoCov">          0 :   for (i = nread, cp = buf; i; i--, cp++)</span>
<span class="lineNum">    1607 </span><span class="lineNoCov">          0 :     *cp = trans_table[to_uchar (*cp)];</span>
<span class="lineNum">    1608 </span>            : }
<span class="lineNum">    1609 </span>            : 
<span class="lineNum">    1610 </span>            : /* If true, the last char from the previous call to 'swab_buffer'
<span class="lineNum">    1611 </span>            :    is saved in 'saved_char'.  */
<span class="lineNum">    1612 </span>            : static bool char_is_saved = false;
<span class="lineNum">    1613 </span>            : 
<span class="lineNum">    1614 </span>            : /* Odd char from previous call.  */
<span class="lineNum">    1615 </span>            : static char saved_char;
<span class="lineNum">    1616 </span>            : 
<span class="lineNum">    1617 </span>            : /* Swap NREAD bytes in BUF, plus possibly an initial char from the
<span class="lineNum">    1618 </span>            :    previous call.  If NREAD is odd, save the last char for the
<span class="lineNum">    1619 </span>            :    next call.   Return the new start of the BUF buffer.  */
<a name="1620"><span class="lineNum">    1620 </span>            : </a>
<span class="lineNum">    1621 </span>            : static char *
<span class="lineNum">    1622 </span><span class="lineNoCov">          0 : swab_buffer (char *buf, size_t *nread)</span>
<span class="lineNum">    1623 </span>            : {
<span class="lineNum">    1624 </span><span class="lineNoCov">          0 :   char *bufstart = buf;</span>
<span class="lineNum">    1625 </span>            :   char *cp;
<span class="lineNum">    1626 </span>            :   size_t i;
<span class="lineNum">    1627 </span>            : 
<span class="lineNum">    1628 </span>            :   /* Is a char left from last time?  */
<span class="lineNum">    1629 </span><span class="lineNoCov">          0 :   if (char_is_saved)</span>
<span class="lineNum">    1630 </span>            :     {
<span class="lineNum">    1631 </span><span class="lineNoCov">          0 :       *--bufstart = saved_char;</span>
<span class="lineNum">    1632 </span><span class="lineNoCov">          0 :       (*nread)++;</span>
<span class="lineNum">    1633 </span><span class="lineNoCov">          0 :       char_is_saved = false;</span>
<span class="lineNum">    1634 </span>            :     }
<span class="lineNum">    1635 </span>            : 
<span class="lineNum">    1636 </span><span class="lineNoCov">          0 :   if (*nread &amp; 1)</span>
<span class="lineNum">    1637 </span>            :     {
<span class="lineNum">    1638 </span>            :       /* An odd number of chars are in the buffer.  */
<span class="lineNum">    1639 </span><span class="lineNoCov">          0 :       saved_char = bufstart[--*nread];</span>
<span class="lineNum">    1640 </span><span class="lineNoCov">          0 :       char_is_saved = true;</span>
<span class="lineNum">    1641 </span>            :     }
<span class="lineNum">    1642 </span>            : 
<span class="lineNum">    1643 </span>            :   /* Do the byte-swapping by moving every second character two
<span class="lineNum">    1644 </span>            :      positions toward the end, working from the end of the buffer
<span class="lineNum">    1645 </span>            :      toward the beginning.  This way we only move half of the data.  */
<span class="lineNum">    1646 </span>            : 
<span class="lineNum">    1647 </span><span class="lineNoCov">          0 :   cp = bufstart + *nread;       /* Start one char past the last.  */</span>
<span class="lineNum">    1648 </span><span class="lineNoCov">          0 :   for (i = *nread / 2; i; i--, cp -= 2)</span>
<span class="lineNum">    1649 </span><span class="lineNoCov">          0 :     *cp = *(cp - 2);</span>
<span class="lineNum">    1650 </span>            : 
<span class="lineNum">    1651 </span><span class="lineNoCov">          0 :   return ++bufstart;</span>
<span class="lineNum">    1652 </span>            : }
<span class="lineNum">    1653 </span>            : 
<span class="lineNum">    1654 </span>            : /* Add OFFSET to the input offset, setting the overflow flag if
<span class="lineNum">    1655 </span>            :    necessary.  */
<span class="lineNum">    1656 </span>            : 
<span class="lineNum">    1657 </span>            : static void
<span class="lineNum">    1658 </span>            : advance_input_offset (uintmax_t offset)
<span class="lineNum">    1659 </span>            : {
<span class="lineNum">    1660 </span><span class="lineNoCov">          0 :   input_offset += offset;</span>
<span class="lineNum">    1661 </span><span class="lineNoCov">          0 :   if (input_offset &lt; offset)</span>
<span class="lineNum">    1662 </span><span class="lineNoCov">          0 :     input_offset_overflow = true;</span>
<span class="lineNum">    1663 </span>            : }
<span class="lineNum">    1664 </span>            : 
<span class="lineNum">    1665 </span>            : /* This is a wrapper for lseek.  It detects and warns about a kernel
<span class="lineNum">    1666 </span>            :    bug that makes lseek a no-op for tape devices, even though the kernel
<span class="lineNum">    1667 </span>            :    lseek return value suggests that the function succeeded.
<span class="lineNum">    1668 </span>            : 
<span class="lineNum">    1669 </span>            :    The parameters are the same as those of the lseek function, but
<span class="lineNum">    1670 </span>            :    with the addition of FILENAME, the name of the file associated with
<span class="lineNum">    1671 </span>            :    descriptor FDESC.  The file name is used solely in the warning that's
<span class="lineNum">    1672 </span>            :    printed when the bug is detected.  Return the same value that lseek
<span class="lineNum">    1673 </span>            :    would have returned, but when the lseek bug is detected, return -1
<span class="lineNum">    1674 </span>            :    to indicate that lseek failed.
<span class="lineNum">    1675 </span>            : 
<span class="lineNum">    1676 </span>            :    The offending behavior has been confirmed with an Exabyte SCSI tape
<span class="lineNum">    1677 </span>            :    drive accessed via /dev/nst0 on both Linux 2.2.17 and 2.4.16 kernels.  */
<span class="lineNum">    1678 </span>            : 
<span class="lineNum">    1679 </span>            : #ifdef __linux__
<span class="lineNum">    1680 </span>            : 
<span class="lineNum">    1681 </span>            : # include &lt;sys/mtio.h&gt;
<span class="lineNum">    1682 </span>            : 
<span class="lineNum">    1683 </span>            : # define MT_SAME_POSITION(P, Q) \
<span class="lineNum">    1684 </span>            :    ((P).mt_resid == (Q).mt_resid \
<span class="lineNum">    1685 </span>            :     &amp;&amp; (P).mt_fileno == (Q).mt_fileno \
<span class="lineNum">    1686 </span>            :     &amp;&amp; (P).mt_blkno == (Q).mt_blkno)
<a name="1687"><span class="lineNum">    1687 </span>            : </a>
<span class="lineNum">    1688 </span>            : static off_t
<span class="lineNum">    1689 </span><span class="lineNoCov">          0 : skip_via_lseek (char const *filename, int fdesc, off_t offset, int whence)</span>
<span class="lineNum">    1690 </span>            : {
<span class="lineNum">    1691 </span>            :   struct mtget s1;
<span class="lineNum">    1692 </span>            :   struct mtget s2;
<span class="lineNum">    1693 </span><span class="lineNoCov">          0 :   bool got_original_tape_position = (ioctl (fdesc, MTIOCGET, &amp;s1) == 0);</span>
<span class="lineNum">    1694 </span>            :   /* known bad device type */
<span class="lineNum">    1695 </span>            :   /* &amp;&amp; s.mt_type == MT_ISSCSI2 */
<span class="lineNum">    1696 </span>            : 
<span class="lineNum">    1697 </span><span class="lineNoCov">          0 :   off_t new_position = lseek (fdesc, offset, whence);</span>
<span class="lineNum">    1698 </span><span class="lineNoCov">          0 :   if (0 &lt;= new_position</span>
<span class="lineNum">    1699 </span><span class="lineNoCov">          0 :       &amp;&amp; got_original_tape_position</span>
<span class="lineNum">    1700 </span><span class="lineNoCov">          0 :       &amp;&amp; ioctl (fdesc, MTIOCGET, &amp;s2) == 0</span>
<span class="lineNum">    1701 </span><span class="lineNoCov">          0 :       &amp;&amp; MT_SAME_POSITION (s1, s2))</span>
<span class="lineNum">    1702 </span>            :     {
<span class="lineNum">    1703 </span><span class="lineNoCov">          0 :       if (status_level != STATUS_NONE)</span>
<span class="lineNum">    1704 </span><span class="lineNoCov">          0 :         error (0, 0, _(&quot;warning: working around lseek kernel bug for file &quot;</span>
<span class="lineNum">    1705 </span>            :                        &quot;(%s)\n  of mt_type=0x%0lx -- &quot;
<span class="lineNum">    1706 </span>            :                        &quot;see &lt;sys/mtio.h&gt; for the list of types&quot;),
<span class="lineNum">    1707 </span><span class="lineNoCov">          0 :                filename, s2.mt_type + 0Lu);</span>
<span class="lineNum">    1708 </span><span class="lineNoCov">          0 :       errno = 0;</span>
<span class="lineNum">    1709 </span><span class="lineNoCov">          0 :       new_position = -1;</span>
<span class="lineNum">    1710 </span>            :     }
<span class="lineNum">    1711 </span>            : 
<span class="lineNum">    1712 </span><span class="lineNoCov">          0 :   return new_position;</span>
<span class="lineNum">    1713 </span>            : }
<span class="lineNum">    1714 </span>            : #else
<span class="lineNum">    1715 </span>            : # define skip_via_lseek(Filename, Fd, Offset, Whence) lseek (Fd, Offset, Whence)
<span class="lineNum">    1716 </span>            : #endif
<span class="lineNum">    1717 </span>            : 
<span class="lineNum">    1718 </span>            : /* Throw away RECORDS blocks of BLOCKSIZE bytes plus BYTES bytes on
<span class="lineNum">    1719 </span>            :    file descriptor FDESC, which is open with read permission for FILE.
<span class="lineNum">    1720 </span>            :    Store up to BLOCKSIZE bytes of the data at a time in IBUF or OBUF, if
<span class="lineNum">    1721 </span>            :    necessary. RECORDS or BYTES must be nonzero. If FDESC is
<span class="lineNum">    1722 </span>            :    STDIN_FILENO, advance the input offset. Return the number of
<span class="lineNum">    1723 </span>            :    records remaining, i.e., that were not skipped because EOF was
<span class="lineNum">    1724 </span>            :    reached.  If FDESC is STDOUT_FILENO, on return, BYTES is the
<span class="lineNum">    1725 </span>            :    remaining bytes in addition to the remaining records.  */
<a name="1726"><span class="lineNum">    1726 </span>            : </a>
<span class="lineNum">    1727 </span>            : static uintmax_t
<span class="lineNum">    1728 </span><span class="lineNoCov">          0 : skip (int fdesc, char const *file, uintmax_t records, size_t blocksize,</span>
<span class="lineNum">    1729 </span>            :       size_t *bytes)
<span class="lineNum">    1730 </span>            : {
<span class="lineNum">    1731 </span><span class="lineNoCov">          0 :   uintmax_t offset = records * blocksize + *bytes;</span>
<span class="lineNum">    1732 </span>            : 
<span class="lineNum">    1733 </span>            :   /* Try lseek and if an error indicates it was an inappropriate operation --
<span class="lineNum">    1734 </span>            :      or if the file offset is not representable as an off_t --
<span class="lineNum">    1735 </span>            :      fall back on using read.  */
<span class="lineNum">    1736 </span>            : 
<span class="lineNum">    1737 </span><span class="lineNoCov">          0 :   errno = 0;</span>
<span class="lineNum">    1738 </span><span class="lineNoCov">          0 :   if (records &lt;= OFF_T_MAX / blocksize</span>
<span class="lineNum">    1739 </span><span class="lineNoCov">          0 :       &amp;&amp; 0 &lt;= skip_via_lseek (file, fdesc, offset, SEEK_CUR))</span>
<span class="lineNum">    1740 </span>            :     {
<span class="lineNum">    1741 </span><span class="lineNoCov">          0 :       if (fdesc == STDIN_FILENO)</span>
<span class="lineNum">    1742 </span>            :         {
<span class="lineNum">    1743 </span>            :            struct stat st;
<span class="lineNum">    1744 </span><span class="lineNoCov">          0 :            if (fstat (STDIN_FILENO, &amp;st) != 0)</span>
<span class="lineNum">    1745 </span><span class="lineNoCov">          0 :              error (EXIT_FAILURE, errno, _(&quot;cannot fstat %s&quot;), quoteaf (file));</span>
<span class="lineNum">    1746 </span><span class="lineNoCov">          0 :            if (usable_st_size (&amp;st) &amp;&amp; st.st_size &lt; input_offset + offset)</span>
<span class="lineNum">    1747 </span>            :              {
<span class="lineNum">    1748 </span>            :                /* When skipping past EOF, return the number of _full_ blocks
<span class="lineNum">    1749 </span>            :                 * that are not skipped, and set offset to EOF, so the caller
<span class="lineNum">    1750 </span>            :                 * can determine the requested skip was not satisfied.  */
<span class="lineNum">    1751 </span><span class="lineNoCov">          0 :                records = ( offset - st.st_size ) / blocksize;</span>
<span class="lineNum">    1752 </span><span class="lineNoCov">          0 :                offset = st.st_size - input_offset;</span>
<span class="lineNum">    1753 </span>            :              }
<span class="lineNum">    1754 </span>            :            else
<span class="lineNum">    1755 </span>            :              records = 0;
<span class="lineNum">    1756 </span><span class="lineNoCov">          0 :            advance_input_offset (offset);</span>
<span class="lineNum">    1757 </span>            :         }
<span class="lineNum">    1758 </span>            :       else
<span class="lineNum">    1759 </span>            :         {
<span class="lineNum">    1760 </span><span class="lineNoCov">          0 :           records = 0;</span>
<span class="lineNum">    1761 </span><span class="lineNoCov">          0 :           *bytes = 0;</span>
<span class="lineNum">    1762 </span>            :         }
<span class="lineNum">    1763 </span>            :       return records;
<span class="lineNum">    1764 </span>            :     }
<span class="lineNum">    1765 </span>            :   else
<span class="lineNum">    1766 </span>            :     {
<span class="lineNum">    1767 </span><span class="lineNoCov">          0 :       int lseek_errno = errno;</span>
<span class="lineNum">    1768 </span>            : 
<span class="lineNum">    1769 </span>            :       /* The seek request may have failed above if it was too big
<span class="lineNum">    1770 </span>            :          (&gt; device size, &gt; max file size, etc.)
<span class="lineNum">    1771 </span>            :          Or it may not have been done at all (&gt; OFF_T_MAX).
<span class="lineNum">    1772 </span>            :          Therefore try to seek to the end of the file,
<span class="lineNum">    1773 </span>            :          to avoid redundant reading.  */
<span class="lineNum">    1774 </span><span class="lineNoCov">          0 :       if ((skip_via_lseek (file, fdesc, 0, SEEK_END)) &gt;= 0)</span>
<span class="lineNum">    1775 </span>            :         {
<span class="lineNum">    1776 </span>            :           /* File is seekable, and we're at the end of it, and
<span class="lineNum">    1777 </span>            :              size &lt;= OFF_T_MAX. So there's no point using read to advance.  */
<span class="lineNum">    1778 </span>            : 
<span class="lineNum">    1779 </span><span class="lineNoCov">          0 :           if (!lseek_errno)</span>
<span class="lineNum">    1780 </span>            :             {
<span class="lineNum">    1781 </span>            :               /* The original seek was not attempted as offset &gt; OFF_T_MAX.
<span class="lineNum">    1782 </span>            :                  We should error for write as can't get to the desired
<span class="lineNum">    1783 </span>            :                  location, even if OFF_T_MAX &lt; max file size.
<span class="lineNum">    1784 </span>            :                  For read we're not going to read any data anyway,
<span class="lineNum">    1785 </span>            :                  so we should error for consistency.
<span class="lineNum">    1786 </span>            :                  It would be nice to not error for /dev/{zero,null}
<span class="lineNum">    1787 </span>            :                  for any offset, but that's not a significant issue.  */
<span class="lineNum">    1788 </span><span class="lineNoCov">          0 :               lseek_errno = EOVERFLOW;</span>
<span class="lineNum">    1789 </span>            :             }
<span class="lineNum">    1790 </span>            : 
<span class="lineNum">    1791 </span><span class="lineNoCov">          0 :           if (fdesc == STDIN_FILENO)</span>
<span class="lineNum">    1792 </span><span class="lineNoCov">          0 :             error (0, lseek_errno, _(&quot;%s: cannot skip&quot;), quotef (file));</span>
<span class="lineNum">    1793 </span>            :           else
<span class="lineNum">    1794 </span><span class="lineNoCov">          0 :             error (0, lseek_errno, _(&quot;%s: cannot seek&quot;), quotef (file));</span>
<span class="lineNum">    1795 </span>            :           /* If the file has a specific size and we've asked
<span class="lineNum">    1796 </span>            :              to skip/seek beyond the max allowable, then quit.  */
<span class="lineNum">    1797 </span><span class="lineNoCov">          0 :           quit (EXIT_FAILURE);</span>
<span class="lineNum">    1798 </span>            :         }
<span class="lineNum">    1799 </span>            :       /* else file_size &amp;&amp; offset &gt; OFF_T_MAX or file ! seekable */
<span class="lineNum">    1800 </span>            : 
<span class="lineNum">    1801 </span>            :       char *buf;
<span class="lineNum">    1802 </span><span class="lineNoCov">          0 :       if (fdesc == STDIN_FILENO)</span>
<span class="lineNum">    1803 </span>            :         {
<span class="lineNum">    1804 </span><span class="lineNoCov">          0 :           alloc_ibuf ();</span>
<span class="lineNum">    1805 </span><span class="lineNoCov">          0 :           buf = ibuf;</span>
<span class="lineNum">    1806 </span>            :         }
<span class="lineNum">    1807 </span>            :       else
<span class="lineNum">    1808 </span>            :         {
<span class="lineNum">    1809 </span><span class="lineNoCov">          0 :           alloc_obuf ();</span>
<span class="lineNum">    1810 </span><span class="lineNoCov">          0 :           buf = obuf;</span>
<span class="lineNum">    1811 </span>            :         }
<span class="lineNum">    1812 </span>            : 
<span class="lineNum">    1813 </span>            :       do
<span class="lineNum">    1814 </span>            :         {
<span class="lineNum">    1815 </span><span class="lineNoCov">          0 :           ssize_t nread = iread_fnc (fdesc, buf, records ? blocksize : *bytes);</span>
<span class="lineNum">    1816 </span><span class="lineNoCov">          0 :           if (nread &lt; 0)</span>
<span class="lineNum">    1817 </span>            :             {
<span class="lineNum">    1818 </span><span class="lineNoCov">          0 :               if (fdesc == STDIN_FILENO)</span>
<span class="lineNum">    1819 </span>            :                 {
<span class="lineNum">    1820 </span><span class="lineNoCov">          0 :                   error (0, errno, _(&quot;error reading %s&quot;), quoteaf (file));</span>
<span class="lineNum">    1821 </span><span class="lineNoCov">          0 :                   if (conversions_mask &amp; C_NOERROR)</span>
<span class="lineNum">    1822 </span><span class="lineNoCov">          0 :                     print_stats ();</span>
<span class="lineNum">    1823 </span>            :                 }
<span class="lineNum">    1824 </span>            :               else
<span class="lineNum">    1825 </span><span class="lineNoCov">          0 :                 error (0, lseek_errno, _(&quot;%s: cannot seek&quot;), quotef (file));</span>
<span class="lineNum">    1826 </span><span class="lineNoCov">          0 :               quit (EXIT_FAILURE);</span>
<span class="lineNum">    1827 </span>            :             }
<span class="lineNum">    1828 </span><span class="lineNoCov">          0 :           else if (nread == 0)</span>
<span class="lineNum">    1829 </span>            :             break;
<span class="lineNum">    1830 </span><span class="lineNoCov">          0 :           else if (fdesc == STDIN_FILENO)</span>
<span class="lineNum">    1831 </span><span class="lineNoCov">          0 :             advance_input_offset (nread);</span>
<span class="lineNum">    1832 </span>            : 
<span class="lineNum">    1833 </span><span class="lineNoCov">          0 :           if (records != 0)</span>
<span class="lineNum">    1834 </span><span class="lineNoCov">          0 :             records--;</span>
<span class="lineNum">    1835 </span>            :           else
<span class="lineNum">    1836 </span><span class="lineNoCov">          0 :             *bytes = 0;</span>
<span class="lineNum">    1837 </span>            :         }
<span class="lineNum">    1838 </span><span class="lineNoCov">          0 :       while (records || *bytes);</span>
<span class="lineNum">    1839 </span>            : 
<span class="lineNum">    1840 </span>            :       return records;
<span class="lineNum">    1841 </span>            :     }
<span class="lineNum">    1842 </span>            : }
<span class="lineNum">    1843 </span>            : 
<span class="lineNum">    1844 </span>            : /* Advance the input by NBYTES if possible, after a read error.
<span class="lineNum">    1845 </span>            :    The input file offset may or may not have advanced after the failed
<span class="lineNum">    1846 </span>            :    read; adjust it to point just after the bad record regardless.
<span class="lineNum">    1847 </span>            :    Return true if successful, or if the input is already known to not
<span class="lineNum">    1848 </span>            :    be seekable.  */
<a name="1849"><span class="lineNum">    1849 </span>            : </a>
<span class="lineNum">    1850 </span>            : static bool
<span class="lineNum">    1851 </span><span class="lineNoCov">          0 : advance_input_after_read_error (size_t nbytes)</span>
<span class="lineNum">    1852 </span>            : {
<span class="lineNum">    1853 </span><span class="lineNoCov">          0 :   if (! input_seekable)</span>
<span class="lineNum">    1854 </span>            :     {
<span class="lineNum">    1855 </span><span class="lineNoCov">          0 :       if (input_seek_errno == ESPIPE)</span>
<span class="lineNum">    1856 </span>            :         return true;
<span class="lineNum">    1857 </span><span class="lineNoCov">          0 :       errno = input_seek_errno;</span>
<span class="lineNum">    1858 </span>            :     }
<span class="lineNum">    1859 </span>            :   else
<span class="lineNum">    1860 </span>            :     {
<span class="lineNum">    1861 </span>            :       off_t offset;
<span class="lineNum">    1862 </span><span class="lineNoCov">          0 :       advance_input_offset (nbytes);</span>
<span class="lineNum">    1863 </span><span class="lineNoCov">          0 :       input_offset_overflow |= (OFF_T_MAX &lt; input_offset);</span>
<span class="lineNum">    1864 </span><span class="lineNoCov">          0 :       if (input_offset_overflow)</span>
<span class="lineNum">    1865 </span>            :         {
<span class="lineNum">    1866 </span><span class="lineNoCov">          0 :           error (0, 0, _(&quot;offset overflow while reading file %s&quot;),</span>
<span class="lineNum">    1867 </span>            :                  quoteaf (input_file));
<span class="lineNum">    1868 </span><span class="lineNoCov">          0 :           return false;</span>
<span class="lineNum">    1869 </span>            :         }
<span class="lineNum">    1870 </span><span class="lineNoCov">          0 :       offset = lseek (STDIN_FILENO, 0, SEEK_CUR);</span>
<span class="lineNum">    1871 </span><span class="lineNoCov">          0 :       if (0 &lt;= offset)</span>
<span class="lineNum">    1872 </span>            :         {
<span class="lineNum">    1873 </span>            :           off_t diff;
<span class="lineNum">    1874 </span><span class="lineNoCov">          0 :           if (offset == input_offset)</span>
<span class="lineNum">    1875 </span>            :             return true;
<span class="lineNum">    1876 </span><span class="lineNoCov">          0 :           diff = input_offset - offset;</span>
<span class="lineNum">    1877 </span><span class="lineNoCov">          0 :           if (! (0 &lt;= diff &amp;&amp; diff &lt;= nbytes) &amp;&amp; status_level != STATUS_NONE)</span>
<span class="lineNum">    1878 </span><span class="lineNoCov">          0 :             error (0, 0, _(&quot;warning: invalid file offset after failed read&quot;));</span>
<span class="lineNum">    1879 </span><span class="lineNoCov">          0 :           if (0 &lt;= skip_via_lseek (input_file, STDIN_FILENO, diff, SEEK_CUR))</span>
<span class="lineNum">    1880 </span>            :             return true;
<span class="lineNum">    1881 </span><span class="lineNoCov">          0 :           if (errno == 0)</span>
<span class="lineNum">    1882 </span><span class="lineNoCov">          0 :             error (0, 0, _(&quot;cannot work around kernel bug after all&quot;));</span>
<span class="lineNum">    1883 </span>            :         }
<span class="lineNum">    1884 </span>            :     }
<span class="lineNum">    1885 </span>            : 
<span class="lineNum">    1886 </span><span class="lineNoCov">          0 :   error (0, errno, _(&quot;%s: cannot seek&quot;), quotef (input_file));</span>
<span class="lineNum">    1887 </span><span class="lineNoCov">          0 :   return false;</span>
<span class="lineNum">    1888 </span>            : }
<span class="lineNum">    1889 </span>            : 
<span class="lineNum">    1890 </span>            : /* Copy NREAD bytes of BUF, with no conversions.  */
<a name="1891"><span class="lineNum">    1891 </span>            : </a>
<span class="lineNum">    1892 </span>            : static void
<span class="lineNum">    1893 </span><span class="lineNoCov">          0 : copy_simple (char const *buf, size_t nread)</span>
<span class="lineNum">    1894 </span>            : {
<span class="lineNum">    1895 </span><span class="lineNoCov">          0 :   const char *start = buf;      /* First uncopied char in BUF.  */</span>
<span class="lineNum">    1896 </span>            : 
<span class="lineNum">    1897 </span>            :   do
<span class="lineNum">    1898 </span>            :     {
<span class="lineNum">    1899 </span><span class="lineNoCov">          0 :       size_t nfree = MIN (nread, output_blocksize - oc);</span>
<span class="lineNum">    1900 </span>            : 
<span class="lineNum">    1901 </span><span class="lineNoCov">          0 :       memcpy (obuf + oc, start, nfree);</span>
<span class="lineNum">    1902 </span>            : 
<span class="lineNum">    1903 </span><span class="lineNoCov">          0 :       nread -= nfree;           /* Update the number of bytes left to copy. */</span>
<span class="lineNum">    1904 </span><span class="lineNoCov">          0 :       start += nfree;</span>
<span class="lineNum">    1905 </span><span class="lineNoCov">          0 :       oc += nfree;</span>
<span class="lineNum">    1906 </span><span class="lineNoCov">          0 :       if (oc &gt;= output_blocksize)</span>
<span class="lineNum">    1907 </span><span class="lineNoCov">          0 :         write_output ();</span>
<span class="lineNum">    1908 </span>            :     }
<span class="lineNum">    1909 </span><span class="lineNoCov">          0 :   while (nread != 0);</span>
<span class="lineNum">    1910 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    1911 </span>            : 
<span class="lineNum">    1912 </span>            : /* Copy NREAD bytes of BUF, doing conv=block
<span class="lineNum">    1913 </span>            :    (pad newline-terminated records to 'conversion_blocksize',
<span class="lineNum">    1914 </span>            :    replacing the newline with trailing spaces).  */
<a name="1915"><span class="lineNum">    1915 </span>            : </a>
<span class="lineNum">    1916 </span>            : static void
<span class="lineNum">    1917 </span><span class="lineNoCov">          0 : copy_with_block (char const *buf, size_t nread)</span>
<span class="lineNum">    1918 </span>            : {
<span class="lineNum">    1919 </span>            :   size_t i;
<span class="lineNum">    1920 </span>            : 
<span class="lineNum">    1921 </span><span class="lineNoCov">          0 :   for (i = nread; i; i--, buf++)</span>
<span class="lineNum">    1922 </span>            :     {
<span class="lineNum">    1923 </span><span class="lineNoCov">          0 :       if (*buf == newline_character)</span>
<span class="lineNum">    1924 </span>            :         {
<span class="lineNum">    1925 </span><span class="lineNoCov">          0 :           if (col &lt; conversion_blocksize)</span>
<span class="lineNum">    1926 </span>            :             {
<span class="lineNum">    1927 </span>            :               size_t j;
<span class="lineNum">    1928 </span><span class="lineNoCov">          0 :               for (j = col; j &lt; conversion_blocksize; j++)</span>
<span class="lineNum">    1929 </span><span class="lineNoCov">          0 :                 output_char (space_character);</span>
<span class="lineNum">    1930 </span>            :             }
<span class="lineNum">    1931 </span><span class="lineNoCov">          0 :           col = 0;</span>
<span class="lineNum">    1932 </span>            :         }
<span class="lineNum">    1933 </span>            :       else
<span class="lineNum">    1934 </span>            :         {
<span class="lineNum">    1935 </span><span class="lineNoCov">          0 :           if (col == conversion_blocksize)</span>
<span class="lineNum">    1936 </span><span class="lineNoCov">          0 :             r_truncate++;</span>
<span class="lineNum">    1937 </span><span class="lineNoCov">          0 :           else if (col &lt; conversion_blocksize)</span>
<span class="lineNum">    1938 </span><span class="lineNoCov">          0 :             output_char (*buf);</span>
<span class="lineNum">    1939 </span><span class="lineNoCov">          0 :           col++;</span>
<span class="lineNum">    1940 </span>            :         }
<span class="lineNum">    1941 </span>            :     }
<span class="lineNum">    1942 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    1943 </span>            : 
<span class="lineNum">    1944 </span>            : /* Copy NREAD bytes of BUF, doing conv=unblock
<span class="lineNum">    1945 </span>            :    (replace trailing spaces in 'conversion_blocksize'-sized records
<span class="lineNum">    1946 </span>            :    with a newline).  */
<a name="1947"><span class="lineNum">    1947 </span>            : </a>
<span class="lineNum">    1948 </span>            : static void
<span class="lineNum">    1949 </span><span class="lineNoCov">          0 : copy_with_unblock (char const *buf, size_t nread)</span>
<span class="lineNum">    1950 </span>            : {
<span class="lineNum">    1951 </span>            :   size_t i;
<span class="lineNum">    1952 </span>            :   char c;
<span class="lineNum">    1953 </span>            :   static size_t pending_spaces = 0;
<span class="lineNum">    1954 </span>            : 
<span class="lineNum">    1955 </span><span class="lineNoCov">          0 :   for (i = 0; i &lt; nread; i++)</span>
<span class="lineNum">    1956 </span>            :     {
<span class="lineNum">    1957 </span><span class="lineNoCov">          0 :       c = buf[i];</span>
<span class="lineNum">    1958 </span>            : 
<span class="lineNum">    1959 </span><span class="lineNoCov">          0 :       if (col++ &gt;= conversion_blocksize)</span>
<span class="lineNum">    1960 </span>            :         {
<span class="lineNum">    1961 </span><span class="lineNoCov">          0 :           col = pending_spaces = 0; /* Wipe out any pending spaces.  */</span>
<span class="lineNum">    1962 </span><span class="lineNoCov">          0 :           i--;                  /* Push the char back; get it later. */</span>
<span class="lineNum">    1963 </span><span class="lineNoCov">          0 :           output_char (newline_character);</span>
<span class="lineNum">    1964 </span>            :         }
<span class="lineNum">    1965 </span><span class="lineNoCov">          0 :       else if (c == space_character)</span>
<span class="lineNum">    1966 </span><span class="lineNoCov">          0 :         pending_spaces++;</span>
<span class="lineNum">    1967 </span>            :       else
<span class="lineNum">    1968 </span>            :         {
<span class="lineNum">    1969 </span>            :           /* 'c' is the character after a run of spaces that were not
<span class="lineNum">    1970 </span>            :              at the end of the conversion buffer.  Output them.  */
<span class="lineNum">    1971 </span><span class="lineNoCov">          0 :           while (pending_spaces)</span>
<span class="lineNum">    1972 </span>            :             {
<span class="lineNum">    1973 </span><span class="lineNoCov">          0 :               output_char (space_character);</span>
<span class="lineNum">    1974 </span><span class="lineNoCov">          0 :               --pending_spaces;</span>
<span class="lineNum">    1975 </span>            :             }
<span class="lineNum">    1976 </span><span class="lineNoCov">          0 :           output_char (c);</span>
<span class="lineNum">    1977 </span>            :         }
<span class="lineNum">    1978 </span>            :     }
<span class="lineNum">    1979 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    1980 </span>            : 
<span class="lineNum">    1981 </span>            : /* Set the file descriptor flags for FD that correspond to the nonzero bits
<span class="lineNum">    1982 </span>            :    in ADD_FLAGS.  The file's name is NAME.  */
<a name="1983"><span class="lineNum">    1983 </span>            : </a>
<span class="lineNum">    1984 </span>            : static void
<span class="lineNum">    1985 </span><span class="lineNoCov">          0 : set_fd_flags (int fd, int add_flags, char const *name)</span>
<span class="lineNum">    1986 </span>            : {
<span class="lineNum">    1987 </span>            :   /* Ignore file creation flags that are no-ops on file descriptors.  */
<span class="lineNum">    1988 </span><span class="lineNoCov">          0 :   add_flags &amp;= ~ (O_NOCTTY | O_NOFOLLOW);</span>
<span class="lineNum">    1989 </span>            : 
<span class="lineNum">    1990 </span><span class="lineNoCov">          0 :   if (add_flags)</span>
<span class="lineNum">    1991 </span>            :     {
<span class="lineNum">    1992 </span><span class="lineNoCov">          0 :       int old_flags = fcntl (fd, F_GETFL);</span>
<span class="lineNum">    1993 </span><span class="lineNoCov">          0 :       int new_flags = old_flags | add_flags;</span>
<span class="lineNum">    1994 </span><span class="lineNoCov">          0 :       bool ok = true;</span>
<span class="lineNum">    1995 </span><span class="lineNoCov">          0 :       if (old_flags &lt; 0)</span>
<span class="lineNum">    1996 </span>            :         ok = false;
<span class="lineNum">    1997 </span><span class="lineNoCov">          0 :       else if (old_flags != new_flags)</span>
<span class="lineNum">    1998 </span>            :         {
<span class="lineNum">    1999 </span><span class="lineNoCov">          0 :           if (new_flags &amp; (O_DIRECTORY | O_NOLINKS))</span>
<span class="lineNum">    2000 </span>            :             {
<span class="lineNum">    2001 </span>            :               /* NEW_FLAGS contains at least one file creation flag that
<span class="lineNum">    2002 </span>            :                  requires some checking of the open file descriptor.  */
<span class="lineNum">    2003 </span>            :               struct stat st;
<span class="lineNum">    2004 </span><span class="lineNoCov">          0 :               if (fstat (fd, &amp;st) != 0)</span>
<span class="lineNum">    2005 </span>            :                 ok = false;
<span class="lineNum">    2006 </span><span class="lineNoCov">          0 :               else if ((new_flags &amp; O_DIRECTORY) &amp;&amp; ! S_ISDIR (st.st_mode))</span>
<span class="lineNum">    2007 </span>            :                 {
<span class="lineNum">    2008 </span><span class="lineNoCov">          0 :                   errno = ENOTDIR;</span>
<span class="lineNum">    2009 </span><span class="lineNoCov">          0 :                   ok = false;</span>
<span class="lineNum">    2010 </span>            :                 }
<span class="lineNum">    2011 </span>            :               else if ((new_flags &amp; O_NOLINKS) &amp;&amp; 1 &lt; st.st_nlink)
<span class="lineNum">    2012 </span>            :                 {
<span class="lineNum">    2013 </span>            :                   errno = EMLINK;
<span class="lineNum">    2014 </span>            :                   ok = false;
<span class="lineNum">    2015 </span>            :                 }
<span class="lineNum">    2016 </span><span class="lineNoCov">          0 :               new_flags &amp;= ~ (O_DIRECTORY | O_NOLINKS);</span>
<span class="lineNum">    2017 </span>            :             }
<span class="lineNum">    2018 </span>            : 
<span class="lineNum">    2019 </span><span class="lineNoCov">          0 :           if (ok &amp;&amp; old_flags != new_flags</span>
<span class="lineNum">    2020 </span><span class="lineNoCov">          0 :               &amp;&amp; fcntl (fd, F_SETFL, new_flags) == -1)</span>
<span class="lineNum">    2021 </span><span class="lineNoCov">          0 :             ok = false;</span>
<span class="lineNum">    2022 </span>            :         }
<span class="lineNum">    2023 </span>            : 
<span class="lineNum">    2024 </span><span class="lineNoCov">          0 :       if (!ok)</span>
<span class="lineNum">    2025 </span><span class="lineNoCov">          0 :         error (EXIT_FAILURE, errno, _(&quot;setting flags for %s&quot;), quoteaf (name));</span>
<span class="lineNum">    2026 </span>            :     }
<span class="lineNum">    2027 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    2028 </span>            : 
<span class="lineNum">    2029 </span>            : /* The main loop.  */
<a name="2030"><span class="lineNum">    2030 </span>            : </a>
<span class="lineNum">    2031 </span>            : static int
<span class="lineNum">    2032 </span><span class="lineNoCov">          0 : dd_copy (void)</span>
<span class="lineNum">    2033 </span>            : {
<span class="lineNum">    2034 </span>            :   char *bufstart;               /* Input buffer. */
<span class="lineNum">    2035 </span>            :   ssize_t nread;                /* Bytes read in the current block.  */
<span class="lineNum">    2036 </span>            : 
<span class="lineNum">    2037 </span>            :   /* If nonzero, then the previously read block was partial and
<span class="lineNum">    2038 </span>            :      PARTREAD was its size.  */
<span class="lineNum">    2039 </span><span class="lineNoCov">          0 :   size_t partread = 0;</span>
<span class="lineNum">    2040 </span>            : 
<span class="lineNum">    2041 </span><span class="lineNoCov">          0 :   int exit_status = EXIT_SUCCESS;</span>
<span class="lineNum">    2042 </span>            :   size_t n_bytes_read;
<span class="lineNum">    2043 </span>            : 
<span class="lineNum">    2044 </span>            :   /* Leave at least one extra byte at the beginning and end of 'ibuf'
<span class="lineNum">    2045 </span>            :      for conv=swab, but keep the buffer address even.  But some peculiar
<span class="lineNum">    2046 </span>            :      device drivers work only with word-aligned buffers, so leave an
<span class="lineNum">    2047 </span>            :      extra two bytes.  */
<span class="lineNum">    2048 </span>            : 
<span class="lineNum">    2049 </span>            :   /* Some devices require alignment on a sector or page boundary
<span class="lineNum">    2050 </span>            :      (e.g. character disk devices).  Align the input buffer to a
<span class="lineNum">    2051 </span>            :      page boundary to cover all bases.  Note that due to the swab
<span class="lineNum">    2052 </span>            :      algorithm, we must have at least one byte in the page before
<span class="lineNum">    2053 </span>            :      the input buffer;  thus we allocate 2 pages of slop in the
<span class="lineNum">    2054 </span>            :      real buffer.  8k above the blocksize shouldn't bother anyone.
<span class="lineNum">    2055 </span>            : 
<span class="lineNum">    2056 </span>            :      The page alignment is necessary on any Linux kernel that supports
<span class="lineNum">    2057 </span>            :      either the SGI raw I/O patch or Steven Tweedies raw I/O patch.
<span class="lineNum">    2058 </span>            :      It is necessary when accessing raw (i.e., character special) disk
<span class="lineNum">    2059 </span>            :      devices on Unixware or other SVR4-derived system.  */
<span class="lineNum">    2060 </span>            : 
<span class="lineNum">    2061 </span><span class="lineNoCov">          0 :   if (skip_records != 0 || skip_bytes != 0)</span>
<span class="lineNum">    2062 </span>            :     {
<span class="lineNum">    2063 </span><span class="lineNoCov">          0 :       uintmax_t us_bytes = input_offset + (skip_records * input_blocksize)</span>
<span class="lineNum">    2064 </span><span class="lineNoCov">          0 :                            + skip_bytes;</span>
<span class="lineNum">    2065 </span><span class="lineNoCov">          0 :       uintmax_t us_blocks = skip (STDIN_FILENO, input_file,</span>
<span class="lineNum">    2066 </span>            :                                   skip_records, input_blocksize, &amp;skip_bytes);
<span class="lineNum">    2067 </span><span class="lineNoCov">          0 :       us_bytes -= input_offset;</span>
<span class="lineNum">    2068 </span>            : 
<span class="lineNum">    2069 </span>            :       /* POSIX doesn't say what to do when dd detects it has been
<span class="lineNum">    2070 </span>            :          asked to skip past EOF, so I assume it's non-fatal.
<span class="lineNum">    2071 </span>            :          There are 3 reasons why there might be unskipped blocks/bytes:
<span class="lineNum">    2072 </span>            :              1. file is too small
<span class="lineNum">    2073 </span>            :              2. pipe has not enough data
<span class="lineNum">    2074 </span>            :              3. partial reads  */
<span class="lineNum">    2075 </span><span class="lineNoCov">          0 :       if ((us_blocks || (!input_offset_overflow &amp;&amp; us_bytes))</span>
<span class="lineNum">    2076 </span><span class="lineNoCov">          0 :           &amp;&amp; status_level != STATUS_NONE)</span>
<span class="lineNum">    2077 </span>            :         {
<span class="lineNum">    2078 </span><span class="lineNoCov">          0 :           error (0, 0,</span>
<span class="lineNum">    2079 </span><span class="lineNoCov">          0 :                  _(&quot;%s: cannot skip to specified offset&quot;), quotef (input_file));</span>
<span class="lineNum">    2080 </span>            :         }
<span class="lineNum">    2081 </span>            :     }
<span class="lineNum">    2082 </span>            : 
<span class="lineNum">    2083 </span><span class="lineNoCov">          0 :   if (seek_records != 0 || seek_bytes != 0)</span>
<span class="lineNum">    2084 </span>            :     {
<span class="lineNum">    2085 </span><span class="lineNoCov">          0 :       size_t bytes = seek_bytes;</span>
<span class="lineNum">    2086 </span><span class="lineNoCov">          0 :       uintmax_t write_records = skip (STDOUT_FILENO, output_file,</span>
<span class="lineNum">    2087 </span>            :                                       seek_records, output_blocksize, &amp;bytes);
<span class="lineNum">    2088 </span>            : 
<span class="lineNum">    2089 </span><span class="lineNoCov">          0 :       if (write_records != 0 || bytes != 0)</span>
<span class="lineNum">    2090 </span>            :         {
<span class="lineNum">    2091 </span><span class="lineNoCov">          0 :           memset (obuf, 0, write_records ? output_blocksize : bytes);</span>
<span class="lineNum">    2092 </span>            : 
<span class="lineNum">    2093 </span>            :           do
<span class="lineNum">    2094 </span>            :             {
<span class="lineNum">    2095 </span><span class="lineNoCov">          0 :               size_t size = write_records ? output_blocksize : bytes;</span>
<span class="lineNum">    2096 </span><span class="lineNoCov">          0 :               if (iwrite (STDOUT_FILENO, obuf, size) != size)</span>
<span class="lineNum">    2097 </span>            :                 {
<span class="lineNum">    2098 </span><span class="lineNoCov">          0 :                   error (0, errno, _(&quot;writing to %s&quot;), quoteaf (output_file));</span>
<span class="lineNum">    2099 </span><span class="lineNoCov">          0 :                   quit (EXIT_FAILURE);</span>
<span class="lineNum">    2100 </span>            :                 }
<span class="lineNum">    2101 </span>            : 
<span class="lineNum">    2102 </span><span class="lineNoCov">          0 :               if (write_records != 0)</span>
<span class="lineNum">    2103 </span><span class="lineNoCov">          0 :                 write_records--;</span>
<span class="lineNum">    2104 </span>            :               else
<span class="lineNum">    2105 </span><span class="lineNoCov">          0 :                 bytes = 0;</span>
<span class="lineNum">    2106 </span>            :             }
<span class="lineNum">    2107 </span><span class="lineNoCov">          0 :           while (write_records || bytes);</span>
<span class="lineNum">    2108 </span>            :         }
<span class="lineNum">    2109 </span>            :     }
<span class="lineNum">    2110 </span>            : 
<span class="lineNum">    2111 </span><span class="lineNoCov">          0 :   if (max_records == 0 &amp;&amp; max_bytes == 0)</span>
<span class="lineNum">    2112 </span>            :     return exit_status;
<span class="lineNum">    2113 </span>            : 
<span class="lineNum">    2114 </span><span class="lineNoCov">          0 :   alloc_ibuf ();</span>
<span class="lineNum">    2115 </span><span class="lineNoCov">          0 :   alloc_obuf ();</span>
<span class="lineNum">    2116 </span>            : 
<span class="lineNum">    2117 </span>            :   while (1)
<span class="lineNum">    2118 </span>            :     {
<span class="lineNum">    2119 </span><span class="lineNoCov">          0 :       if (status_level == STATUS_PROGRESS)</span>
<span class="lineNum">    2120 </span>            :         {
<span class="lineNum">    2121 </span><span class="lineNoCov">          0 :           xtime_t progress_time = gethrxtime ();</span>
<span class="lineNum">    2122 </span><span class="lineNoCov">          0 :           if (next_time &lt;= progress_time)</span>
<span class="lineNum">    2123 </span>            :             {
<span class="lineNum">    2124 </span><span class="lineNoCov">          0 :               print_xfer_stats (progress_time);</span>
<span class="lineNum">    2125 </span><span class="lineNoCov">          0 :               next_time += XTIME_PRECISION;</span>
<span class="lineNum">    2126 </span>            :             }
<span class="lineNum">    2127 </span>            :         }
<span class="lineNum">    2128 </span>            : 
<span class="lineNum">    2129 </span><span class="lineNoCov">          0 :       if (r_partial + r_full &gt;= max_records + !!max_bytes)</span>
<span class="lineNum">    2130 </span>            :         break;
<span class="lineNum">    2131 </span>            : 
<span class="lineNum">    2132 </span>            :       /* Zero the buffer before reading, so that if we get a read error,
<span class="lineNum">    2133 </span>            :          whatever data we are able to read is followed by zeros.
<span class="lineNum">    2134 </span>            :          This minimizes data loss. */
<span class="lineNum">    2135 </span><span class="lineNoCov">          0 :       if ((conversions_mask &amp; C_SYNC) &amp;&amp; (conversions_mask &amp; C_NOERROR))</span>
<span class="lineNum">    2136 </span><span class="lineNoCov">          0 :         memset (ibuf,</span>
<span class="lineNum">    2137 </span><span class="lineNoCov">          0 :                 (conversions_mask &amp; (C_BLOCK | C_UNBLOCK)) ? ' ' : '\0',</span>
<span class="lineNum">    2138 </span>            :                 input_blocksize);
<span class="lineNum">    2139 </span>            : 
<span class="lineNum">    2140 </span><span class="lineNoCov">          0 :       if (r_partial + r_full &gt;= max_records)</span>
<span class="lineNum">    2141 </span><span class="lineNoCov">          0 :         nread = iread_fnc (STDIN_FILENO, ibuf, max_bytes);</span>
<span class="lineNum">    2142 </span>            :       else
<span class="lineNum">    2143 </span><span class="lineNoCov">          0 :         nread = iread_fnc (STDIN_FILENO, ibuf, input_blocksize);</span>
<span class="lineNum">    2144 </span>            : 
<span class="lineNum">    2145 </span><span class="lineNoCov">          0 :       if (nread &gt;= 0 &amp;&amp; i_nocache)</span>
<span class="lineNum">    2146 </span><span class="lineNoCov">          0 :         invalidate_cache (STDIN_FILENO, nread);</span>
<span class="lineNum">    2147 </span>            : 
<span class="lineNum">    2148 </span><span class="lineNoCov">          0 :       if (nread == 0)</span>
<span class="lineNum">    2149 </span>            :         break;                  /* EOF.  */
<span class="lineNum">    2150 </span>            : 
<span class="lineNum">    2151 </span><span class="lineNoCov">          0 :       if (nread &lt; 0)</span>
<span class="lineNum">    2152 </span>            :         {
<span class="lineNum">    2153 </span><span class="lineNoCov">          0 :           if (!(conversions_mask &amp; C_NOERROR) || status_level != STATUS_NONE)</span>
<span class="lineNum">    2154 </span><span class="lineNoCov">          0 :             error (0, errno, _(&quot;error reading %s&quot;), quoteaf (input_file));</span>
<span class="lineNum">    2155 </span>            : 
<span class="lineNum">    2156 </span><span class="lineNoCov">          0 :           if (conversions_mask &amp; C_NOERROR)</span>
<span class="lineNum">    2157 </span>            :             {
<span class="lineNum">    2158 </span><span class="lineNoCov">          0 :               print_stats ();</span>
<span class="lineNum">    2159 </span><span class="lineNoCov">          0 :               size_t bad_portion = input_blocksize - partread;</span>
<span class="lineNum">    2160 </span>            : 
<span class="lineNum">    2161 </span>            :               /* We already know this data is not cached,
<span class="lineNum">    2162 </span>            :                  but call this so that correct offsets are maintained.  */
<span class="lineNum">    2163 </span><span class="lineNoCov">          0 :               invalidate_cache (STDIN_FILENO, bad_portion);</span>
<span class="lineNum">    2164 </span>            : 
<span class="lineNum">    2165 </span>            :               /* Seek past the bad block if possible. */
<span class="lineNum">    2166 </span><span class="lineNoCov">          0 :               if (!advance_input_after_read_error (bad_portion))</span>
<span class="lineNum">    2167 </span>            :                 {
<span class="lineNum">    2168 </span><span class="lineNoCov">          0 :                   exit_status = EXIT_FAILURE;</span>
<span class="lineNum">    2169 </span>            : 
<span class="lineNum">    2170 </span>            :                   /* Suppress duplicate diagnostics.  */
<span class="lineNum">    2171 </span><span class="lineNoCov">          0 :                   input_seekable = false;</span>
<span class="lineNum">    2172 </span><span class="lineNoCov">          0 :                   input_seek_errno = ESPIPE;</span>
<span class="lineNum">    2173 </span>            :                 }
<span class="lineNum">    2174 </span><span class="lineNoCov">          0 :               if ((conversions_mask &amp; C_SYNC) &amp;&amp; !partread)</span>
<span class="lineNum">    2175 </span>            :                 /* Replace the missing input with null bytes and
<span class="lineNum">    2176 </span>            :                    proceed normally.  */
<span class="lineNum">    2177 </span>            :                 nread = 0;
<span class="lineNum">    2178 </span>            :               else
<span class="lineNum">    2179 </span><span class="lineNoCov">          0 :                 continue;</span>
<span class="lineNum">    2180 </span>            :             }
<span class="lineNum">    2181 </span>            :           else
<span class="lineNum">    2182 </span>            :             {
<span class="lineNum">    2183 </span>            :               /* Write any partial block. */
<span class="lineNum">    2184 </span>            :               exit_status = EXIT_FAILURE;
<span class="lineNum">    2185 </span>            :               break;
<span class="lineNum">    2186 </span>            :             }
<span class="lineNum">    2187 </span>            :         }
<span class="lineNum">    2188 </span>            : 
<span class="lineNum">    2189 </span><span class="lineNoCov">          0 :       n_bytes_read = nread;</span>
<span class="lineNum">    2190 </span><span class="lineNoCov">          0 :       advance_input_offset (nread);</span>
<span class="lineNum">    2191 </span>            : 
<span class="lineNum">    2192 </span><span class="lineNoCov">          0 :       if (n_bytes_read &lt; input_blocksize)</span>
<span class="lineNum">    2193 </span>            :         {
<span class="lineNum">    2194 </span><span class="lineNoCov">          0 :           r_partial++;</span>
<span class="lineNum">    2195 </span><span class="lineNoCov">          0 :           partread = n_bytes_read;</span>
<span class="lineNum">    2196 </span><span class="lineNoCov">          0 :           if (conversions_mask &amp; C_SYNC)</span>
<span class="lineNum">    2197 </span>            :             {
<span class="lineNum">    2198 </span><span class="lineNoCov">          0 :               if (!(conversions_mask &amp; C_NOERROR))</span>
<span class="lineNum">    2199 </span>            :                 /* If C_NOERROR, we zeroed the block before reading. */
<span class="lineNum">    2200 </span><span class="lineNoCov">          0 :                 memset (ibuf + n_bytes_read,</span>
<span class="lineNum">    2201 </span><span class="lineNoCov">          0 :                         (conversions_mask &amp; (C_BLOCK | C_UNBLOCK)) ? ' ' : '\0',</span>
<span class="lineNum">    2202 </span>            :                         input_blocksize - n_bytes_read);
<span class="lineNum">    2203 </span><span class="lineNoCov">          0 :               n_bytes_read = input_blocksize;</span>
<span class="lineNum">    2204 </span>            :             }
<span class="lineNum">    2205 </span>            :         }
<span class="lineNum">    2206 </span>            :       else
<span class="lineNum">    2207 </span>            :         {
<span class="lineNum">    2208 </span><span class="lineNoCov">          0 :           r_full++;</span>
<span class="lineNum">    2209 </span><span class="lineNoCov">          0 :           partread = 0;</span>
<span class="lineNum">    2210 </span>            :         }
<span class="lineNum">    2211 </span>            : 
<span class="lineNum">    2212 </span><span class="lineNoCov">          0 :       if (ibuf == obuf)         /* If not C_TWOBUFS. */</span>
<span class="lineNum">    2213 </span>            :         {
<span class="lineNum">    2214 </span><span class="lineNoCov">          0 :           size_t nwritten = iwrite (STDOUT_FILENO, obuf, n_bytes_read);</span>
<span class="lineNum">    2215 </span><span class="lineNoCov">          0 :           w_bytes += nwritten;</span>
<span class="lineNum">    2216 </span><span class="lineNoCov">          0 :           if (nwritten != n_bytes_read)</span>
<span class="lineNum">    2217 </span>            :             {
<span class="lineNum">    2218 </span><span class="lineNoCov">          0 :               error (0, errno, _(&quot;error writing %s&quot;), quoteaf (output_file));</span>
<span class="lineNum">    2219 </span><span class="lineNoCov">          0 :               return EXIT_FAILURE;</span>
<span class="lineNum">    2220 </span>            :             }
<span class="lineNum">    2221 </span><span class="lineNoCov">          0 :           else if (n_bytes_read == input_blocksize)</span>
<span class="lineNum">    2222 </span><span class="lineNoCov">          0 :             w_full++;</span>
<span class="lineNum">    2223 </span>            :           else
<span class="lineNum">    2224 </span><span class="lineNoCov">          0 :             w_partial++;</span>
<span class="lineNum">    2225 </span><span class="lineNoCov">          0 :           continue;</span>
<span class="lineNum">    2226 </span>            :         }
<span class="lineNum">    2227 </span>            : 
<span class="lineNum">    2228 </span>            :       /* Do any translations on the whole buffer at once.  */
<span class="lineNum">    2229 </span>            : 
<span class="lineNum">    2230 </span><span class="lineNoCov">          0 :       if (translation_needed)</span>
<span class="lineNum">    2231 </span><span class="lineNoCov">          0 :         translate_buffer (ibuf, n_bytes_read);</span>
<span class="lineNum">    2232 </span>            : 
<span class="lineNum">    2233 </span><span class="lineNoCov">          0 :       if (conversions_mask &amp; C_SWAB)</span>
<span class="lineNum">    2234 </span><span class="lineNoCov">          0 :         bufstart = swab_buffer (ibuf, &amp;n_bytes_read);</span>
<span class="lineNum">    2235 </span>            :       else
<span class="lineNum">    2236 </span>            :         bufstart = ibuf;
<span class="lineNum">    2237 </span>            : 
<span class="lineNum">    2238 </span><span class="lineNoCov">          0 :       if (conversions_mask &amp; C_BLOCK)</span>
<span class="lineNum">    2239 </span><span class="lineNoCov">          0 :         copy_with_block (bufstart, n_bytes_read);</span>
<span class="lineNum">    2240 </span><span class="lineNoCov">          0 :       else if (conversions_mask &amp; C_UNBLOCK)</span>
<span class="lineNum">    2241 </span><span class="lineNoCov">          0 :         copy_with_unblock (bufstart, n_bytes_read);</span>
<span class="lineNum">    2242 </span>            :       else
<span class="lineNum">    2243 </span><span class="lineNoCov">          0 :         copy_simple (bufstart, n_bytes_read);</span>
<span class="lineNum">    2244 </span>            :     }
<span class="lineNum">    2245 </span>            : 
<span class="lineNum">    2246 </span>            :   /* If we have a char left as a result of conv=swab, output it.  */
<span class="lineNum">    2247 </span><span class="lineNoCov">          0 :   if (char_is_saved)</span>
<span class="lineNum">    2248 </span>            :     {
<span class="lineNum">    2249 </span><span class="lineNoCov">          0 :       if (conversions_mask &amp; C_BLOCK)</span>
<span class="lineNum">    2250 </span><span class="lineNoCov">          0 :         copy_with_block (&amp;saved_char, 1);</span>
<span class="lineNum">    2251 </span><span class="lineNoCov">          0 :       else if (conversions_mask &amp; C_UNBLOCK)</span>
<span class="lineNum">    2252 </span><span class="lineNoCov">          0 :         copy_with_unblock (&amp;saved_char, 1);</span>
<span class="lineNum">    2253 </span>            :       else
<span class="lineNum">    2254 </span><span class="lineNoCov">          0 :         output_char (saved_char);</span>
<span class="lineNum">    2255 </span>            :     }
<span class="lineNum">    2256 </span>            : 
<span class="lineNum">    2257 </span><span class="lineNoCov">          0 :   if ((conversions_mask &amp; C_BLOCK) &amp;&amp; col &gt; 0)</span>
<span class="lineNum">    2258 </span>            :     {
<span class="lineNum">    2259 </span>            :       /* If the final input line didn't end with a '\n', pad
<span class="lineNum">    2260 </span>            :          the output block to 'conversion_blocksize' chars.  */
<span class="lineNum">    2261 </span>            :       size_t i;
<span class="lineNum">    2262 </span><span class="lineNoCov">          0 :       for (i = col; i &lt; conversion_blocksize; i++)</span>
<span class="lineNum">    2263 </span><span class="lineNoCov">          0 :         output_char (space_character);</span>
<span class="lineNum">    2264 </span>            :     }
<span class="lineNum">    2265 </span>            : 
<span class="lineNum">    2266 </span><span class="lineNoCov">          0 :   if (col &amp;&amp; (conversions_mask &amp; C_UNBLOCK))</span>
<span class="lineNum">    2267 </span>            :     {
<span class="lineNum">    2268 </span>            :       /* If there was any output, add a final '\n'.  */
<span class="lineNum">    2269 </span><span class="lineNoCov">          0 :       output_char (newline_character);</span>
<span class="lineNum">    2270 </span>            :     }
<span class="lineNum">    2271 </span>            : 
<span class="lineNum">    2272 </span>            :   /* Write out the last block. */
<span class="lineNum">    2273 </span><span class="lineNoCov">          0 :   if (oc != 0)</span>
<span class="lineNum">    2274 </span>            :     {
<span class="lineNum">    2275 </span><span class="lineNoCov">          0 :       size_t nwritten = iwrite (STDOUT_FILENO, obuf, oc);</span>
<span class="lineNum">    2276 </span><span class="lineNoCov">          0 :       w_bytes += nwritten;</span>
<span class="lineNum">    2277 </span><span class="lineNoCov">          0 :       if (nwritten != 0)</span>
<span class="lineNum">    2278 </span><span class="lineNoCov">          0 :         w_partial++;</span>
<span class="lineNum">    2279 </span><span class="lineNoCov">          0 :       if (nwritten != oc)</span>
<span class="lineNum">    2280 </span>            :         {
<span class="lineNum">    2281 </span><span class="lineNoCov">          0 :           error (0, errno, _(&quot;error writing %s&quot;), quoteaf (output_file));</span>
<span class="lineNum">    2282 </span><span class="lineNoCov">          0 :           return EXIT_FAILURE;</span>
<span class="lineNum">    2283 </span>            :         }
<span class="lineNum">    2284 </span>            :     }
<span class="lineNum">    2285 </span>            : 
<span class="lineNum">    2286 </span>            :   /* If the last write was converted to a seek, then for a regular file
<span class="lineNum">    2287 </span>            :      or shared memory object, ftruncate to extend the size.  */
<span class="lineNum">    2288 </span><span class="lineNoCov">          0 :   if (final_op_was_seek)</span>
<span class="lineNum">    2289 </span>            :     {
<span class="lineNum">    2290 </span>            :       struct stat stdout_stat;
<span class="lineNum">    2291 </span><span class="lineNoCov">          0 :       if (fstat (STDOUT_FILENO, &amp;stdout_stat) != 0)</span>
<span class="lineNum">    2292 </span>            :         {
<span class="lineNum">    2293 </span><span class="lineNoCov">          0 :           error (0, errno, _(&quot;cannot fstat %s&quot;), quoteaf (output_file));</span>
<span class="lineNum">    2294 </span><span class="lineNoCov">          0 :           return EXIT_FAILURE;</span>
<span class="lineNum">    2295 </span>            :         }
<span class="lineNum">    2296 </span><span class="lineNoCov">          0 :       if (S_ISREG (stdout_stat.st_mode) || S_TYPEISSHM (&amp;stdout_stat))</span>
<span class="lineNum">    2297 </span>            :         {
<span class="lineNum">    2298 </span><span class="lineNoCov">          0 :           off_t output_offset = lseek (STDOUT_FILENO, 0, SEEK_CUR);</span>
<span class="lineNum">    2299 </span><span class="lineNoCov">          0 :           if (0 &lt;= output_offset &amp;&amp; stdout_stat.st_size &lt; output_offset)</span>
<span class="lineNum">    2300 </span>            :             {
<span class="lineNum">    2301 </span><span class="lineNoCov">          0 :               if (iftruncate (STDOUT_FILENO, output_offset) != 0)</span>
<span class="lineNum">    2302 </span>            :                 {
<span class="lineNum">    2303 </span><span class="lineNoCov">          0 :                   error (0, errno,</span>
<span class="lineNum">    2304 </span><span class="lineNoCov">          0 :                          _(&quot;failed to truncate to %&quot; PRIdMAX &quot; bytes&quot;</span>
<span class="lineNum">    2305 </span>            :                            &quot; in output file %s&quot;),
<span class="lineNum">    2306 </span>            :                          (intmax_t) output_offset, quoteaf (output_file));
<span class="lineNum">    2307 </span><span class="lineNoCov">          0 :                   return EXIT_FAILURE;</span>
<span class="lineNum">    2308 </span>            :                 }
<span class="lineNum">    2309 </span>            :             }
<span class="lineNum">    2310 </span>            :         }
<span class="lineNum">    2311 </span>            :     }
<span class="lineNum">    2312 </span>            : 
<span class="lineNum">    2313 </span><span class="lineNoCov">          0 :   if ((conversions_mask &amp; C_FDATASYNC) &amp;&amp; fdatasync (STDOUT_FILENO) != 0)</span>
<span class="lineNum">    2314 </span>            :     {
<span class="lineNum">    2315 </span><span class="lineNoCov">          0 :       if (errno != ENOSYS &amp;&amp; errno != EINVAL)</span>
<span class="lineNum">    2316 </span>            :         {
<span class="lineNum">    2317 </span><span class="lineNoCov">          0 :           error (0, errno, _(&quot;fdatasync failed for %s&quot;), quoteaf (output_file));</span>
<span class="lineNum">    2318 </span><span class="lineNoCov">          0 :           exit_status = EXIT_FAILURE;</span>
<span class="lineNum">    2319 </span>            :         }
<span class="lineNum">    2320 </span><span class="lineNoCov">          0 :       conversions_mask |= C_FSYNC;</span>
<span class="lineNum">    2321 </span>            :     }
<span class="lineNum">    2322 </span>            : 
<span class="lineNum">    2323 </span><span class="lineNoCov">          0 :   if (conversions_mask &amp; C_FSYNC)</span>
<span class="lineNum">    2324 </span><span class="lineNoCov">          0 :     while (fsync (STDOUT_FILENO) != 0)</span>
<span class="lineNum">    2325 </span><span class="lineNoCov">          0 :       if (errno != EINTR)</span>
<span class="lineNum">    2326 </span>            :         {
<span class="lineNum">    2327 </span><span class="lineNoCov">          0 :           error (0, errno, _(&quot;fsync failed for %s&quot;), quoteaf (output_file));</span>
<span class="lineNum">    2328 </span><span class="lineNoCov">          0 :           return EXIT_FAILURE;</span>
<span class="lineNum">    2329 </span>            :         }
<span class="lineNum">    2330 </span>            : 
<span class="lineNum">    2331 </span>            :   return exit_status;
<span class="lineNum">    2332 </span>            : }
<a name="2333"><span class="lineNum">    2333 </span>            : </a>
<span class="lineNum">    2334 </span>            : int
<span class="lineNum">    2335 </span><span class="lineNoCov">          0 : main (int argc, char **argv)</span>
<span class="lineNum">    2336 </span>            : {
<span class="lineNum">    2337 </span>            :   int i;
<span class="lineNum">    2338 </span>            :   int exit_status;
<span class="lineNum">    2339 </span>            :   off_t offset;
<span class="lineNum">    2340 </span>            : 
<span class="lineNum">    2341 </span><span class="lineNoCov">          0 :   install_signal_handlers ();</span>
<span class="lineNum">    2342 </span>            : 
<span class="lineNum">    2343 </span>            :   initialize_main (&amp;argc, &amp;argv);
<span class="lineNum">    2344 </span><span class="lineNoCov">          0 :   set_program_name (argv[0]);</span>
<span class="lineNum">    2345 </span><span class="lineNoCov">          0 :   setlocale (LC_ALL, &quot;&quot;);</span>
<span class="lineNum">    2346 </span><span class="lineNoCov">          0 :   bindtextdomain (PACKAGE, LOCALEDIR);</span>
<span class="lineNum">    2347 </span><span class="lineNoCov">          0 :   textdomain (PACKAGE);</span>
<span class="lineNum">    2348 </span>            : 
<span class="lineNum">    2349 </span>            :   /* Arrange to close stdout if parse_long_options exits.  */
<span class="lineNum">    2350 </span><span class="lineNoCov">          0 :   atexit (maybe_close_stdout);</span>
<span class="lineNum">    2351 </span>            : 
<span class="lineNum">    2352 </span><span class="lineNoCov">          0 :   page_size = getpagesize ();</span>
<span class="lineNum">    2353 </span>            : 
<span class="lineNum">    2354 </span><span class="lineNoCov">          0 :   parse_long_options (argc, argv, PROGRAM_NAME, PACKAGE, Version,</span>
<span class="lineNum">    2355 </span>            :                       usage, AUTHORS, (char const *) NULL);
<span class="lineNum">    2356 </span><span class="lineNoCov">          0 :   close_stdout_required = false;</span>
<span class="lineNum">    2357 </span>            : 
<span class="lineNum">    2358 </span><span class="lineNoCov">          0 :   if (getopt_long (argc, argv, &quot;&quot;, NULL, NULL) != -1)</span>
<span class="lineNum">    2359 </span><span class="lineNoCov">          0 :     usage (EXIT_FAILURE);</span>
<span class="lineNum">    2360 </span>            : 
<span class="lineNum">    2361 </span>            :   /* Initialize translation table to identity translation. */
<span class="lineNum">    2362 </span><span class="lineNoCov">          0 :   for (i = 0; i &lt; 256; i++)</span>
<span class="lineNum">    2363 </span><span class="lineNoCov">          0 :     trans_table[i] = i;</span>
<span class="lineNum">    2364 </span>            : 
<span class="lineNum">    2365 </span>            :   /* Decode arguments. */
<span class="lineNum">    2366 </span><span class="lineNoCov">          0 :   scanargs (argc, argv);</span>
<span class="lineNum">    2367 </span>            : 
<span class="lineNum">    2368 </span><span class="lineNoCov">          0 :   apply_translations ();</span>
<span class="lineNum">    2369 </span>            : 
<span class="lineNum">    2370 </span><span class="lineNoCov">          0 :   if (input_file == NULL)</span>
<span class="lineNum">    2371 </span>            :     {
<span class="lineNum">    2372 </span><span class="lineNoCov">          0 :       input_file = _(&quot;standard input&quot;);</span>
<span class="lineNum">    2373 </span><span class="lineNoCov">          0 :       set_fd_flags (STDIN_FILENO, input_flags, input_file);</span>
<span class="lineNum">    2374 </span>            :     }
<span class="lineNum">    2375 </span>            :   else
<span class="lineNum">    2376 </span>            :     {
<span class="lineNum">    2377 </span><span class="lineNoCov">          0 :       if (ifd_reopen (STDIN_FILENO, input_file, O_RDONLY | input_flags, 0) &lt; 0)</span>
<span class="lineNum">    2378 </span><span class="lineNoCov">          0 :         error (EXIT_FAILURE, errno, _(&quot;failed to open %s&quot;),</span>
<span class="lineNum">    2379 </span>            :                quoteaf (input_file));
<span class="lineNum">    2380 </span>            :     }
<span class="lineNum">    2381 </span>            : 
<span class="lineNum">    2382 </span><span class="lineNoCov">          0 :   offset = lseek (STDIN_FILENO, 0, SEEK_CUR);</span>
<span class="lineNum">    2383 </span><span class="lineNoCov">          0 :   input_seekable = (0 &lt;= offset);</span>
<span class="lineNum">    2384 </span><span class="lineNoCov">          0 :   input_offset = MAX (0, offset);</span>
<span class="lineNum">    2385 </span><span class="lineNoCov">          0 :   input_seek_errno = errno;</span>
<span class="lineNum">    2386 </span>            : 
<span class="lineNum">    2387 </span><span class="lineNoCov">          0 :   if (output_file == NULL)</span>
<span class="lineNum">    2388 </span>            :     {
<span class="lineNum">    2389 </span><span class="lineNoCov">          0 :       output_file = _(&quot;standard output&quot;);</span>
<span class="lineNum">    2390 </span><span class="lineNoCov">          0 :       set_fd_flags (STDOUT_FILENO, output_flags, output_file);</span>
<span class="lineNum">    2391 </span>            :     }
<span class="lineNum">    2392 </span>            :   else
<span class="lineNum">    2393 </span>            :     {
<span class="lineNum">    2394 </span><span class="lineNoCov">          0 :       mode_t perms = MODE_RW_UGO;</span>
<span class="lineNum">    2395 </span><span class="lineNoCov">          0 :       int opts</span>
<span class="lineNum">    2396 </span>            :         = (output_flags
<span class="lineNum">    2397 </span><span class="lineNoCov">          0 :            | (conversions_mask &amp; C_NOCREAT ? 0 : O_CREAT)</span>
<span class="lineNum">    2398 </span><span class="lineNoCov">          0 :            | (conversions_mask &amp; C_EXCL ? O_EXCL : 0)</span>
<span class="lineNum">    2399 </span><span class="lineNoCov">          0 :            | (seek_records || (conversions_mask &amp; C_NOTRUNC) ? 0 : O_TRUNC));</span>
<span class="lineNum">    2400 </span>            : 
<span class="lineNum">    2401 </span>            :       /* Open the output file with *read* access only if we might
<span class="lineNum">    2402 </span>            :          need to read to satisfy a 'seek=' request.  If we can't read
<span class="lineNum">    2403 </span>            :          the file, go ahead with write-only access; it might work.  */
<span class="lineNum">    2404 </span><span class="lineNoCov">          0 :       if ((! seek_records</span>
<span class="lineNum">    2405 </span><span class="lineNoCov">          0 :            || ifd_reopen (STDOUT_FILENO, output_file, O_RDWR | opts, perms) &lt; 0)</span>
<span class="lineNum">    2406 </span><span class="lineNoCov">          0 :           &amp;&amp; (ifd_reopen (STDOUT_FILENO, output_file, O_WRONLY | opts, perms)</span>
<span class="lineNum">    2407 </span>            :               &lt; 0))
<span class="lineNum">    2408 </span><span class="lineNoCov">          0 :         error (EXIT_FAILURE, errno, _(&quot;failed to open %s&quot;),</span>
<span class="lineNum">    2409 </span>            :                quoteaf (output_file));
<span class="lineNum">    2410 </span>            : 
<span class="lineNum">    2411 </span><span class="lineNoCov">          0 :       if (seek_records != 0 &amp;&amp; !(conversions_mask &amp; C_NOTRUNC))</span>
<span class="lineNum">    2412 </span>            :         {
<span class="lineNum">    2413 </span><span class="lineNoCov">          0 :           uintmax_t size = seek_records * output_blocksize + seek_bytes;</span>
<span class="lineNum">    2414 </span><span class="lineNoCov">          0 :           unsigned long int obs = output_blocksize;</span>
<span class="lineNum">    2415 </span>            : 
<span class="lineNum">    2416 </span><span class="lineNoCov">          0 :           if (OFF_T_MAX / output_blocksize &lt; seek_records)</span>
<span class="lineNum">    2417 </span><span class="lineNoCov">          0 :             error (EXIT_FAILURE, 0,</span>
<span class="lineNum">    2418 </span><span class="lineNoCov">          0 :                    _(&quot;offset too large: &quot;</span>
<span class="lineNum">    2419 </span>            :                      &quot;cannot truncate to a length of seek=%&quot;PRIuMAX&quot;&quot;
<span class="lineNum">    2420 </span>            :                      &quot; (%lu-byte) blocks&quot;),
<span class="lineNum">    2421 </span>            :                    seek_records, obs);
<span class="lineNum">    2422 </span>            : 
<span class="lineNum">    2423 </span><span class="lineNoCov">          0 :           if (iftruncate (STDOUT_FILENO, size) != 0)</span>
<span class="lineNum">    2424 </span>            :             {
<span class="lineNum">    2425 </span>            :               /* Complain only when ftruncate fails on a regular file, a
<span class="lineNum">    2426 </span>            :                  directory, or a shared memory object, as POSIX 1003.1-2004
<span class="lineNum">    2427 </span>            :                  specifies ftruncate's behavior only for these file types.
<span class="lineNum">    2428 </span>            :                  For example, do not complain when Linux kernel 2.4 ftruncate
<span class="lineNum">    2429 </span>            :                  fails on /dev/fd0.  */
<span class="lineNum">    2430 </span><span class="lineNoCov">          0 :               int ftruncate_errno = errno;</span>
<span class="lineNum">    2431 </span>            :               struct stat stdout_stat;
<span class="lineNum">    2432 </span><span class="lineNoCov">          0 :               if (fstat (STDOUT_FILENO, &amp;stdout_stat) != 0)</span>
<span class="lineNum">    2433 </span><span class="lineNoCov">          0 :                 error (EXIT_FAILURE, errno, _(&quot;cannot fstat %s&quot;),</span>
<span class="lineNum">    2434 </span>            :                        quoteaf (output_file));
<span class="lineNum">    2435 </span><span class="lineNoCov">          0 :               if (S_ISREG (stdout_stat.st_mode)</span>
<span class="lineNum">    2436 </span><span class="lineNoCov">          0 :                   || S_ISDIR (stdout_stat.st_mode)</span>
<span class="lineNum">    2437 </span>            :                   || S_TYPEISSHM (&amp;stdout_stat))
<span class="lineNum">    2438 </span><span class="lineNoCov">          0 :                 error (EXIT_FAILURE, ftruncate_errno,</span>
<span class="lineNum">    2439 </span><span class="lineNoCov">          0 :                        _(&quot;failed to truncate to %&quot;PRIuMAX&quot; bytes&quot;</span>
<span class="lineNum">    2440 </span>            :                          &quot; in output file %s&quot;),
<span class="lineNum">    2441 </span>            :                        size, quoteaf (output_file));
<span class="lineNum">    2442 </span>            :             }
<span class="lineNum">    2443 </span>            :         }
<span class="lineNum">    2444 </span>            :     }
<span class="lineNum">    2445 </span>            : 
<span class="lineNum">    2446 </span><span class="lineNoCov">          0 :   start_time = gethrxtime ();</span>
<span class="lineNum">    2447 </span><span class="lineNoCov">          0 :   next_time = start_time + XTIME_PRECISION;</span>
<span class="lineNum">    2448 </span>            : 
<span class="lineNum">    2449 </span><span class="lineNoCov">          0 :   exit_status = dd_copy ();</span>
<span class="lineNum">    2450 </span>            : 
<span class="lineNum">    2451 </span><span class="lineNoCov">          0 :   if (max_records == 0 &amp;&amp; max_bytes == 0)</span>
<span class="lineNum">    2452 </span>            :     {
<span class="lineNum">    2453 </span>            :       /* Special case to invalidate cache to end of file.  */
<span class="lineNum">    2454 </span><span class="lineNoCov">          0 :       if (i_nocache &amp;&amp; !invalidate_cache (STDIN_FILENO, 0))</span>
<span class="lineNum">    2455 </span>            :         {
<span class="lineNum">    2456 </span><span class="lineNoCov">          0 :           error (0, errno, _(&quot;failed to discard cache for: %s&quot;),</span>
<span class="lineNum">    2457 </span>            :                  quotef (input_file));
<span class="lineNum">    2458 </span><span class="lineNoCov">          0 :           exit_status = EXIT_FAILURE;</span>
<span class="lineNum">    2459 </span>            :         }
<span class="lineNum">    2460 </span><span class="lineNoCov">          0 :       if (o_nocache &amp;&amp; !invalidate_cache (STDOUT_FILENO, 0))</span>
<span class="lineNum">    2461 </span>            :         {
<span class="lineNum">    2462 </span><span class="lineNoCov">          0 :           error (0, errno, _(&quot;failed to discard cache for: %s&quot;),</span>
<span class="lineNum">    2463 </span>            :                  quotef (output_file));
<span class="lineNum">    2464 </span><span class="lineNoCov">          0 :           exit_status = EXIT_FAILURE;</span>
<span class="lineNum">    2465 </span>            :         }
<span class="lineNum">    2466 </span>            :     }
<span class="lineNum">    2467 </span><span class="lineNoCov">          0 :   else if (max_records != (uintmax_t) -1)</span>
<span class="lineNum">    2468 </span>            :     {
<span class="lineNum">    2469 </span>            :       /* Invalidate any pending region less than page size,
<span class="lineNum">    2470 </span>            :          in case the kernel might round up.  */
<span class="lineNum">    2471 </span><span class="lineNoCov">          0 :       if (i_nocache)</span>
<span class="lineNum">    2472 </span><span class="lineNoCov">          0 :         invalidate_cache (STDIN_FILENO, 0);</span>
<span class="lineNum">    2473 </span><span class="lineNoCov">          0 :       if (o_nocache)</span>
<span class="lineNum">    2474 </span><span class="lineNoCov">          0 :         invalidate_cache (STDOUT_FILENO, 0);</span>
<span class="lineNum">    2475 </span>            :     }
<span class="lineNum">    2476 </span>            : 
<span class="lineNum">    2477 </span>            :   finish_up ();
<span class="lineNum">    2478 </span>            :   return exit_status;
<span class="lineNum">    2479 </span>            : }
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.12</a></td></tr>
  </table>
  <br>

</body>
</html>
