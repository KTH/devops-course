        -:    0:Source:src/cat.c
        -:    0:Graph:src/cat.gcno
        -:    0:Data:src/cat.gcda
        -:    0:Runs:9889
        -:    0:Programs:1
        -:    1:/* cat -- concatenate files and print on the standard output.
        -:    2:   Copyright (C) 1988-2016 Free Software Foundation, Inc.
        -:    3:
        -:    4:   This program is free software: you can redistribute it and/or modify
        -:    5:   it under the terms of the GNU General Public License as published by
        -:    6:   the Free Software Foundation, either version 3 of the License, or
        -:    7:   (at your option) any later version.
        -:    8:
        -:    9:   This program is distributed in the hope that it will be useful,
        -:   10:   but WITHOUT ANY WARRANTY; without even the implied warranty of
        -:   11:   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
        -:   12:   GNU General Public License for more details.
        -:   13:
        -:   14:   You should have received a copy of the GNU General Public License
        -:   15:   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
        -:   16:
        -:   17:/* Differences from the Unix cat:
        -:   18:   * Always unbuffered, -u is ignored.
        -:   19:   * Usually much faster than other versions of cat, the difference
        -:   20:   is especially apparent when using the -v option.
        -:   21:
        -:   22:   By tege@sics.se, Torbjorn Granlund, advised by rms, Richard Stallman.  */
        -:   23:
        -:   24:#include <config.h>
        -:   25:
        -:   26:#include <stdio.h>
        -:   27:#include <getopt.h>
        -:   28:#include <sys/types.h>
        -:   29:
        -:   30:#if HAVE_STROPTS_H
        -:   31:# include <stropts.h>
        -:   32:#endif
        -:   33:#include <sys/ioctl.h>
        -:   34:
        -:   35:#include "system.h"
        -:   36:#include "ioblksize.h"
        -:   37:#include "error.h"
        -:   38:#include "fadvise.h"
        -:   39:#include "full-write.h"
        -:   40:#include "safe-read.h"
        -:   41:#include "xfreopen.h"
        -:   42:
        -:   43:/* The official name of this program (e.g., no 'g' prefix).  */
        -:   44:#define PROGRAM_NAME "cat"
        -:   45:
        -:   46:#define AUTHORS \
        -:   47:  proper_name_utf8 ("Torbjorn Granlund", "Torbj\303\266rn Granlund"), \
        -:   48:  proper_name ("Richard M. Stallman")
        -:   49:
        -:   50:/* Name of input file.  May be "-".  */
        -:   51:static char const *infile;
        -:   52:
        -:   53:/* Descriptor on which input file is open.  */
        -:   54:static int input_desc;
        -:   55:
        -:   56:/* Buffer for line numbers.
        -:   57:   An 11 digit counter may overflow within an hour on a P2/466,
        -:   58:   an 18 digit counter needs about 1000y */
        -:   59:#define LINE_COUNTER_BUF_LEN 20
        -:   60:static char line_buf[LINE_COUNTER_BUF_LEN] =
        -:   61:  {
        -:   62:    ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ',
        -:   63:    ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '0',
        -:   64:    '\t', '\0'
        -:   65:  };
        -:   66:
        -:   67:/* Position in 'line_buf' where printing starts.  This will not change
        -:   68:   unless the number of lines is larger than 999999.  */
        -:   69:static char *line_num_print = line_buf + LINE_COUNTER_BUF_LEN - 8;
        -:   70:
        -:   71:/* Position of the first digit in 'line_buf'.  */
        -:   72:static char *line_num_start = line_buf + LINE_COUNTER_BUF_LEN - 3;
        -:   73:
        -:   74:/* Position of the last digit in 'line_buf'.  */
        -:   75:static char *line_num_end = line_buf + LINE_COUNTER_BUF_LEN - 3;
        -:   76:
        -:   77:/* Preserves the 'cat' function's local 'newlines' between invocations.  */
        -:   78:static int newlines2 = 0;
        -:   79:
        -:   80:void
        1:   81:usage (int status)
        -:   82:{
        1:   83:  if (status != EXIT_SUCCESS)
    #####:   84:    emit_try_help ();
        -:   85:  else
        -:   86:    {
        2:   87:      printf (_("\
        -:   88:Usage: %s [OPTION]... [FILE]...\n\
        -:   89:"),
        -:   90:              program_name);
        1:   91:      fputs (_("\
        -:   92:Concatenate FILE(s) to standard output.\n\
        -:   93:"), stdout);
        -:   94:
        1:   95:      emit_stdin_note ();
        -:   96:
        1:   97:      fputs (_("\
        -:   98:\n\
        -:   99:  -A, --show-all           equivalent to -vET\n\
        -:  100:  -b, --number-nonblank    number nonempty output lines, overrides -n\n\
        -:  101:  -e                       equivalent to -vE\n\
        -:  102:  -E, --show-ends          display $ at end of each line\n\
        -:  103:  -n, --number             number all output lines\n\
        -:  104:  -s, --squeeze-blank      suppress repeated empty output lines\n\
        -:  105:"), stdout);
        1:  106:      fputs (_("\
        -:  107:  -t                       equivalent to -vT\n\
        -:  108:  -T, --show-tabs          display TAB characters as ^I\n\
        -:  109:  -u                       (ignored)\n\
        -:  110:  -v, --show-nonprinting   use ^ and M- notation, except for LFD and TAB\n\
        -:  111:"), stdout);
        1:  112:      fputs (HELP_OPTION_DESCRIPTION, stdout);
        1:  113:      fputs (VERSION_OPTION_DESCRIPTION, stdout);
        2:  114:      printf (_("\
        -:  115:\n\
        -:  116:Examples:\n\
        -:  117:  %s f - g  Output f's contents, then standard input, then g's contents.\n\
        -:  118:  %s        Copy standard input to standard output.\n\
        -:  119:"),
        -:  120:              program_name, program_name);
        1:  121:      emit_ancillary_info (PROGRAM_NAME);
        -:  122:    }
        1:  123:  exit (status);
        -:  124:}
        -:  125:
        -:  126:/* Compute the next line number.  */
        -:  127:
        -:  128:static void
    #####:  129:next_line_num (void)
        -:  130:{
    #####:  131:  char *endp = line_num_end;
        -:  132:  do
        -:  133:    {
    #####:  134:      if ((*endp)++ < '9')
        -:  135:        return;
    #####:  136:      *endp-- = '0';
        -:  137:    }
    #####:  138:  while (endp >= line_num_start);
    #####:  139:  if (line_num_start > line_buf)
    #####:  140:    *--line_num_start = '1';
        -:  141:  else
    #####:  142:    *line_buf = '>';
    #####:  143:  if (line_num_start < line_num_print)
    #####:  144:    line_num_print--;
        -:  145:}
        -:  146:
        -:  147:/* Plain cat.  Copies the file behind 'input_desc' to STDOUT_FILENO.
        -:  148:   Return true if successful.  */
        -:  149:
        -:  150:static bool
    15164:  151:simple_cat (
        -:  152:     /* Pointer to the buffer, used by reads and writes.  */
        -:  153:     char *buf,
        -:  154:
        -:  155:     /* Number of characters preferably read or written by each read and write
        -:  156:        call.  */
        -:  157:     size_t bufsize)
        -:  158:{
        -:  159:  /* Actual number of characters read, and therefore written.  */
        -:  160:  size_t n_read;
        -:  161:
        -:  162:  /* Loop until the end of the file.  */
        -:  163:
        -:  164:  while (true)
        -:  165:    {
        -:  166:      /* Read a block of input.  */
        -:  167:
    30328:  168:      n_read = safe_read (input_desc, buf, bufsize);
    30328:  169:      if (n_read == SAFE_READ_ERROR)
        -:  170:        {
    #####:  171:          error (0, errno, "%s", quotef (infile));
    #####:  172:          return false;
        -:  173:        }
        -:  174:
        -:  175:      /* End of this file?  */
        -:  176:
    30328:  177:      if (n_read == 0)
        -:  178:        return true;
        -:  179:
        -:  180:      /* Write this block out.  */
        -:  181:
        -:  182:      {
        -:  183:        /* The following is ok, since we know that 0 < n_read.  */
    15164:  184:        size_t n = n_read;
    15164:  185:        if (full_write (STDOUT_FILENO, buf, n) != n)
    #####:  186:          error (EXIT_FAILURE, errno, _("write error"));
        -:  187:      }
        -:  188:    }
        -:  189:}
        -:  190:
        -:  191:/* Write any pending output to STDOUT_FILENO.
        -:  192:   Pending is defined to be the *BPOUT - OUTBUF bytes starting at OUTBUF.
        -:  193:   Then set *BPOUT to OUTPUT if it's not already that value.  */
        -:  194:
        -:  195:static inline void
    #####:  196:write_pending (char *outbuf, char **bpout)
        -:  197:{
    #####:  198:  size_t n_write = *bpout - outbuf;
    #####:  199:  if (0 < n_write)
        -:  200:    {
    #####:  201:      if (full_write (STDOUT_FILENO, outbuf, n_write) != n_write)
    #####:  202:        error (EXIT_FAILURE, errno, _("write error"));
    #####:  203:      *bpout = outbuf;
        -:  204:    }
    #####:  205:}
        -:  206:
        -:  207:/* Cat the file behind INPUT_DESC to the file behind OUTPUT_DESC.
        -:  208:   Return true if successful.
        -:  209:   Called if any option more than -u was specified.
        -:  210:
        -:  211:   A newline character is always put at the end of the buffer, to make
        -:  212:   an explicit test for buffer end unnecessary.  */
        -:  213:
        -:  214:static bool
    #####:  215:cat (
        -:  216:     /* Pointer to the beginning of the input buffer.  */
        -:  217:     char *inbuf,
        -:  218:
        -:  219:     /* Number of characters read in each read call.  */
        -:  220:     size_t insize,
        -:  221:
        -:  222:     /* Pointer to the beginning of the output buffer.  */
        -:  223:     char *outbuf,
        -:  224:
        -:  225:     /* Number of characters written by each write call.  */
        -:  226:     size_t outsize,
        -:  227:
        -:  228:     /* Variables that have values according to the specified options.  */
        -:  229:     bool show_nonprinting,
        -:  230:     bool show_tabs,
        -:  231:     bool number,
        -:  232:     bool number_nonblank,
        -:  233:     bool show_ends,
        -:  234:     bool squeeze_blank)
        -:  235:{
        -:  236:  /* Last character read from the input buffer.  */
        -:  237:  unsigned char ch;
        -:  238:
        -:  239:  /* Pointer to the next character in the input buffer.  */
        -:  240:  char *bpin;
        -:  241:
        -:  242:  /* Pointer to the first non-valid byte in the input buffer, i.e., the
        -:  243:     current end of the buffer.  */
        -:  244:  char *eob;
        -:  245:
        -:  246:  /* Pointer to the position where the next character shall be written.  */
        -:  247:  char *bpout;
        -:  248:
        -:  249:  /* Number of characters read by the last read call.  */
        -:  250:  size_t n_read;
        -:  251:
        -:  252:  /* Determines how many consecutive newlines there have been in the
        -:  253:     input.  0 newlines makes NEWLINES -1, 1 newline makes NEWLINES 1,
        -:  254:     etc.  Initially 0 to indicate that we are at the beginning of a
        -:  255:     new line.  The "state" of the procedure is determined by
        -:  256:     NEWLINES.  */
    #####:  257:  int newlines = newlines2;
        -:  258:
        -:  259:#ifdef FIONREAD
        -:  260:  /* If nonzero, use the FIONREAD ioctl, as an optimization.
        -:  261:     (On Ultrix, it is not supported on NFS file systems.)  */
    #####:  262:  bool use_fionread = true;
        -:  263:#endif
        -:  264:
        -:  265:  /* The inbuf pointers are initialized so that BPIN > EOB, and thereby input
        -:  266:     is read immediately.  */
        -:  267:
    #####:  268:  eob = inbuf;
    #####:  269:  bpin = eob + 1;
        -:  270:
    #####:  271:  bpout = outbuf;
        -:  272:
        -:  273:  while (true)
        -:  274:    {
        -:  275:      do
        -:  276:        {
        -:  277:          /* Write if there are at least OUTSIZE bytes in OUTBUF.  */
        -:  278:
    #####:  279:          if (outbuf + outsize <= bpout)
        -:  280:            {
        -:  281:              char *wp = outbuf;
        -:  282:              size_t remaining_bytes;
        -:  283:              do
        -:  284:                {
    #####:  285:                  if (full_write (STDOUT_FILENO, wp, outsize) != outsize)
    #####:  286:                    error (EXIT_FAILURE, errno, _("write error"));
    #####:  287:                  wp += outsize;
    #####:  288:                  remaining_bytes = bpout - wp;
        -:  289:                }
    #####:  290:              while (outsize <= remaining_bytes);
        -:  291:
        -:  292:              /* Move the remaining bytes to the beginning of the
        -:  293:                 buffer.  */
        -:  294:
    #####:  295:              memmove (outbuf, wp, remaining_bytes);
    #####:  296:              bpout = outbuf + remaining_bytes;
        -:  297:            }
        -:  298:
        -:  299:          /* Is INBUF empty?  */
        -:  300:
    #####:  301:          if (bpin > eob)
        -:  302:            {
    #####:  303:              bool input_pending = false;
        -:  304:#ifdef FIONREAD
    #####:  305:              int n_to_read = 0;
        -:  306:
        -:  307:              /* Is there any input to read immediately?
        -:  308:                 If not, we are about to wait,
        -:  309:                 so write all buffered output before waiting.  */
        -:  310:
    #####:  311:              if (use_fionread
    #####:  312:                  && ioctl (input_desc, FIONREAD, &n_to_read) < 0)
        -:  313:                {
        -:  314:                  /* Ultrix returns EOPNOTSUPP on NFS;
        -:  315:                     HP-UX returns ENOTTY on pipes.
        -:  316:                     SunOS returns EINVAL and
        -:  317:                     More/BSD returns ENODEV on special files
        -:  318:                     like /dev/null.
        -:  319:                     Irix-5 returns ENOSYS on pipes.  */
    #####:  320:                  if (errno == EOPNOTSUPP || errno == ENOTTY
    #####:  321:                      || errno == EINVAL || errno == ENODEV
    #####:  322:                      || errno == ENOSYS)
        -:  323:                    use_fionread = false;
        -:  324:                  else
        -:  325:                    {
    #####:  326:                      error (0, errno, _("cannot do ioctl on %s"),
        -:  327:                             quoteaf (infile));
    #####:  328:                      newlines2 = newlines;
    #####:  329:                      return false;
        -:  330:                    }
        -:  331:                }
    #####:  332:              if (n_to_read != 0)
    #####:  333:                input_pending = true;
        -:  334:#endif
        -:  335:
    #####:  336:              if (!input_pending)
    #####:  337:                write_pending (outbuf, &bpout);
        -:  338:
        -:  339:              /* Read more input into INBUF.  */
        -:  340:
    #####:  341:              n_read = safe_read (input_desc, inbuf, insize);
    #####:  342:              if (n_read == SAFE_READ_ERROR)
        -:  343:                {
    #####:  344:                  error (0, errno, "%s", quotef (infile));
    #####:  345:                  write_pending (outbuf, &bpout);
    #####:  346:                  newlines2 = newlines;
    #####:  347:                  return false;
        -:  348:                }
    #####:  349:              if (n_read == 0)
        -:  350:                {
    #####:  351:                  write_pending (outbuf, &bpout);
    #####:  352:                  newlines2 = newlines;
    #####:  353:                  return true;
        -:  354:                }
        -:  355:
        -:  356:              /* Update the pointers and insert a sentinel at the buffer
        -:  357:                 end.  */
        -:  358:
    #####:  359:              bpin = inbuf;
    #####:  360:              eob = bpin + n_read;
    #####:  361:              *eob = '\n';
        -:  362:            }
        -:  363:          else
        -:  364:            {
        -:  365:              /* It was a real (not a sentinel) newline.  */
        -:  366:
        -:  367:              /* Was the last line empty?
        -:  368:                 (i.e., have two or more consecutive newlines been read?)  */
        -:  369:
    #####:  370:              if (++newlines > 0)
        -:  371:                {
    #####:  372:                  if (newlines >= 2)
        -:  373:                    {
        -:  374:                      /* Limit this to 2 here.  Otherwise, with lots of
        -:  375:                         consecutive newlines, the counter could wrap
        -:  376:                         around at INT_MAX.  */
    #####:  377:                      newlines = 2;
        -:  378:
        -:  379:                      /* Are multiple adjacent empty lines to be substituted
        -:  380:                         by single ditto (-s), and this was the second empty
        -:  381:                         line?  */
    #####:  382:                      if (squeeze_blank)
        -:  383:                        {
    #####:  384:                          ch = *bpin++;
    #####:  385:                          continue;
        -:  386:                        }
        -:  387:                    }
        -:  388:
        -:  389:                  /* Are line numbers to be written at empty lines (-n)?  */
        -:  390:
    #####:  391:                  if (number && !number_nonblank)
        -:  392:                    {
    #####:  393:                      next_line_num ();
    #####:  394:                      bpout = stpcpy (bpout, line_num_print);
        -:  395:                    }
        -:  396:                }
        -:  397:
        -:  398:              /* Output a currency symbol if requested (-e).  */
        -:  399:
    #####:  400:              if (show_ends)
    #####:  401:                *bpout++ = '$';
        -:  402:
        -:  403:              /* Output the newline.  */
        -:  404:
    #####:  405:              *bpout++ = '\n';
        -:  406:            }
    #####:  407:          ch = *bpin++;
        -:  408:        }
    #####:  409:      while (ch == '\n');
        -:  410:
        -:  411:      /* Are we at the beginning of a line, and line numbers are requested?  */
        -:  412:
    #####:  413:      if (newlines >= 0 && number)
        -:  414:        {
    #####:  415:          next_line_num ();
    #####:  416:          bpout = stpcpy (bpout, line_num_print);
        -:  417:        }
        -:  418:
        -:  419:      /* Here CH cannot contain a newline character.  */
        -:  420:
        -:  421:      /* The loops below continue until a newline character is found,
        -:  422:         which means that the buffer is empty or that a proper newline
        -:  423:         has been found.  */
        -:  424:
        -:  425:      /* If quoting, i.e., at least one of -v, -e, or -t specified,
        -:  426:         scan for chars that need conversion.  */
    #####:  427:      if (show_nonprinting)
        -:  428:        {
        -:  429:          while (true)
        -:  430:            {
    #####:  431:              if (ch >= 32)
        -:  432:                {
    #####:  433:                  if (ch < 127)
    #####:  434:                    *bpout++ = ch;
    #####:  435:                  else if (ch == 127)
        -:  436:                    {
    #####:  437:                      *bpout++ = '^';
    #####:  438:                      *bpout++ = '?';
        -:  439:                    }
        -:  440:                  else
        -:  441:                    {
    #####:  442:                      *bpout++ = 'M';
    #####:  443:                      *bpout++ = '-';
    #####:  444:                      if (ch >= 128 + 32)
        -:  445:                        {
    #####:  446:                          if (ch < 128 + 127)
    #####:  447:                            *bpout++ = ch - 128;
        -:  448:                          else
        -:  449:                            {
    #####:  450:                              *bpout++ = '^';
    #####:  451:                              *bpout++ = '?';
        -:  452:                            }
        -:  453:                        }
        -:  454:                      else
        -:  455:                        {
    #####:  456:                          *bpout++ = '^';
    #####:  457:                          *bpout++ = ch - 128 + 64;
        -:  458:                        }
        -:  459:                    }
        -:  460:                }
    #####:  461:              else if (ch == '\t' && !show_tabs)
    #####:  462:                *bpout++ = '\t';
    #####:  463:              else if (ch == '\n')
        -:  464:                {
        -:  465:                  newlines = -1;
        -:  466:                  break;
        -:  467:                }
        -:  468:              else
        -:  469:                {
    #####:  470:                  *bpout++ = '^';
    #####:  471:                  *bpout++ = ch + 64;
        -:  472:                }
        -:  473:
    #####:  474:              ch = *bpin++;
    #####:  475:            }
        -:  476:        }
        -:  477:      else
        -:  478:        {
        -:  479:          /* Not quoting, neither of -v, -e, or -t specified.  */
        -:  480:          while (true)
        -:  481:            {
    #####:  482:              if (ch == '\t' && show_tabs)
        -:  483:                {
    #####:  484:                  *bpout++ = '^';
    #####:  485:                  *bpout++ = ch + 64;
        -:  486:                }
    #####:  487:              else if (ch != '\n')
    #####:  488:                *bpout++ = ch;
        -:  489:              else
        -:  490:                {
        -:  491:                  newlines = -1;
        -:  492:                  break;
        -:  493:                }
        -:  494:
    #####:  495:              ch = *bpin++;
    #####:  496:            }
        -:  497:        }
        -:  498:    }
        -:  499:}
        -:  500:
        -:  501:int
     9889:  502:main (int argc, char **argv)
        -:  503:{
        -:  504:  /* Optimal size of i/o operations of output.  */
        -:  505:  size_t outsize;
        -:  506:
        -:  507:  /* Optimal size of i/o operations of input.  */
        -:  508:  size_t insize;
        -:  509:
     9889:  510:  size_t page_size = getpagesize ();
        -:  511:
        -:  512:  /* Pointer to the input buffer.  */
        -:  513:  char *inbuf;
        -:  514:
        -:  515:  /* Pointer to the output buffer.  */
        -:  516:  char *outbuf;
        -:  517:
     9889:  518:  bool ok = true;
        -:  519:  int c;
        -:  520:
        -:  521:  /* Index in argv to processed argument.  */
        -:  522:  int argind;
        -:  523:
        -:  524:  /* Device number of the output (file or whatever).  */
        -:  525:  dev_t out_dev;
        -:  526:
        -:  527:  /* I-node number of the output.  */
        -:  528:  ino_t out_ino;
        -:  529:
        -:  530:  /* True if the output is a regular file.  */
        -:  531:  bool out_isreg;
        -:  532:
        -:  533:  /* Nonzero if we have ever read standard input.  */
     9889:  534:  bool have_read_stdin = false;
        -:  535:
        -:  536:  struct stat stat_buf;
        -:  537:
        -:  538:  /* Variables that are set according to the specified options.  */
     9889:  539:  bool number = false;
     9889:  540:  bool number_nonblank = false;
     9889:  541:  bool squeeze_blank = false;
     9889:  542:  bool show_ends = false;
     9889:  543:  bool show_nonprinting = false;
     9889:  544:  bool show_tabs = false;
     9889:  545:  int file_open_mode = O_RDONLY;
        -:  546:
        -:  547:  static struct option const long_options[] =
        -:  548:  {
        -:  549:    {"number-nonblank", no_argument, NULL, 'b'},
        -:  550:    {"number", no_argument, NULL, 'n'},
        -:  551:    {"squeeze-blank", no_argument, NULL, 's'},
        -:  552:    {"show-nonprinting", no_argument, NULL, 'v'},
        -:  553:    {"show-ends", no_argument, NULL, 'E'},
        -:  554:    {"show-tabs", no_argument, NULL, 'T'},
        -:  555:    {"show-all", no_argument, NULL, 'A'},
        -:  556:    {GETOPT_HELP_OPTION_DECL},
        -:  557:    {GETOPT_VERSION_OPTION_DECL},
        -:  558:    {NULL, 0, NULL, 0}
        -:  559:  };
        -:  560:
        -:  561:  initialize_main (&argc, &argv);
     9889:  562:  set_program_name (argv[0]);
     9889:  563:  setlocale (LC_ALL, "");
     9889:  564:  bindtextdomain (PACKAGE, LOCALEDIR);
     9889:  565:  textdomain (PACKAGE);
        -:  566:
        -:  567:  /* Arrange to close stdout if we exit via the
        -:  568:     case_GETOPT_HELP_CHAR or case_GETOPT_VERSION_CHAR code.
        -:  569:     Normally STDOUT_FILENO is used rather than stdout, so
        -:  570:     close_stdout does nothing.  */
     9889:  571:  atexit (close_stdout);
        -:  572:
        -:  573:  /* Parse command line options.  */
        -:  574:
    19778:  575:  while ((c = getopt_long (argc, argv, "benstuvAET", long_options, NULL))
        -:  576:         != -1)
        -:  577:    {
        2:  578:      switch (c)
        -:  579:        {
        -:  580:        case 'b':
    #####:  581:          number = true;
    #####:  582:          number_nonblank = true;
    #####:  583:          break;
        -:  584:
        -:  585:        case 'e':
    #####:  586:          show_ends = true;
    #####:  587:          show_nonprinting = true;
    #####:  588:          break;
        -:  589:
        -:  590:        case 'n':
    #####:  591:          number = true;
    #####:  592:          break;
        -:  593:
        -:  594:        case 's':
    #####:  595:          squeeze_blank = true;
    #####:  596:          break;
        -:  597:
        -:  598:        case 't':
    #####:  599:          show_tabs = true;
    #####:  600:          show_nonprinting = true;
    #####:  601:          break;
        -:  602:
        -:  603:        case 'u':
        -:  604:          /* We provide the -u feature unconditionally.  */
        -:  605:          break;
        -:  606:
        -:  607:        case 'v':
    #####:  608:          show_nonprinting = true;
    #####:  609:          break;
        -:  610:
        -:  611:        case 'A':
    #####:  612:          show_nonprinting = true;
    #####:  613:          show_ends = true;
    #####:  614:          show_tabs = true;
    #####:  615:          break;
        -:  616:
        -:  617:        case 'E':
    #####:  618:          show_ends = true;
    #####:  619:          break;
        -:  620:
        -:  621:        case 'T':
    #####:  622:          show_tabs = true;
    #####:  623:          break;
        -:  624:
        1:  625:        case_GETOPT_HELP_CHAR;
        -:  626:
        1:  627:        case_GETOPT_VERSION_CHAR (PROGRAM_NAME, AUTHORS);
        -:  628:
        -:  629:        default:
    #####:  630:          usage (EXIT_FAILURE);
        -:  631:        }
        -:  632:    }
        -:  633:
        -:  634:  /* Get device, i-node number, and optimal blocksize of output.  */
        -:  635:
     9887:  636:  if (fstat (STDOUT_FILENO, &stat_buf) < 0)
    #####:  637:    error (EXIT_FAILURE, errno, _("standard output"));
        -:  638:
    19774:  639:  outsize = io_blksize (stat_buf);
     9887:  640:  out_dev = stat_buf.st_dev;
     9887:  641:  out_ino = stat_buf.st_ino;
     9887:  642:  out_isreg = S_ISREG (stat_buf.st_mode) != 0;
        -:  643:
     9887:  644:  if (! (number || show_ends || squeeze_blank))
        -:  645:    {
        -:  646:      file_open_mode |= O_BINARY;
        -:  647:      if (O_BINARY && ! isatty (STDOUT_FILENO))
        -:  648:        xfreopen (NULL, "wb", stdout);
        -:  649:    }
        -:  650:
        -:  651:  /* Check if any of the input files are the same as the output file.  */
        -:  652:
        -:  653:  /* Main loop.  */
        -:  654:
     9887:  655:  infile = "-";
     9887:  656:  argind = optind;
        -:  657:
        -:  658:  do
        -:  659:    {
    15473:  660:      if (argind < argc)
    12720:  661:        infile = argv[argind];
        -:  662:
    15473:  663:      if (STREQ (infile, "-"))
        -:  664:        {
     8339:  665:          have_read_stdin = true;
     8339:  666:          input_desc = STDIN_FILENO;
        -:  667:          if ((file_open_mode & O_BINARY) && ! isatty (STDIN_FILENO))
        -:  668:            xfreopen (NULL, "rb", stdin);
        -:  669:        }
        -:  670:      else
        -:  671:        {
    14268:  672:          input_desc = open (infile, file_open_mode);
     7134:  673:          if (input_desc < 0)
        -:  674:            {
      309:  675:              error (0, errno, "%s", quotef (infile));
      309:  676:              ok = false;
      309:  677:              continue;
        -:  678:            }
        -:  679:        }
        -:  680:
    30328:  681:      if (fstat (input_desc, &stat_buf) < 0)
        -:  682:        {
    #####:  683:          error (0, errno, "%s", quotef (infile));
    #####:  684:          ok = false;
    #####:  685:          goto contin;
        -:  686:        }
    30328:  687:      insize = io_blksize (stat_buf);
        -:  688:
    15164:  689:      fdadvise (input_desc, 0, 0, FADVISE_SEQUENTIAL);
        -:  690:
        -:  691:      /* Don't copy a nonempty regular file to itself, as that would
        -:  692:         merely exhaust the output device.  It's better to catch this
        -:  693:         error earlier rather than later.  */
        -:  694:
    15164:  695:      if (out_isreg
    15097:  696:          && stat_buf.st_dev == out_dev && stat_buf.st_ino == out_ino
    #####:  697:          && lseek (input_desc, 0, SEEK_CUR) < stat_buf.st_size)
        -:  698:        {
    #####:  699:          error (0, 0, _("%s: input file is output file"), quotef (infile));
    #####:  700:          ok = false;
    #####:  701:          goto contin;
        -:  702:        }
        -:  703:
        -:  704:      /* Select which version of 'cat' to use.  If any format-oriented
        -:  705:         options were given use 'cat'; otherwise use 'simple_cat'.  */
        -:  706:
    30328:  707:      if (! (number || show_ends || show_nonprinting
    15164:  708:             || show_tabs || squeeze_blank))
        -:  709:        {
    15164:  710:          insize = MAX (insize, outsize);
    15164:  711:          inbuf = xmalloc (insize + page_size - 1);
        -:  712:
    15164:  713:          ok &= simple_cat (ptr_align (inbuf, page_size), insize);
        -:  714:        }
        -:  715:      else
        -:  716:        {
    #####:  717:          inbuf = xmalloc (insize + 1 + page_size - 1);
        -:  718:
        -:  719:          /* Why are
        -:  720:             (OUTSIZE - 1 + INSIZE * 4 + LINE_COUNTER_BUF_LEN + PAGE_SIZE - 1)
        -:  721:             bytes allocated for the output buffer?
        -:  722:
        -:  723:             A test whether output needs to be written is done when the input
        -:  724:             buffer empties or when a newline appears in the input.  After
        -:  725:             output is written, at most (OUTSIZE - 1) bytes will remain in the
        -:  726:             buffer.  Now INSIZE bytes of input is read.  Each input character
        -:  727:             may grow by a factor of 4 (by the prepending of M-^).  If all
        -:  728:             characters do, and no newlines appear in this block of input, we
        -:  729:             will have at most (OUTSIZE - 1 + INSIZE * 4) bytes in the buffer.
        -:  730:             If the last character in the preceding block of input was a
        -:  731:             newline, a line number may be written (according to the given
        -:  732:             options) as the first thing in the output buffer. (Done after the
        -:  733:             new input is read, but before processing of the input begins.)
        -:  734:             A line number requires seldom more than LINE_COUNTER_BUF_LEN
        -:  735:             positions.
        -:  736:
        -:  737:             Align the output buffer to a page size boundary, for efficiency
        -:  738:             on some paging implementations, so add PAGE_SIZE - 1 bytes to the
        -:  739:             request to make room for the alignment.  */
        -:  740:
    #####:  741:          outbuf = xmalloc (outsize - 1 + insize * 4 + LINE_COUNTER_BUF_LEN
    #####:  742:                            + page_size - 1);
        -:  743:
    #####:  744:          ok &= cat (ptr_align (inbuf, page_size), insize,
    #####:  745:                     ptr_align (outbuf, page_size), outsize, show_nonprinting,
        -:  746:                     show_tabs, number, number_nonblank, show_ends,
        -:  747:                     squeeze_blank);
        -:  748:
    #####:  749:          free (outbuf);
        -:  750:        }
        -:  751:
    15164:  752:      free (inbuf);
        -:  753:
        -:  754:    contin:
    15164:  755:      if (!STREQ (infile, "-") && close (input_desc) < 0)
        -:  756:        {
    #####:  757:          error (0, errno, "%s", quotef (infile));
    #####:  758:          ok = false;
        -:  759:        }
        -:  760:    }
    15473:  761:  while (++argind < argc);
        -:  762:
     9887:  763:  if (have_read_stdin && close (STDIN_FILENO) < 0)
    #####:  764:    error (EXIT_FAILURE, errno, _("closing standard input"));
        -:  765:
     9887:  766:  return ok ? EXIT_SUCCESS : EXIT_FAILURE;
        -:  767:}
