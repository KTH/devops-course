        -:    0:Source:src/ls.c
        -:    0:Graph:src/ls.gcno
        -:    0:Data:src/ls.gcda
        -:    0:Runs:248
        -:    0:Programs:1
        -:    0:Source is newer than graph
        -:    1:/* 'dir', 'vdir' and 'ls' directory listing programs for GNU.
        -:    2:   Copyright (C) 1985-2016 Free Software Foundation, Inc.
        -:    3:
        -:    4:   This program is free software: you can redistribute it and/or modify
        -:    5:   it under the terms of the GNU General Public License as published by
        -:    6:   the Free Software Foundation, either version 3 of the License, or
        -:    7:   (at your option) any later version.
        -:    8:
        -:    9:   This program is distributed in the hope that it will be useful,
        -:   10:   but WITHOUT ANY WARRANTY; without even the implied warranty of
        -:   11:   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
        -:   12:   GNU General Public License for more details.
        -:   13:
        -:   14:   You should have received a copy of the GNU General Public License
        -:   15:   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
        -:   16:
        -:   17:/* If ls_mode is LS_MULTI_COL,
        -:   18:   the multi-column format is the default regardless
        -:   19:   of the type of output device.
        -:   20:   This is for the 'dir' program.
        -:   21:
        -:   22:   If ls_mode is LS_LONG_FORMAT,
        -:   23:   the long format is the default regardless of the
        -:   24:   type of output device.
        -:   25:   This is for the 'vdir' program.
        -:   26:
        -:   27:   If ls_mode is LS_LS,
        -:   28:   the output format depends on whether the output
        -:   29:   device is a terminal.
        -:   30:   This is for the 'ls' program.  */
        -:   31:
        -:   32:/* Written by Richard Stallman and David MacKenzie.  */
        -:   33:
        -:   34:/* Color support by Peter Anvin <Peter.Anvin@linux.org> and Dennis
        -:   35:   Flaherty <dennisf@denix.elk.miles.com> based on original patches by
        -:   36:   Greg Lee <lee@uhunix.uhcc.hawaii.edu>.  */
        -:   37:
        -:   38:#include <config.h>
        -:   39:#include <sys/types.h>
        -:   40:
        -:   41:#include <termios.h>
        -:   42:#if HAVE_STROPTS_H
        -:   43:# include <stropts.h>
        -:   44:#endif
        -:   45:#include <sys/ioctl.h>
        -:   46:
        -:   47:#ifdef WINSIZE_IN_PTEM
        -:   48:# include <sys/stream.h>
        -:   49:# include <sys/ptem.h>
        -:   50:#endif
        -:   51:
        -:   52:#include <stdio.h>
        -:   53:#include <assert.h>
        -:   54:#include <setjmp.h>
        -:   55:#include <pwd.h>
        -:   56:#include <getopt.h>
        -:   57:#include <signal.h>
        -:   58:#include <selinux/selinux.h>
        -:   59:#include <wchar.h>
        -:   60:
        -:   61:#if HAVE_LANGINFO_CODESET
        -:   62:# include <langinfo.h>
        -:   63:#endif
        -:   64:
        -:   65:/* Use SA_NOCLDSTOP as a proxy for whether the sigaction machinery is
        -:   66:   present.  */
        -:   67:#ifndef SA_NOCLDSTOP
        -:   68:# define SA_NOCLDSTOP 0
        -:   69:# define sigprocmask(How, Set, Oset) /* empty */
        -:   70:# define sigset_t int
        -:   71:# if ! HAVE_SIGINTERRUPT
        -:   72:#  define siginterrupt(sig, flag) /* empty */
        -:   73:# endif
        -:   74:#endif
        -:   75:
        -:   76:/* NonStop circa 2011 lacks both SA_RESTART and siginterrupt, so don't
        -:   77:   restart syscalls after a signal handler fires.  This may cause
        -:   78:   colors to get messed up on the screen if 'ls' is interrupted, but
        -:   79:   that's the best we can do on such a platform.  */
        -:   80:#ifndef SA_RESTART
        -:   81:# define SA_RESTART 0
        -:   82:#endif
        -:   83:
        -:   84:#include "system.h"
        -:   85:#include <fnmatch.h>
        -:   86:
        -:   87:#include "acl.h"
        -:   88:#include "argmatch.h"
        -:   89:#include "dev-ino.h"
        -:   90:#include "error.h"
        -:   91:#include "filenamecat.h"
        -:   92:#include "hard-locale.h"
        -:   93:#include "hash.h"
        -:   94:#include "human.h"
        -:   95:#include "filemode.h"
        -:   96:#include "filevercmp.h"
        -:   97:#include "idcache.h"
        -:   98:#include "ls.h"
        -:   99:#include "mbswidth.h"
        -:  100:#include "mpsort.h"
        -:  101:#include "obstack.h"
        -:  102:#include "quote.h"
        -:  103:#include "smack.h"
        -:  104:#include "stat-size.h"
        -:  105:#include "stat-time.h"
        -:  106:#include "strftime.h"
        -:  107:#include "xdectoint.h"
        -:  108:#include "xstrtol.h"
        -:  109:#include "areadlink.h"
        -:  110:#include "mbsalign.h"
        -:  111:#include "dircolors.h"
        -:  112:#include "../../afl-2.52b/experimental/argv_fuzzing/argv-fuzz-inl.h"
        -:  113:
        -:  114:/* Include <sys/capability.h> last to avoid a clash of <sys/types.h>
        -:  115:   include guards with some premature versions of libcap.
        -:  116:   For more details, see <http://bugzilla.redhat.com/483548>.  */
        -:  117:#ifdef HAVE_CAP
        -:  118:# include <sys/capability.h>
        -:  119:#endif
        -:  120:
        -:  121:#define PROGRAM_NAME (ls_mode == LS_LS ? "ls" \
        -:  122:                      : (ls_mode == LS_MULTI_COL \
        -:  123:                         ? "dir" : "vdir"))
        -:  124:
        -:  125:#define AUTHORS \
        -:  126:  proper_name ("Richard M. Stallman"), \
        -:  127:  proper_name ("David MacKenzie")
        -:  128:
        -:  129:#define obstack_chunk_alloc malloc
        -:  130:#define obstack_chunk_free free
        -:  131:
        -:  132:/* Return an int indicating the result of comparing two integers.
        -:  133:   Subtracting doesn't always work, due to overflow.  */
        -:  134:#define longdiff(a, b) ((a) < (b) ? -1 : (a) > (b))
        -:  135:
        -:  136:/* Unix-based readdir implementations have historically returned a dirent.d_ino
        -:  137:   value that is sometimes not equal to the stat-obtained st_ino value for
        -:  138:   that same entry.  This error occurs for a readdir entry that refers
        -:  139:   to a mount point.  readdir's error is to return the inode number of
        -:  140:   the underlying directory -- one that typically cannot be stat'ed, as
        -:  141:   long as a file system is mounted on that directory.  RELIABLE_D_INO
        -:  142:   encapsulates whether we can use the more efficient approach of relying
        -:  143:   on readdir-supplied d_ino values, or whether we must incur the cost of
        -:  144:   calling stat or lstat to obtain each guaranteed-valid inode number.  */
        -:  145:
        -:  146:#ifndef READDIR_LIES_ABOUT_MOUNTPOINT_D_INO
        -:  147:# define READDIR_LIES_ABOUT_MOUNTPOINT_D_INO 1
        -:  148:#endif
        -:  149:
        -:  150:#if READDIR_LIES_ABOUT_MOUNTPOINT_D_INO
        -:  151:# define RELIABLE_D_INO(dp) NOT_AN_INODE_NUMBER
        -:  152:#else
        -:  153:# define RELIABLE_D_INO(dp) D_INO (dp)
        -:  154:#endif
        -:  155:
        -:  156:#if ! HAVE_STRUCT_STAT_ST_AUTHOR
        -:  157:# define st_author st_uid
        -:  158:#endif
        -:  159:
        -:  160:enum filetype
        -:  161:  {
        -:  162:    unknown,
        -:  163:    fifo,
        -:  164:    chardev,
        -:  165:    directory,
        -:  166:    blockdev,
        -:  167:    normal,
        -:  168:    symbolic_link,
        -:  169:    sock,
        -:  170:    whiteout,
        -:  171:    arg_directory
        -:  172:  };
        -:  173:
        -:  174:/* Display letters and indicators for each filetype.
        -:  175:   Keep these in sync with enum filetype.  */
        -:  176:static char const filetype_letter[] = "?pcdb-lswd";
        -:  177:
        -:  178:/* Ensure that filetype and filetype_letter have the same
        -:  179:   number of elements.  */
        -:  180:verify (sizeof filetype_letter - 1 == arg_directory + 1);
        -:  181:
        -:  182:#define FILETYPE_INDICATORS				\
        -:  183:  {							\
        -:  184:    C_ORPHAN, C_FIFO, C_CHR, C_DIR, C_BLK, C_FILE,	\
        -:  185:    C_LINK, C_SOCK, C_FILE, C_DIR			\
        -:  186:  }
        -:  187:
        -:  188:enum acl_type
        -:  189:  {
        -:  190:    ACL_T_NONE,
        -:  191:    ACL_T_LSM_CONTEXT_ONLY,
        -:  192:    ACL_T_YES
        -:  193:  };
        -:  194:
        -:  195:struct fileinfo
        -:  196:  {
        -:  197:    /* The file name.  */
        -:  198:    char *name;
        -:  199:
        -:  200:    /* For symbolic link, name of the file linked to, otherwise zero.  */
        -:  201:    char *linkname;
        -:  202:
        -:  203:    struct stat stat;
        -:  204:
        -:  205:    enum filetype filetype;
        -:  206:
        -:  207:    /* For symbolic link and long listing, st_mode of file linked to, otherwise
        -:  208:       zero.  */
        -:  209:    mode_t linkmode;
        -:  210:
        -:  211:    /* security context.  */
        -:  212:    char *scontext;
        -:  213:
        -:  214:    bool stat_ok;
        -:  215:
        -:  216:    /* For symbolic link and color printing, true if linked-to file
        -:  217:       exists, otherwise false.  */
        -:  218:    bool linkok;
        -:  219:
        -:  220:    /* For long listings, true if the file has an access control list,
        -:  221:       or a security context.  */
        -:  222:    enum acl_type acl_type;
        -:  223:
        -:  224:    /* For color listings, true if a regular file has capability info.  */
        -:  225:    bool has_capability;
        -:  226:  };
        -:  227:
        -:  228:#define LEN_STR_PAIR(s) sizeof (s) - 1, s
        -:  229:
        -:  230:/* Null is a valid character in a color indicator (think about Epson
        -:  231:   printers, for example) so we have to use a length/buffer string
        -:  232:   type.  */
        -:  233:
        -:  234:struct bin_str
        -:  235:  {
        -:  236:    size_t len;			/* Number of bytes */
        -:  237:    const char *string;		/* Pointer to the same */
        -:  238:  };
        -:  239:
        -:  240:#if ! HAVE_TCGETPGRP
        -:  241:# define tcgetpgrp(Fd) 0
        -:  242:#endif
        -:  243:
        -:  244:static size_t quote_name (FILE *out, const char *name,
        -:  245:                          struct quoting_options const *options,
        -:  246:                          size_t *width);
        -:  247:static char *make_link_name (char const *name, char const *linkname);
        -:  248:static int decode_switches (int argc, char **argv);
        -:  249:static bool file_ignored (char const *name);
        -:  250:static uintmax_t gobble_file (char const *name, enum filetype type,
        -:  251:                              ino_t inode, bool command_line_arg,
        -:  252:                              char const *dirname);
        -:  253:static bool print_color_indicator (const struct fileinfo *f,
        -:  254:                                   bool symlink_target);
        -:  255:static void put_indicator (const struct bin_str *ind);
        -:  256:static void add_ignore_pattern (const char *pattern);
        -:  257:static void attach (char *dest, const char *dirname, const char *name);
        -:  258:static void clear_files (void);
        -:  259:static void extract_dirs_from_files (char const *dirname,
        -:  260:                                     bool command_line_arg);
        -:  261:static void get_link_name (char const *filename, struct fileinfo *f,
        -:  262:                           bool command_line_arg);
        -:  263:static void indent (size_t from, size_t to);
        -:  264:static size_t calculate_columns (bool by_columns);
        -:  265:static void print_current_files (void);
        -:  266:static void print_dir (char const *name, char const *realname,
        -:  267:                       bool command_line_arg);
        -:  268:static size_t print_file_name_and_frills (const struct fileinfo *f,
        -:  269:                                          size_t start_col);
        -:  270:static void print_horizontal (void);
        -:  271:static int format_user_width (uid_t u);
        -:  272:static int format_group_width (gid_t g);
        -:  273:static void print_long_format (const struct fileinfo *f);
        -:  274:static void print_many_per_line (void);
        -:  275:static size_t print_name_with_quoting (const struct fileinfo *f,
        -:  276:                                       bool symlink_target,
        -:  277:                                       struct obstack *stack,
        -:  278:                                       size_t start_col);
        -:  279:static void prep_non_filename_text (void);
        -:  280:static bool print_type_indicator (bool stat_ok, mode_t mode,
        -:  281:                                  enum filetype type);
        -:  282:static void print_with_separator (char sep);
        -:  283:static void queue_directory (char const *name, char const *realname,
        -:  284:                             bool command_line_arg);
        -:  285:static void sort_files (void);
        -:  286:static void parse_ls_color (void);
        -:  287:
        -:  288:static void getenv_quoting_style (void);
        -:  289:
        -:  290:/* Initial size of hash table.
        -:  291:   Most hierarchies are likely to be shallower than this.  */
        -:  292:#define INITIAL_TABLE_SIZE 30
        -:  293:
        -:  294:/* The set of 'active' directories, from the current command-line argument
        -:  295:   to the level in the hierarchy at which files are being listed.
        -:  296:   A directory is represented by its device and inode numbers (struct dev_ino).
        -:  297:   A directory is added to this set when ls begins listing it or its
        -:  298:   entries, and it is removed from the set just after ls has finished
        -:  299:   processing it.  This set is used solely to detect loops, e.g., with
        -:  300:   mkdir loop; cd loop; ln -s ../loop sub; ls -RL  */
        -:  301:static Hash_table *active_dir_set;
        -:  302:
        -:  303:#define LOOP_DETECT (!!active_dir_set)
        -:  304:
        -:  305:/* The table of files in the current directory:
        -:  306:
        -:  307:   'cwd_file' points to a vector of 'struct fileinfo', one per file.
        -:  308:   'cwd_n_alloc' is the number of elements space has been allocated for.
        -:  309:   'cwd_n_used' is the number actually in use.  */
        -:  310:
        -:  311:/* Address of block containing the files that are described.  */
        -:  312:static struct fileinfo *cwd_file;
        -:  313:
        -:  314:/* Length of block that 'cwd_file' points to, measured in files.  */
        -:  315:static size_t cwd_n_alloc;
        -:  316:
        -:  317:/* Index of first unused slot in 'cwd_file'.  */
        -:  318:static size_t cwd_n_used;
        -:  319:
        -:  320:/* Vector of pointers to files, in proper sorted order, and the number
        -:  321:   of entries allocated for it.  */
        -:  322:static void **sorted_file;
        -:  323:static size_t sorted_file_alloc;
        -:  324:
        -:  325:/* When true, in a color listing, color each symlink name according to the
        -:  326:   type of file it points to.  Otherwise, color them according to the 'ln'
        -:  327:   directive in LS_COLORS.  Dangling (orphan) symlinks are treated specially,
        -:  328:   regardless.  This is set when 'ln=target' appears in LS_COLORS.  */
        -:  329:
        -:  330:static bool color_symlink_as_referent;
        -:  331:
        -:  332:/* mode of appropriate file for colorization */
        -:  333:#define FILE_OR_LINK_MODE(File) \
        -:  334:    ((color_symlink_as_referent && (File)->linkok) \
        -:  335:     ? (File)->linkmode : (File)->stat.st_mode)
        -:  336:
        -:  337:
        -:  338:/* Record of one pending directory waiting to be listed.  */
        -:  339:
        -:  340:struct pending
        -:  341:  {
        -:  342:    char *name;
        -:  343:    /* If the directory is actually the file pointed to by a symbolic link we
        -:  344:       were told to list, 'realname' will contain the name of the symbolic
        -:  345:       link, otherwise zero.  */
        -:  346:    char *realname;
        -:  347:    bool command_line_arg;
        -:  348:    struct pending *next;
        -:  349:  };
        -:  350:
        -:  351:static struct pending *pending_dirs;
        -:  352:
        -:  353:/* Current time in seconds and nanoseconds since 1970, updated as
        -:  354:   needed when deciding whether a file is recent.  */
        -:  355:
        -:  356:static struct timespec current_time;
        -:  357:
        -:  358:static bool print_scontext;
        -:  359:static char UNKNOWN_SECURITY_CONTEXT[] = "?";
        -:  360:
        -:  361:/* Whether any of the files has an ACL.  This affects the width of the
        -:  362:   mode column.  */
        -:  363:
        -:  364:static bool any_has_acl;
        -:  365:
        -:  366:/* The number of columns to use for columns containing inode numbers,
        -:  367:   block sizes, link counts, owners, groups, authors, major device
        -:  368:   numbers, minor device numbers, and file sizes, respectively.  */
        -:  369:
        -:  370:static int inode_number_width;
        -:  371:static int block_size_width;
        -:  372:static int nlink_width;
        -:  373:static int scontext_width;
        -:  374:static int owner_width;
        -:  375:static int group_width;
        -:  376:static int author_width;
        -:  377:static int major_device_number_width;
        -:  378:static int minor_device_number_width;
        -:  379:static int file_size_width;
        -:  380:
        -:  381:/* Option flags */
        -:  382:
        -:  383:/* long_format for lots of info, one per line.
        -:  384:   one_per_line for just names, one per line.
        -:  385:   many_per_line for just names, many per line, sorted vertically.
        -:  386:   horizontal for just names, many per line, sorted horizontally.
        -:  387:   with_commas for just names, many per line, separated by commas.
        -:  388:
        -:  389:   -l (and other options that imply -l), -1, -C, -x and -m control
        -:  390:   this parameter.  */
        -:  391:
        -:  392:enum format
        -:  393:  {
        -:  394:    long_format,		/* -l and other options that imply -l */
        -:  395:    one_per_line,		/* -1 */
        -:  396:    many_per_line,		/* -C */
        -:  397:    horizontal,			/* -x */
        -:  398:    with_commas			/* -m */
        -:  399:  };
        -:  400:
        -:  401:static enum format format;
        -:  402:
        -:  403:/* 'full-iso' uses full ISO-style dates and times.  'long-iso' uses longer
        -:  404:   ISO-style time stamps, though shorter than 'full-iso'.  'iso' uses shorter
        -:  405:   ISO-style time stamps.  'locale' uses locale-dependent time stamps.  */
        -:  406:enum time_style
        -:  407:  {
        -:  408:    full_iso_time_style,	/* --time-style=full-iso */
        -:  409:    long_iso_time_style,	/* --time-style=long-iso */
        -:  410:    iso_time_style,		/* --time-style=iso */
        -:  411:    locale_time_style		/* --time-style=locale */
        -:  412:  };
        -:  413:
        -:  414:static char const *const time_style_args[] =
        -:  415:{
        -:  416:  "full-iso", "long-iso", "iso", "locale", NULL
        -:  417:};
        -:  418:static enum time_style const time_style_types[] =
        -:  419:{
        -:  420:  full_iso_time_style, long_iso_time_style, iso_time_style,
        -:  421:  locale_time_style
        -:  422:};
        -:  423:ARGMATCH_VERIFY (time_style_args, time_style_types);
        -:  424:
        -:  425:/* Type of time to print or sort by.  Controlled by -c and -u.
        -:  426:   The values of each item of this enum are important since they are
        -:  427:   used as indices in the sort functions array (see sort_files()).  */
        -:  428:
        -:  429:enum time_type
        -:  430:  {
        -:  431:    time_mtime,			/* default */
        -:  432:    time_ctime,			/* -c */
        -:  433:    time_atime,			/* -u */
        -:  434:    time_numtypes		/* the number of elements of this enum */
        -:  435:  };
        -:  436:
        -:  437:static enum time_type time_type;
        -:  438:
        -:  439:/* The file characteristic to sort by.  Controlled by -t, -S, -U, -X, -v.
        -:  440:   The values of each item of this enum are important since they are
        -:  441:   used as indices in the sort functions array (see sort_files()).  */
        -:  442:
        -:  443:enum sort_type
        -:  444:  {
        -:  445:    sort_none = -1,		/* -U */
        -:  446:    sort_name,			/* default */
        -:  447:    sort_extension,		/* -X */
        -:  448:    sort_size,			/* -S */
        -:  449:    sort_version,		/* -v */
        -:  450:    sort_time,			/* -t */
        -:  451:    sort_numtypes		/* the number of elements of this enum */
        -:  452:  };
        -:  453:
        -:  454:static enum sort_type sort_type;
        -:  455:
        -:  456:/* Direction of sort.
        -:  457:   false means highest first if numeric,
        -:  458:   lowest first if alphabetic;
        -:  459:   these are the defaults.
        -:  460:   true means the opposite order in each case.  -r  */
        -:  461:
        -:  462:static bool sort_reverse;
        -:  463:
        -:  464:/* True means to display owner information.  -g turns this off.  */
        -:  465:
        -:  466:static bool print_owner = true;
        -:  467:
        -:  468:/* True means to display author information.  */
        -:  469:
        -:  470:static bool print_author;
        -:  471:
        -:  472:/* True means to display group information.  -G and -o turn this off.  */
        -:  473:
        -:  474:static bool print_group = true;
        -:  475:
        -:  476:/* True means print the user and group id's as numbers rather
        -:  477:   than as names.  -n  */
        -:  478:
        -:  479:static bool numeric_ids;
        -:  480:
        -:  481:/* True means mention the size in blocks of each file.  -s  */
        -:  482:
        -:  483:static bool print_block_size;
        -:  484:
        -:  485:/* Human-readable options for output, when printing block counts.  */
        -:  486:static int human_output_opts;
        -:  487:
        -:  488:/* The units to use when printing block counts.  */
        -:  489:static uintmax_t output_block_size;
        -:  490:
        -:  491:/* Likewise, but for file sizes.  */
        -:  492:static int file_human_output_opts;
        -:  493:static uintmax_t file_output_block_size = 1;
        -:  494:
        -:  495:/* Follow the output with a special string.  Using this format,
        -:  496:   Emacs' dired mode starts up twice as fast, and can handle all
        -:  497:   strange characters in file names.  */
        -:  498:static bool dired;
        -:  499:
        -:  500:/* 'none' means don't mention the type of files.
        -:  501:   'slash' means mention directories only, with a '/'.
        -:  502:   'file_type' means mention file types.
        -:  503:   'classify' means mention file types and mark executables.
        -:  504:
        -:  505:   Controlled by -F, -p, and --indicator-style.  */
        -:  506:
        -:  507:enum indicator_style
        -:  508:  {
        -:  509:    none,	/*     --indicator-style=none */
        -:  510:    slash,	/* -p, --indicator-style=slash */
        -:  511:    file_type,	/*     --indicator-style=file-type */
        -:  512:    classify	/* -F, --indicator-style=classify */
        -:  513:  };
        -:  514:
        -:  515:static enum indicator_style indicator_style;
        -:  516:
        -:  517:/* Names of indicator styles.  */
        -:  518:static char const *const indicator_style_args[] =
        -:  519:{
        -:  520:  "none", "slash", "file-type", "classify", NULL
        -:  521:};
        -:  522:static enum indicator_style const indicator_style_types[] =
        -:  523:{
        -:  524:  none, slash, file_type, classify
        -:  525:};
        -:  526:ARGMATCH_VERIFY (indicator_style_args, indicator_style_types);
        -:  527:
        -:  528:/* True means use colors to mark types.  Also define the different
        -:  529:   colors as well as the stuff for the LS_COLORS environment variable.
        -:  530:   The LS_COLORS variable is now in a termcap-like format.  */
        -:  531:
        -:  532:static bool print_with_color;
        -:  533:
        -:  534:/* Whether we used any colors in the output so far.  If so, we will
        -:  535:   need to restore the default color later.  If not, we will need to
        -:  536:   call prep_non_filename_text before using color for the first time. */
        -:  537:
        -:  538:static bool used_color = false;
        -:  539:
        -:  540:enum color_type
        -:  541:  {
        -:  542:    color_never,		/* 0: default or --color=never */
        -:  543:    color_always,		/* 1: --color=always */
        -:  544:    color_if_tty		/* 2: --color=tty */
        -:  545:  };
        -:  546:
        -:  547:enum Dereference_symlink
        -:  548:  {
        -:  549:    DEREF_UNDEFINED = 1,
        -:  550:    DEREF_NEVER,
        -:  551:    DEREF_COMMAND_LINE_ARGUMENTS,	/* -H */
        -:  552:    DEREF_COMMAND_LINE_SYMLINK_TO_DIR,	/* the default, in certain cases */
        -:  553:    DEREF_ALWAYS			/* -L */
        -:  554:  };
        -:  555:
        -:  556:enum indicator_no
        -:  557:  {
        -:  558:    C_LEFT, C_RIGHT, C_END, C_RESET, C_NORM, C_FILE, C_DIR, C_LINK,
        -:  559:    C_FIFO, C_SOCK,
        -:  560:    C_BLK, C_CHR, C_MISSING, C_ORPHAN, C_EXEC, C_DOOR, C_SETUID, C_SETGID,
        -:  561:    C_STICKY, C_OTHER_WRITABLE, C_STICKY_OTHER_WRITABLE, C_CAP, C_MULTIHARDLINK,
        -:  562:    C_CLR_TO_EOL
        -:  563:  };
        -:  564:
        -:  565:static const char *const indicator_name[]=
        -:  566:  {
        -:  567:    "lc", "rc", "ec", "rs", "no", "fi", "di", "ln", "pi", "so",
        -:  568:    "bd", "cd", "mi", "or", "ex", "do", "su", "sg", "st",
        -:  569:    "ow", "tw", "ca", "mh", "cl", NULL
        -:  570:  };
        -:  571:
        -:  572:struct color_ext_type
        -:  573:  {
        -:  574:    struct bin_str ext;		/* The extension we're looking for */
        -:  575:    struct bin_str seq;		/* The sequence to output when we do */
        -:  576:    struct color_ext_type *next;	/* Next in list */
        -:  577:  };
        -:  578:
        -:  579:static struct bin_str color_indicator[] =
        -:  580:  {
        -:  581:    { LEN_STR_PAIR ("\033[") },		/* lc: Left of color sequence */
        -:  582:    { LEN_STR_PAIR ("m") },		/* rc: Right of color sequence */
        -:  583:    { 0, NULL },			/* ec: End color (replaces lc+rs+rc) */
        -:  584:    { LEN_STR_PAIR ("0") },		/* rs: Reset to ordinary colors */
        -:  585:    { 0, NULL },			/* no: Normal */
        -:  586:    { 0, NULL },			/* fi: File: default */
        -:  587:    { LEN_STR_PAIR ("01;34") },		/* di: Directory: bright blue */
        -:  588:    { LEN_STR_PAIR ("01;36") },		/* ln: Symlink: bright cyan */
        -:  589:    { LEN_STR_PAIR ("33") },		/* pi: Pipe: yellow/brown */
        -:  590:    { LEN_STR_PAIR ("01;35") },		/* so: Socket: bright magenta */
        -:  591:    { LEN_STR_PAIR ("01;33") },		/* bd: Block device: bright yellow */
        -:  592:    { LEN_STR_PAIR ("01;33") },		/* cd: Char device: bright yellow */
        -:  593:    { 0, NULL },			/* mi: Missing file: undefined */
        -:  594:    { 0, NULL },			/* or: Orphaned symlink: undefined */
        -:  595:    { LEN_STR_PAIR ("01;32") },		/* ex: Executable: bright green */
        -:  596:    { LEN_STR_PAIR ("01;35") },		/* do: Door: bright magenta */
        -:  597:    { LEN_STR_PAIR ("37;41") },		/* su: setuid: white on red */
        -:  598:    { LEN_STR_PAIR ("30;43") },		/* sg: setgid: black on yellow */
        -:  599:    { LEN_STR_PAIR ("37;44") },		/* st: sticky: black on blue */
        -:  600:    { LEN_STR_PAIR ("34;42") },		/* ow: other-writable: blue on green */
        -:  601:    { LEN_STR_PAIR ("30;42") },		/* tw: ow w/ sticky: black on green */
        -:  602:    { LEN_STR_PAIR ("30;41") },		/* ca: black on red */
        -:  603:    { 0, NULL },			/* mh: disabled by default */
        -:  604:    { LEN_STR_PAIR ("\033[K") },	/* cl: clear to end of line */
        -:  605:  };
        -:  606:
        -:  607:/* FIXME: comment  */
        -:  608:static struct color_ext_type *color_ext_list = NULL;
        -:  609:
        -:  610:/* Buffer for color sequences */
        -:  611:static char *color_buf;
        -:  612:
        -:  613:/* True means to check for orphaned symbolic link, for displaying
        -:  614:   colors.  */
        -:  615:
        -:  616:static bool check_symlink_color;
        -:  617:
        -:  618:/* True means mention the inode number of each file.  -i  */
        -:  619:
        -:  620:static bool print_inode;
        -:  621:
        -:  622:/* What to do with symbolic links.  Affected by -d, -F, -H, -l (and
        -:  623:   other options that imply -l), and -L.  */
        -:  624:
        -:  625:static enum Dereference_symlink dereference;
        -:  626:
        -:  627:/* True means when a directory is found, display info on its
        -:  628:   contents.  -R  */
        -:  629:
        -:  630:static bool recursive;
        -:  631:
        -:  632:/* True means when an argument is a directory name, display info
        -:  633:   on it itself.  -d  */
        -:  634:
        -:  635:static bool immediate_dirs;
        -:  636:
        -:  637:/* True means that directories are grouped before files. */
        -:  638:
        -:  639:static bool directories_first;
        -:  640:
        -:  641:/* Which files to ignore.  */
        -:  642:
        -:  643:static enum
        -:  644:{
        -:  645:  /* Ignore files whose names start with '.', and files specified by
        -:  646:     --hide and --ignore.  */
        -:  647:  IGNORE_DEFAULT,
        -:  648:
        -:  649:  /* Ignore '.', '..', and files specified by --ignore.  */
        -:  650:  IGNORE_DOT_AND_DOTDOT,
        -:  651:
        -:  652:  /* Ignore only files specified by --ignore.  */
        -:  653:  IGNORE_MINIMAL
        -:  654:} ignore_mode;
        -:  655:
        -:  656:/* A linked list of shell-style globbing patterns.  If a non-argument
        -:  657:   file name matches any of these patterns, it is ignored.
        -:  658:   Controlled by -I.  Multiple -I options accumulate.
        -:  659:   The -B option adds '*~' and '.*~' to this list.  */
        -:  660:
        -:  661:struct ignore_pattern
        -:  662:  {
        -:  663:    const char *pattern;
        -:  664:    struct ignore_pattern *next;
        -:  665:  };
        -:  666:
        -:  667:static struct ignore_pattern *ignore_patterns;
        -:  668:
        -:  669:/* Similar to IGNORE_PATTERNS, except that -a or -A causes this
        -:  670:   variable itself to be ignored.  */
        -:  671:static struct ignore_pattern *hide_patterns;
        -:  672:
        -:  673:/* True means output nongraphic chars in file names as '?'.
        -:  674:   (-q, --hide-control-chars)
        -:  675:   qmark_funny_chars and the quoting style (-Q, --quoting-style=WORD) are
        -:  676:   independent.  The algorithm is: first, obey the quoting style to get a
        -:  677:   string representing the file name;  then, if qmark_funny_chars is set,
        -:  678:   replace all nonprintable chars in that string with '?'.  It's necessary
        -:  679:   to replace nonprintable chars even in quoted strings, because we don't
        -:  680:   want to mess up the terminal if control chars get sent to it, and some
        -:  681:   quoting methods pass through control chars as-is.  */
        -:  682:static bool qmark_funny_chars;
        -:  683:
        -:  684:/* Quoting options for file and dir name output.  */
        -:  685:
        -:  686:static struct quoting_options *filename_quoting_options;
        -:  687:static struct quoting_options *dirname_quoting_options;
        -:  688:
        -:  689:/* The number of chars per hardware tab stop.  Setting this to zero
        -:  690:   inhibits the use of TAB characters for separating columns.  -T */
        -:  691:static size_t tabsize;
        -:  692:
        -:  693:/* True means print each directory name before listing it.  */
        -:  694:
        -:  695:static bool print_dir_name;
        -:  696:
        -:  697:/* The line length to use for breaking lines in many-per-line format.
        -:  698:   Can be set with -w.  */
        -:  699:
        -:  700:static size_t line_length;
        -:  701:
        -:  702:/* The local time zone rules, as per the TZ environment variable.  */
        -:  703:
        -:  704:static timezone_t localtz;
        -:  705:
        -:  706:/* If true, the file listing format requires that stat be called on
        -:  707:   each file.  */
        -:  708:
        -:  709:static bool format_needs_stat;
        -:  710:
        -:  711:/* Similar to 'format_needs_stat', but set if only the file type is
        -:  712:   needed.  */
        -:  713:
        -:  714:static bool format_needs_type;
        -:  715:
        -:  716:/* An arbitrary limit on the number of bytes in a printed time stamp.
        -:  717:   This is set to a relatively small value to avoid the need to worry
        -:  718:   about denial-of-service attacks on servers that run "ls" on behalf
        -:  719:   of remote clients.  1000 bytes should be enough for any practical
        -:  720:   time stamp format.  */
        -:  721:
        -:  722:enum { TIME_STAMP_LEN_MAXIMUM = MAX (1000, INT_STRLEN_BOUND (time_t)) };
        -:  723:
        -:  724:/* strftime formats for non-recent and recent files, respectively, in
        -:  725:   -l output.  */
        -:  726:
        -:  727:static char const *long_time_format[2] =
        -:  728:  {
        -:  729:    /* strftime format for non-recent files (older than 6 months), in
        -:  730:       -l output.  This should contain the year, month and day (at
        -:  731:       least), in an order that is understood by people in your
        -:  732:       locale's territory.  Please try to keep the number of used
        -:  733:       screen columns small, because many people work in windows with
        -:  734:       only 80 columns.  But make this as wide as the other string
        -:  735:       below, for recent files.  */
        -:  736:    /* TRANSLATORS: ls output needs to be aligned for ease of reading,
        -:  737:       so be wary of using variable width fields from the locale.
        -:  738:       Note %b is handled specially by ls and aligned correctly.
        -:  739:       Note also that specifying a width as in %5b is erroneous as strftime
        -:  740:       will count bytes rather than characters in multibyte locales.  */
        -:  741:    N_("%b %e  %Y"),
        -:  742:    /* strftime format for recent files (younger than 6 months), in -l
        -:  743:       output.  This should contain the month, day and time (at
        -:  744:       least), in an order that is understood by people in your
        -:  745:       locale's territory.  Please try to keep the number of used
        -:  746:       screen columns small, because many people work in windows with
        -:  747:       only 80 columns.  But make this as wide as the other string
        -:  748:       above, for non-recent files.  */
        -:  749:    /* TRANSLATORS: ls output needs to be aligned for ease of reading,
        -:  750:       so be wary of using variable width fields from the locale.
        -:  751:       Note %b is handled specially by ls and aligned correctly.
        -:  752:       Note also that specifying a width as in %5b is erroneous as strftime
        -:  753:       will count bytes rather than characters in multibyte locales.  */
        -:  754:    N_("%b %e %H:%M")
        -:  755:  };
        -:  756:
        -:  757:/* The set of signals that are caught.  */
        -:  758:
        -:  759:static sigset_t caught_signals;
        -:  760:
        -:  761:/* If nonzero, the value of the pending fatal signal.  */
        -:  762:
        -:  763:static sig_atomic_t volatile interrupt_signal;
        -:  764:
        -:  765:/* A count of the number of pending stop signals that have been received.  */
        -:  766:
        -:  767:static sig_atomic_t volatile stop_signal_count;
        -:  768:
        -:  769:/* Desired exit status.  */
        -:  770:
        -:  771:static int exit_status;
        -:  772:
        -:  773:/* Exit statuses.  */
        -:  774:enum
        -:  775:  {
        -:  776:    /* "ls" had a minor problem.  E.g., while processing a directory,
        -:  777:       ls obtained the name of an entry via readdir, yet was later
        -:  778:       unable to stat that name.  This happens when listing a directory
        -:  779:       in which entries are actively being removed or renamed.  */
        -:  780:    LS_MINOR_PROBLEM = 1,
        -:  781:
        -:  782:    /* "ls" had more serious trouble (e.g., memory exhausted, invalid
        -:  783:       option or failure to stat a command line argument.  */
        -:  784:    LS_FAILURE = 2
        -:  785:  };
        -:  786:
        -:  787:/* For long options that have no equivalent short option, use a
        -:  788:   non-character as a pseudo short option, starting with CHAR_MAX + 1.  */
        -:  789:enum
        -:  790:{
        -:  791:  AUTHOR_OPTION = CHAR_MAX + 1,
        -:  792:  BLOCK_SIZE_OPTION,
        -:  793:  COLOR_OPTION,
        -:  794:  DEREFERENCE_COMMAND_LINE_SYMLINK_TO_DIR_OPTION,
        -:  795:  FILE_TYPE_INDICATOR_OPTION,
        -:  796:  FORMAT_OPTION,
        -:  797:  FULL_TIME_OPTION,
        -:  798:  GROUP_DIRECTORIES_FIRST_OPTION,
        -:  799:  HIDE_OPTION,
        -:  800:  INDICATOR_STYLE_OPTION,
        -:  801:  QUOTING_STYLE_OPTION,
        -:  802:  SHOW_CONTROL_CHARS_OPTION,
        -:  803:  SI_OPTION,
        -:  804:  SORT_OPTION,
        -:  805:  TIME_OPTION,
        -:  806:  TIME_STYLE_OPTION
        -:  807:};
        -:  808:
        -:  809:static struct option const long_options[] =
        -:  810:{
        -:  811:  {"all", no_argument, NULL, 'a'},
        -:  812:  {"escape", no_argument, NULL, 'b'},
        -:  813:  {"directory", no_argument, NULL, 'd'},
        -:  814:  {"dired", no_argument, NULL, 'D'},
        -:  815:  {"full-time", no_argument, NULL, FULL_TIME_OPTION},
        -:  816:  {"group-directories-first", no_argument, NULL,
        -:  817:   GROUP_DIRECTORIES_FIRST_OPTION},
        -:  818:  {"human-readable", no_argument, NULL, 'h'},
        -:  819:  {"inode", no_argument, NULL, 'i'},
        -:  820:  {"kibibytes", no_argument, NULL, 'k'},
        -:  821:  {"numeric-uid-gid", no_argument, NULL, 'n'},
        -:  822:  {"no-group", no_argument, NULL, 'G'},
        -:  823:  {"hide-control-chars", no_argument, NULL, 'q'},
        -:  824:  {"reverse", no_argument, NULL, 'r'},
        -:  825:  {"size", no_argument, NULL, 's'},
        -:  826:  {"width", required_argument, NULL, 'w'},
        -:  827:  {"almost-all", no_argument, NULL, 'A'},
        -:  828:  {"ignore-backups", no_argument, NULL, 'B'},
        -:  829:  {"classify", no_argument, NULL, 'F'},
        -:  830:  {"file-type", no_argument, NULL, FILE_TYPE_INDICATOR_OPTION},
        -:  831:  {"si", no_argument, NULL, SI_OPTION},
        -:  832:  {"dereference-command-line", no_argument, NULL, 'H'},
        -:  833:  {"dereference-command-line-symlink-to-dir", no_argument, NULL,
        -:  834:   DEREFERENCE_COMMAND_LINE_SYMLINK_TO_DIR_OPTION},
        -:  835:  {"hide", required_argument, NULL, HIDE_OPTION},
        -:  836:  {"ignore", required_argument, NULL, 'I'},
        -:  837:  {"indicator-style", required_argument, NULL, INDICATOR_STYLE_OPTION},
        -:  838:  {"dereference", no_argument, NULL, 'L'},
        -:  839:  {"literal", no_argument, NULL, 'N'},
        -:  840:  {"quote-name", no_argument, NULL, 'Q'},
        -:  841:  {"quoting-style", required_argument, NULL, QUOTING_STYLE_OPTION},
        -:  842:  {"recursive", no_argument, NULL, 'R'},
        -:  843:  {"format", required_argument, NULL, FORMAT_OPTION},
        -:  844:  {"show-control-chars", no_argument, NULL, SHOW_CONTROL_CHARS_OPTION},
        -:  845:  {"sort", required_argument, NULL, SORT_OPTION},
        -:  846:  {"tabsize", required_argument, NULL, 'T'},
        -:  847:  {"time", required_argument, NULL, TIME_OPTION},
        -:  848:  {"time-style", required_argument, NULL, TIME_STYLE_OPTION},
        -:  849:  {"color", optional_argument, NULL, COLOR_OPTION},
        -:  850:  {"block-size", required_argument, NULL, BLOCK_SIZE_OPTION},
        -:  851:  {"context", no_argument, 0, 'Z'},
        -:  852:  {"author", no_argument, NULL, AUTHOR_OPTION},
        -:  853:  {GETOPT_HELP_OPTION_DECL},
        -:  854:  {GETOPT_VERSION_OPTION_DECL},
        -:  855:  {NULL, 0, NULL, 0}
        -:  856:};
        -:  857:
        -:  858:static char const *const format_args[] =
        -:  859:{
        -:  860:  "verbose", "long", "commas", "horizontal", "across",
        -:  861:  "vertical", "single-column", NULL
        -:  862:};
        -:  863:static enum format const format_types[] =
        -:  864:{
        -:  865:  long_format, long_format, with_commas, horizontal, horizontal,
        -:  866:  many_per_line, one_per_line
        -:  867:};
        -:  868:ARGMATCH_VERIFY (format_args, format_types);
        -:  869:
        -:  870:static char const *const sort_args[] =
        -:  871:{
        -:  872:  "none", "time", "size", "extension", "version", NULL
        -:  873:};
        -:  874:static enum sort_type const sort_types[] =
        -:  875:{
        -:  876:  sort_none, sort_time, sort_size, sort_extension, sort_version
        -:  877:};
        -:  878:ARGMATCH_VERIFY (sort_args, sort_types);
        -:  879:
        -:  880:static char const *const time_args[] =
        -:  881:{
        -:  882:  "atime", "access", "use", "ctime", "status", NULL
        -:  883:};
        -:  884:static enum time_type const time_types[] =
        -:  885:{
        -:  886:  time_atime, time_atime, time_atime, time_ctime, time_ctime
        -:  887:};
        -:  888:ARGMATCH_VERIFY (time_args, time_types);
        -:  889:
        -:  890:static char const *const color_args[] =
        -:  891:{
        -:  892:  /* force and none are for compatibility with another color-ls version */
        -:  893:  "always", "yes", "force",
        -:  894:  "never", "no", "none",
        -:  895:  "auto", "tty", "if-tty", NULL
        -:  896:};
        -:  897:static enum color_type const color_types[] =
        -:  898:{
        -:  899:  color_always, color_always, color_always,
        -:  900:  color_never, color_never, color_never,
        -:  901:  color_if_tty, color_if_tty, color_if_tty
        -:  902:};
        -:  903:ARGMATCH_VERIFY (color_args, color_types);
        -:  904:
        -:  905:/* Information about filling a column.  */
        -:  906:struct column_info
        -:  907:{
        -:  908:  bool valid_len;
        -:  909:  size_t line_len;
        -:  910:  size_t *col_arr;
        -:  911:};
        -:  912:
        -:  913:/* Array with information about column filledness.  */
        -:  914:static struct column_info *column_info;
        -:  915:
        -:  916:/* Maximum number of columns ever possible for this display.  */
        -:  917:static size_t max_idx;
        -:  918:
        -:  919:/* The minimum width of a column is 3: 1 character for the name and 2
        -:  920:   for the separating white space.  */
        -:  921:#define MIN_COLUMN_WIDTH	3
        -:  922:
        -:  923:
        -:  924:/* This zero-based index is used solely with the --dired option.
        -:  925:   When that option is in effect, this counter is incremented for each
        -:  926:   byte of output generated by this program so that the beginning
        -:  927:   and ending indices (in that output) of every file name can be recorded
        -:  928:   and later output themselves.  */
        -:  929:static size_t dired_pos;
        -:  930:
        -:  931:#define DIRED_PUTCHAR(c) do {putchar ((c)); ++dired_pos;} while (0)
        -:  932:
        -:  933:/* Write S to STREAM and increment DIRED_POS by S_LEN.  */
        -:  934:#define DIRED_FPUTS(s, stream, s_len) \
        -:  935:    do {fputs (s, stream); dired_pos += s_len;} while (0)
        -:  936:
        -:  937:/* Like DIRED_FPUTS, but for use when S is a literal string.  */
        -:  938:#define DIRED_FPUTS_LITERAL(s, stream) \
        -:  939:    do {fputs (s, stream); dired_pos += sizeof (s) - 1;} while (0)
        -:  940:
        -:  941:#define DIRED_INDENT()							\
        -:  942:    do									\
        -:  943:      {									\
        -:  944:        if (dired)							\
        -:  945:          DIRED_FPUTS_LITERAL ("  ", stdout);				\
        -:  946:      }									\
        -:  947:    while (0)
        -:  948:
        -:  949:/* With --dired, store pairs of beginning and ending indices of file names.  */
        -:  950:static struct obstack dired_obstack;
        -:  951:
        -:  952:/* With --dired, store pairs of beginning and ending indices of any
        -:  953:   directory names that appear as headers (just before 'total' line)
        -:  954:   for lists of directory entries.  Such directory names are seen when
        -:  955:   listing hierarchies using -R and when a directory is listed with at
        -:  956:   least one other command line argument.  */
        -:  957:static struct obstack subdired_obstack;
        -:  958:
        -:  959:/* Save the current index on the specified obstack, OBS.  */
        -:  960:#define PUSH_CURRENT_DIRED_POS(obs)					\
        -:  961:  do									\
        -:  962:    {									\
        -:  963:      if (dired)							\
        -:  964:        obstack_grow (obs, &dired_pos, sizeof (dired_pos));		\
        -:  965:    }									\
        -:  966:  while (0)
        -:  967:
        -:  968:/* With -R, this stack is used to help detect directory cycles.
        -:  969:   The device/inode pairs on this stack mirror the pairs in the
        -:  970:   active_dir_set hash table.  */
        -:  971:static struct obstack dev_ino_obstack;
        -:  972:
        -:  973:/* Push a pair onto the device/inode stack.  */
    #####:  974:static void
        -:  975:dev_ino_push (dev_t dev, ino_t ino)
        -:  976:{
        -:  977:  void *vdi;
    #####:  978:  struct dev_ino *di;
    #####:  979:  int dev_ino_size = sizeof *di;
    #####:  980:  obstack_blank (&dev_ino_obstack, dev_ino_size);
    #####:  981:  vdi = obstack_next_free (&dev_ino_obstack);
    #####:  982:  di = vdi;
    #####:  983:  di--;
    #####:  984:  di->st_dev = dev;
    #####:  985:  di->st_ino = ino;
        -:  986:}
        -:  987:
        -:  988:/* Pop a dev/ino struct off the global dev_ino_obstack
        -:  989:   and return that struct.  */
    #####:  990:static struct dev_ino
        -:  991:dev_ino_pop (void)
        -:  992:{
        -:  993:  void *vdi;
    #####:  994:  struct dev_ino *di;
    #####:  995:  int dev_ino_size = sizeof *di;
    #####:  996:  assert (dev_ino_size <= obstack_object_size (&dev_ino_obstack));
    #####:  997:  obstack_blank_fast (&dev_ino_obstack, -dev_ino_size);
    #####:  998:  vdi = obstack_next_free (&dev_ino_obstack);
    #####:  999:  di = vdi;
        -: 1000:  return *di;
        -: 1001:}
        -: 1002:
        -: 1003:/* Note the use commented out below:
        -: 1004:#define ASSERT_MATCHING_DEV_INO(Name, Di)	\
        -: 1005:  do						\
        -: 1006:    {						\
        -: 1007:      struct stat sb;				\
        -: 1008:      assert (Name);				\
        -: 1009:      assert (0 <= stat (Name, &sb));		\
        -: 1010:      assert (sb.st_dev == Di.st_dev);		\
        -: 1011:      assert (sb.st_ino == Di.st_ino);		\
        -: 1012:    }						\
        -: 1013:  while (0)
        -: 1014:*/
        -: 1015:
        -: 1016:/* Write to standard output PREFIX, followed by the quoting style and
        -: 1017:   a space-separated list of the integers stored in OS all on one line.  */
        -: 1018:
    #####: 1019:static void
        -: 1020:dired_dump_obstack (const char *prefix, struct obstack *os)
        -: 1021:{
        -: 1022:  size_t n_pos;
    #####: 1023:
    #####: 1024:  n_pos = obstack_object_size (os) / sizeof (dired_pos);
        -: 1025:  if (n_pos > 0)
        -: 1026:    {
        -: 1027:      size_t i;
        -: 1028:      size_t *pos;
    #####: 1029:
    #####: 1030:      pos = (size_t *) obstack_finish (os);
    #####: 1031:      fputs (prefix, stdout);
    #####: 1032:      for (i = 0; i < n_pos; i++)
        -: 1033:        printf (" %lu", (unsigned long int) pos[i]);
        -: 1034:      putchar ('\n');
    #####: 1035:    }
        -: 1036:}
        -: 1037:
        -: 1038:/* Read the abbreviated month names from the locale, to align them
        -: 1039:   and to determine the max width of the field and to truncate names
        -: 1040:   greater than our max allowed.
        -: 1041:   Note even though this handles multibyte locales correctly
        -: 1042:   it's not restricted to them as single byte locales can have
        -: 1043:   variable width abbreviated months and also precomputing/caching
        -: 1044:   the names was seen to increase the performance of ls significantly.  */
        -: 1045:
        -: 1046:/* max number of display cells to use */
        -: 1047:enum { MAX_MON_WIDTH = 5 };
        -: 1048:/* In the unlikely event that the abmon[] storage is not big enough
        -: 1049:   an error message will be displayed, and we revert to using
        -: 1050:   unmodified abbreviated month names from the locale database.  */
        -: 1051:static char abmon[12][MAX_MON_WIDTH * 2 * MB_LEN_MAX + 1];
        -: 1052:/* minimum width needed to align %b, 0 => don't use precomputed values.  */
        -: 1053:static size_t required_mon_width;
        -: 1054:
      129: 1055:static size_t
        -: 1056:abmon_init (void)
        -: 1057:{
      129: 1058:#ifdef HAVE_NL_LANGINFO
        -: 1059:  required_mon_width = MAX_MON_WIDTH;
        -: 1060:  size_t curr_max_width;
        -: 1061:  do
      258: 1062:    {
      258: 1063:      curr_max_width = required_mon_width;
     3354: 1064:      required_mon_width = 0;
        -: 1065:      for (int i = 0; i < 12; i++)
     3096: 1066:        {
        -: 1067:          size_t width = curr_max_width;
     3096: 1068:
     3096: 1069:          size_t req = mbsalign (nl_langinfo (ABMON_1 + i),
        -: 1070:                                 abmon[i], sizeof (abmon[i]),
        -: 1071:                                 &width, MBS_ALIGN_LEFT, 0);
     3096: 1072:
        -: 1073:          if (req == (size_t) -1 || req >= sizeof (abmon[i]))
    #####: 1074:            {
    #####: 1075:              required_mon_width = 0; /* ignore precomputed strings.  */
        -: 1076:              return required_mon_width;
        -: 1077:            }
     3096: 1078:
        -: 1079:          required_mon_width = MAX (required_mon_width, width);
        -: 1080:        }
      258: 1081:    }
        -: 1082:  while (curr_max_width > required_mon_width);
        -: 1083:#endif
        -: 1084:
        -: 1085:  return required_mon_width;
        -: 1086:}
        -: 1087:
    #####: 1088:static size_t
        -: 1089:dev_ino_hash (void const *x, size_t table_size)
    #####: 1090:{
    #####: 1091:  struct dev_ino const *p = x;
        -: 1092:  return (uintmax_t) p->st_ino % table_size;
        -: 1093:}
        -: 1094:
    #####: 1095:static bool
        -: 1096:dev_ino_compare (void const *x, void const *y)
    #####: 1097:{
    #####: 1098:  struct dev_ino const *a = x;
    #####: 1099:  struct dev_ino const *b = y;
        -: 1100:  return SAME_INODE (*a, *b) ? true : false;
        -: 1101:}
        -: 1102:
    #####: 1103:static void
        -: 1104:dev_ino_free (void *x)
    #####: 1105:{
    #####: 1106:  free (x);
        -: 1107:}
        -: 1108:
        -: 1109:/* Add the device/inode pair (P->st_dev/P->st_ino) to the set of
        -: 1110:   active directories.  Return true if there is already a matching
        -: 1111:   entry in the table.  */
        -: 1112:
    #####: 1113:static bool
        -: 1114:visit_dir (dev_t dev, ino_t ino)
        -: 1115:{
        -: 1116:  struct dev_ino *ent;
        -: 1117:  struct dev_ino *ent_from_table;
        -: 1118:  bool found_match;
    #####: 1119:
    #####: 1120:  ent = xmalloc (sizeof *ent);
    #####: 1121:  ent->st_ino = ino;
        -: 1122:  ent->st_dev = dev;
        -: 1123:
    #####: 1124:  /* Attempt to insert this entry into the table.  */
        -: 1125:  ent_from_table = hash_insert (active_dir_set, ent);
    #####: 1126:
        -: 1127:  if (ent_from_table == NULL)
        -: 1128:    {
    #####: 1129:      /* Insertion failed due to lack of memory.  */
        -: 1130:      xalloc_die ();
        -: 1131:    }
    #####: 1132:
        -: 1133:  found_match = (ent_from_table != ent);
    #####: 1134:
        -: 1135:  if (found_match)
        -: 1136:    {
    #####: 1137:      /* ent was not inserted, so free it.  */
        -: 1138:      free (ent);
        -: 1139:    }
    #####: 1140:
        -: 1141:  return found_match;
        -: 1142:}
        -: 1143:
       80: 1144:static void
        -: 1145:free_pending_ent (struct pending *p)
       80: 1146:{
       80: 1147:  free (p->name);
       80: 1148:  free (p->realname);
       80: 1149:  free (p);
        -: 1150:}
        -: 1151:
    62696: 1152:static bool
        -: 1153:is_colored (enum indicator_no type)
    62696: 1154:{
    62696: 1155:  size_t len = color_indicator[type].len;
   163382: 1156:  char const *s = color_indicator[type].string;
    37990: 1157:  return ! (len == 0
       32: 1158:            || (len == 1 && STRNCMP_LIT (s, "0") == 0)
        -: 1159:            || (len == 2 && STRNCMP_LIT (s, "00") == 0));
        -: 1160:}
        -: 1161:
        -: 1162:static void
        -: 1163:restore_default_color (void)
    #####: 1164:{
    #####: 1165:  put_indicator (&color_indicator[C_LEFT]);
        -: 1166:  put_indicator (&color_indicator[C_RIGHT]);
        -: 1167:}
        -: 1168:
    12534: 1169:static void
        -: 1170:set_normal_color (void)
    12534: 1171:{
        -: 1172:  if (print_with_color && is_colored (C_NORM))
    #####: 1173:    {
    #####: 1174:      put_indicator (&color_indicator[C_LEFT]);
    #####: 1175:      put_indicator (&color_indicator[C_NORM]);
        -: 1176:      put_indicator (&color_indicator[C_RIGHT]);
    12534: 1177:    }
        -: 1178:}
        -: 1179:
        -: 1180:/* An ordinary signal was received; arrange for the program to exit.  */
        -: 1181:
    #####: 1182:static void
        -: 1183:sighandler (int sig)
        -: 1184:{
        -: 1185:  if (! SA_NOCLDSTOP)
    #####: 1186:    signal (sig, SIG_IGN);
    #####: 1187:  if (! interrupt_signal)
    #####: 1188:    interrupt_signal = sig;
        -: 1189:}
        -: 1190:
        -: 1191:/* A SIGTSTP was received; arrange for the program to suspend itself.  */
        -: 1192:
    #####: 1193:static void
        -: 1194:stophandler (int sig)
        -: 1195:{
        -: 1196:  if (! SA_NOCLDSTOP)
    #####: 1197:    signal (sig, stophandler);
    #####: 1198:  if (! interrupt_signal)
    #####: 1199:    stop_signal_count++;
        -: 1200:}
        -: 1201:
        -: 1202:/* Process any pending signals.  If signals are caught, this function
        -: 1203:   should be called periodically.  Ideally there should never be an
        -: 1204:   unbounded amount of time when signals are not being processed.
        -: 1205:   Signal handling can restore the default colors, so callers must
        -: 1206:   immediately change colors after invoking this function.  */
        -: 1207:
    25202: 1208:static void
        -: 1209:process_signals (void)
    50404: 1210:{
        -: 1211:  while (interrupt_signal || stop_signal_count)
        -: 1212:    {
        -: 1213:      int sig;
        -: 1214:      int stops;
        -: 1215:      sigset_t oldset;
    #####: 1216:
        -: 1217:      if (used_color)
    #####: 1218:        restore_default_color ();
        -: 1219:      fflush (stdout);
    #####: 1220:
        -: 1221:      sigprocmask (SIG_BLOCK, &caught_signals, &oldset);
        -: 1222:
        -: 1223:      /* Reload interrupt_signal and stop_signal_count, in case a new
    #####: 1224:         signal was handled before sigprocmask took effect.  */
    #####: 1225:      sig = interrupt_signal;
        -: 1226:      stops = stop_signal_count;
        -: 1227:
        -: 1228:      /* SIGTSTP is special, since the application can receive that signal
        -: 1229:         more than once.  In this case, don't set the signal handler to the
    #####: 1230:         default.  Instead, just raise the uncatchable SIGSTOP.  */
        -: 1231:      if (stops)
    #####: 1232:        {
    #####: 1233:          stop_signal_count = stops - 1;
        -: 1234:          sig = SIGSTOP;
        -: 1235:        }
    #####: 1236:      else
        -: 1237:        signal (sig, SIG_DFL);
        -: 1238:
    #####: 1239:      /* Exit or suspend the program.  */
    #####: 1240:      raise (sig);
        -: 1241:      sigprocmask (SIG_SETMASK, &oldset, NULL);
        -: 1242:
        -: 1243:      /* If execution reaches here, then the program has been
        -: 1244:         continued (after being suspended).  */
    25202: 1245:    }
        -: 1246:}
        -: 1247:
      248: 1248:int
        -: 1249:main (int argc, char **argv)
        -: 1250:{
        -: 1251:  AFL_INIT_ARGV();
        -: 1252:  int i;
        -: 1253:  struct pending *thispend;
        -: 1254:  int n_files;
        -: 1255:
        -: 1256:  /* The signals that are trapped, and the number of such signals.  */
        -: 1257:  static int const sig[] =
        -: 1258:    {
        -: 1259:      /* This one is handled specially.  */
        -: 1260:      SIGTSTP,
        -: 1261:
        -: 1262:      /* The usual suspects.  */
        -: 1263:      SIGALRM, SIGHUP, SIGINT, SIGPIPE, SIGQUIT, SIGTERM,
        -: 1264:#ifdef SIGPOLL
        -: 1265:      SIGPOLL,
        -: 1266:#endif
        -: 1267:#ifdef SIGPROF
        -: 1268:      SIGPROF,
        -: 1269:#endif
        -: 1270:#ifdef SIGVTALRM
        -: 1271:      SIGVTALRM,
        -: 1272:#endif
        -: 1273:#ifdef SIGXCPU
        -: 1274:      SIGXCPU,
        -: 1275:#endif
        -: 1276:#ifdef SIGXFSZ
        -: 1277:      SIGXFSZ,
        -: 1278:#endif
        -: 1279:    };
        -: 1280:  enum { nsigs = ARRAY_CARDINALITY (sig) };
        -: 1281:
        -: 1282:#if ! SA_NOCLDSTOP
        -: 1283:  bool caught_sig[nsigs];
        -: 1284:#endif
      248: 1285:
      248: 1286:  initialize_main (&argc, &argv);
      248: 1287:  set_program_name (argv[0]);
      248: 1288:  setlocale (LC_ALL, "");
        -: 1289:  bindtextdomain (PACKAGE, LOCALEDIR);
      248: 1290:  textdomain (PACKAGE);
      248: 1291:
        -: 1292:  initialize_exit_failure (LS_FAILURE);
        -: 1293:  atexit (close_stdout);
        -: 1294:
        -: 1295:  assert (ARRAY_CARDINALITY (color_indicator) + 1
      248: 1296:          == ARRAY_CARDINALITY (indicator_name));
      248: 1297:
      248: 1298:  exit_status = EXIT_SUCCESS;
        -: 1299:  print_dir_name = true;
      248: 1300:  pending_dirs = NULL;
      248: 1301:
        -: 1302:  current_time.tv_sec = TYPE_MINIMUM (time_t);
      248: 1303:  current_time.tv_nsec = -1;
        -: 1304:
      242: 1305:  i = decode_switches (argc, argv);
       80: 1306:
        -: 1307:  if (print_with_color)
        -: 1308:    parse_ls_color ();
        -: 1309:
      242: 1310:  /* Test print_with_color again, because the call to parse_ls_color
        -: 1311:     may have just reset it -- e.g., if LS_COLORS is invalid.  */
        -: 1312:  if (print_with_color)
       80: 1313:    {
    #####: 1314:      /* Avoid following symbolic links when possible.  */
    #####: 1315:      if (is_colored (C_ORPHAN)
       80: 1316:          || (is_colored (C_EXEC) && color_symlink_as_referent)
        -: 1317:          || (is_colored (C_MISSING) && format == long_format))
        -: 1318:        check_symlink_color = true;
        -: 1319:
        -: 1320:      /* If the standard output is a controlling terminal, watch out
        -: 1321:         for signals, so that the colors can be restored to the
       80: 1322:         default state if "ls" is suspended or interrupted.  */
        -: 1323:
        -: 1324:      if (0 <= tcgetpgrp (STDOUT_FILENO))
        -: 1325:        {
        -: 1326:          int j;
        -: 1327:#if SA_NOCLDSTOP
       80: 1328:          struct sigaction act;
     1040: 1329:
        -: 1330:          sigemptyset (&caught_signals);
      960: 1331:          for (j = 0; j < nsigs; j++)
      960: 1332:            {
      960: 1333:              sigaction (sig[j], NULL, &act);
        -: 1334:              if (act.sa_handler != SIG_IGN)
        -: 1335:                sigaddset (&caught_signals, sig[j]);
       80: 1336:            }
       80: 1337:
        -: 1338:          act.sa_mask = caught_signals;
     1040: 1339:          act.sa_flags = SA_RESTART;
      960: 1340:
        -: 1341:          for (j = 0; j < nsigs; j++)
      960: 1342:            if (sigismember (&caught_signals, sig[j]))
      960: 1343:              {
        -: 1344:                act.sa_handler = sig[j] == SIGTSTP ? stophandler : sighandler;
        -: 1345:                sigaction (sig[j], &act, NULL);
        -: 1346:              }
        -: 1347:#else
        -: 1348:          for (j = 0; j < nsigs; j++)
        -: 1349:            {
        -: 1350:              caught_sig[j] = (signal (sig[j], SIG_IGN) != SIG_IGN);
        -: 1351:              if (caught_sig[j])
        -: 1352:                {
        -: 1353:                  signal (sig[j], sig[j] == SIGTSTP ? stophandler : sighandler);
        -: 1354:                  siginterrupt (sig[j], 0);
        -: 1355:                }
        -: 1356:            }
        -: 1357:#endif
        -: 1358:        }
      242: 1359:    }
      470: 1360:
       86: 1361:  if (dereference == DEREF_UNDEFINED)
       85: 1362:    dereference = ((immediate_dirs
        -: 1363:                    || indicator_style == classify
        -: 1364:                    || format == long_format)
        -: 1365:                   ? DEREF_NEVER
        -: 1366:                   : DEREF_COMMAND_LINE_SYMLINK_TO_DIR);
        -: 1367:
      242: 1368:  /* When using -R, initialize a data structure we'll use to
        -: 1369:     detect any directory cycles.  */
    #####: 1370:  if (recursive)
        -: 1371:    {
        -: 1372:      active_dir_set = hash_initialize (INITIAL_TABLE_SIZE, NULL,
        -: 1373:                                        dev_ino_hash,
    #####: 1374:                                        dev_ino_compare,
    #####: 1375:                                        dev_ino_free);
        -: 1376:      if (active_dir_set == NULL)
    #####: 1377:        xalloc_die ();
        -: 1378:
        -: 1379:      obstack_init (&dev_ino_obstack);
      242: 1380:    }
        -: 1381:
      484: 1382:  localtz = tzalloc (getenv ("TZ"));
      235: 1383:
      106: 1384:  format_needs_stat = sort_type == sort_time || sort_type == sort_size
      348: 1385:    || format == long_format
      242: 1386:    || print_scontext
      484: 1387:    || print_block_size;
      106: 1388:  format_needs_type = (! format_needs_stat
       26: 1389:                       && (recursive
       26: 1390:                           || print_with_color
        -: 1391:                           || indicator_style != none
      242: 1392:                           || directories_first));
        -: 1393:
    #####: 1394:  if (dired)
    #####: 1395:    {
        -: 1396:      obstack_init (&dired_obstack);
        -: 1397:      obstack_init (&subdired_obstack);
      242: 1398:    }
      484: 1399:
      242: 1400:  cwd_n_alloc = 100;
        -: 1401:  cwd_file = xnmalloc (cwd_n_alloc, sizeof *cwd_file);
      242: 1402:  cwd_n_used = 0;
        -: 1403:
      242: 1404:  clear_files ();
        -: 1405:
      242: 1406:  n_files = argc - i;
        -: 1407:
       80: 1408:  if (n_files <= 0)
    #####: 1409:    {
        -: 1410:      if (immediate_dirs)
       80: 1411:        gobble_file (".", directory, NOT_AN_INODE_NUMBER, true, "");
        -: 1412:      else
        -: 1413:        queue_directory (".", NULL, true);
        -: 1414:    }
      181: 1415:  else
      181: 1416:    do
        -: 1417:      gobble_file (argv[i++], unknown, NOT_AN_INODE_NUMBER, true, "");
      242: 1418:    while (i < argc);
        -: 1419:
      162: 1420:  if (cwd_n_used)
      162: 1421:    {
       13: 1422:      sort_files ();
        -: 1423:      if (!immediate_dirs)
        -: 1424:        extract_dirs_from_files (NULL, true);
        -: 1425:      /* 'cwd_n_used' might be zero now.  */
        -: 1426:    }
        -: 1427:
        -: 1428:  /* In the following if/else blocks, it is sufficient to test 'pending_dirs'
        -: 1429:     (and not pending_dirs->name) because there may be no markers in the queue
      242: 1430:     at this point.  A marker may be enqueued when extract_dirs_from_files is
        -: 1431:     called with a non-empty string or via print_dir.  */
      162: 1432:  if (cwd_n_used)
      162: 1433:    {
    #####: 1434:      print_current_files ();
        -: 1435:      if (pending_dirs)
       80: 1436:        DIRED_PUTCHAR ('\n');
       80: 1437:    }
        -: 1438:  else if (n_files <= 1 && pending_dirs && pending_dirs->next == 0)
      322: 1439:    print_dir_name = false;
        -: 1440:
       80: 1441:  while (pending_dirs)
       80: 1442:    {
        -: 1443:      thispend = pending_dirs;
       80: 1444:      pending_dirs = pending_dirs->next;
        -: 1445:
    #####: 1446:      if (LOOP_DETECT)
        -: 1447:        {
        -: 1448:          if (thispend->name == NULL)
        -: 1449:            {
        -: 1450:              /* thispend->name == NULL means this is a marker entry
        -: 1451:                 indicating we've finished processing the directory.
    #####: 1452:                 Use its dev/ino numbers to remove the corresponding
    #####: 1453:                 entry from the active_dir_set hash table.  */
        -: 1454:              struct dev_ino di = dev_ino_pop ();
    #####: 1455:              struct dev_ino *found = hash_delete (active_dir_set, &di);
    #####: 1456:              /* ASSERT_MATCHING_DEV_INO (thispend->realname, di); */
    #####: 1457:              assert (found);
    #####: 1458:              dev_ino_free (found);
        -: 1459:              free_pending_ent (thispend);
        -: 1460:              continue;
        -: 1461:            }
       80: 1462:        }
       80: 1463:
        -: 1464:      print_dir (thispend->name, thispend->realname,
       80: 1465:                 thispend->command_line_arg);
       80: 1466:
        -: 1467:      free_pending_ent (thispend);
        -: 1468:      print_dir_name = true;
      242: 1469:    }
        -: 1470:
        -: 1471:  if (print_with_color)
        -: 1472:    {
       80: 1473:      int j;
        -: 1474:
        -: 1475:      if (used_color)
        -: 1476:        {
       88: 1477:          /* Skip the restore when it would be a no-op, i.e.,
       44: 1478:             when left is "\033[" and right is "m".  */
       44: 1479:          if (!(color_indicator[C_LEFT].len == 2
       44: 1480:                && memcmp (color_indicator[C_LEFT].string, "\033[", 2) == 0
        -: 1481:                && color_indicator[C_RIGHT].len == 1
        -: 1482:                && color_indicator[C_RIGHT].string[0] == 'm'))
       80: 1483:            restore_default_color ();
        -: 1484:        }
        -: 1485:      fflush (stdout);
        -: 1486:
     1040: 1487:      /* Restore the default signal handling.  */
      960: 1488:#if SA_NOCLDSTOP
      960: 1489:      for (j = 0; j < nsigs; j++)
        -: 1490:        if (sigismember (&caught_signals, sig[j]))
        -: 1491:          signal (sig[j], SIG_DFL);
        -: 1492:#else
        -: 1493:      for (j = 0; j < nsigs; j++)
        -: 1494:        if (caught_sig[j])
        -: 1495:          signal (sig[j], SIG_DFL);
        -: 1496:#endif
        -: 1497:
        -: 1498:      /* Act on any signals that arrived before the default was restored.
        -: 1499:         This can process signals out of order, but there doesn't seem to
       80: 1500:         be an easy way to do them in order, and the order isn't that
    #####: 1501:         important anyway.  */
       80: 1502:      for (j = stop_signal_count; j; j--)
       80: 1503:        raise (SIGSTOP);
    #####: 1504:      j = interrupt_signal;
        -: 1505:      if (j)
        -: 1506:        raise (j);
      242: 1507:    }
        -: 1508:
        -: 1509:  if (dired)
    #####: 1510:    {
    #####: 1511:      /* No need to free these since we're about to exit.  */
    #####: 1512:      dired_dump_obstack ("//DIRED//", &dired_obstack);
    #####: 1513:      dired_dump_obstack ("//SUBDIRED//", &subdired_obstack);
        -: 1514:      printf ("//DIRED-OPTIONS// --quoting-style=%s\n",
        -: 1515:              quoting_style_args[get_quoting_style (filename_quoting_options)]);
      242: 1516:    }
        -: 1517:
    #####: 1518:  if (LOOP_DETECT)
    #####: 1519:    {
        -: 1520:      assert (hash_get_n_entries (active_dir_set) == 0);
        -: 1521:      hash_free (active_dir_set);
      242: 1522:    }
        -: 1523:
        -: 1524:  return exit_status;
        -: 1525:}
        -: 1526:
        -: 1527:/* Set the line length to the value given by SPEC.  Return true if
        -: 1528:   successful.  0 means no limit on line length.  */
    #####: 1529:
        -: 1530:static bool
        -: 1531:set_line_length (char const *spec)
        -: 1532:{
        -: 1533:  uintmax_t val;
        -: 1534:
    #####: 1535:  /* Treat too-large values as if they were SIZE_MAX, which is
        -: 1536:     effectively infinity.  */
        -: 1537:  switch (xstrtoumax (spec, NULL, 0, &val, ""))
    #####: 1538:    {
    #####: 1539:    case LONGINT_OK:
        -: 1540:      line_length = MIN (val, SIZE_MAX);
        -: 1541:      return true;
    #####: 1542:
    #####: 1543:    case LONGINT_OVERFLOW:
        -: 1544:      line_length = SIZE_MAX;
        -: 1545:      return true;
        -: 1546:
        -: 1547:    default:
        -: 1548:      return false;
        -: 1549:    }
        -: 1550:}
        -: 1551:
        -: 1552:/* Set all the option flags according to the switches specified.
        -: 1553:   Return the index of the first non-option argument.  */
      248: 1554:
        -: 1555:static int
      248: 1556:decode_switches (int argc, char **argv)
        -: 1557:{
      248: 1558:  char *time_style_option = NULL;
      248: 1559:
        -: 1560:  bool sort_type_specified = false;
      248: 1561:  bool kibibytes_specified = false;
        -: 1562:
        -: 1563:  qmark_funny_chars = false;
        -: 1564:
      248: 1565:  /* initialize all switches to default settings */
        -: 1566:
        -: 1567:  switch (ls_mode)
        -: 1568:    {
        2: 1569:    case LS_MULTI_COL:
        2: 1570:      /* This is for the 'dir' program.  */
        2: 1571:      format = many_per_line;
        -: 1572:      set_quoting_style (NULL, escape_quoting_style);
        -: 1573:      break;
        -: 1574:
        2: 1575:    case LS_LONG_FORMAT:
        2: 1576:      /* This is for the 'vdir' program.  */
        2: 1577:      format = long_format;
        -: 1578:      set_quoting_style (NULL, escape_quoting_style);
        -: 1579:      break;
        -: 1580:
      244: 1581:    case LS_LS:
        -: 1582:      /* This is for the 'ls' program.  */
       80: 1583:      if (isatty (STDOUT_FILENO))
       80: 1584:        {
        -: 1585:          format = many_per_line;
       80: 1586:          set_quoting_style (NULL, shell_escape_quoting_style);
        -: 1587:          /* See description of qmark_funny_chars, above.  */
        -: 1588:          qmark_funny_chars = true;
        -: 1589:        }
      164: 1590:      else
      164: 1591:        {
        -: 1592:          format = one_per_line;
        -: 1593:          qmark_funny_chars = false;
        -: 1594:        }
        -: 1595:      break;
    #####: 1596:
        -: 1597:    default:
        -: 1598:      abort ();
      248: 1599:    }
      248: 1600:
      248: 1601:  time_type = time_mtime;
      248: 1602:  sort_type = sort_name;
      248: 1603:  sort_reverse = false;
      248: 1604:  numeric_ids = false;
      248: 1605:  print_block_size = false;
      248: 1606:  indicator_style = none;
      248: 1607:  print_inode = false;
      248: 1608:  dereference = DEREF_UNDEFINED;
      248: 1609:  recursive = false;
      248: 1610:  immediate_dirs = false;
      248: 1611:  ignore_mode = IGNORE_DEFAULT;
      248: 1612:  ignore_patterns = NULL;
        -: 1613:  hide_patterns = NULL;
      248: 1614:  print_scontext = false;
        -: 1615:
      248: 1616:  getenv_quoting_style ();
        -: 1617:
      248: 1618:  line_length = 80;
      248: 1619:  {
    #####: 1620:    char const *p = getenv ("COLUMNS");
    #####: 1621:    if (p && *p && ! set_line_length (p))
        -: 1622:      error (0, 0,
        -: 1623:             _("ignoring invalid width in environment variable COLUMNS: %s"),
        -: 1624:             quote (p));
        -: 1625:  }
        -: 1626:
        -: 1627:#ifdef TIOCGWINSZ
        -: 1628:  {
      248: 1629:    struct winsize ws;
       80: 1630:
       80: 1631:    if (ioctl (STDOUT_FILENO, TIOCGWINSZ, &ws) != -1
        -: 1632:        && 0 < ws.ws_col && ws.ws_col == (size_t) ws.ws_col)
        -: 1633:      line_length = ws.ws_col;
        -: 1634:  }
        -: 1635:#endif
      248: 1636:
      248: 1637:  {
      248: 1638:    char const *p = getenv ("TABSIZE");
        -: 1639:    tabsize = 8;
        -: 1640:    if (p)
    #####: 1641:      {
        -: 1642:        unsigned long int tmp_ulong;
        -: 1643:        if (xstrtoul (p, NULL, 0, &tmp_ulong, NULL) == LONGINT_OK
    #####: 1644:            && tmp_ulong <= SIZE_MAX)
        -: 1645:          {
        -: 1646:            tabsize = tmp_ulong;
        -: 1647:          }
    #####: 1648:        else
    #####: 1649:          {
        -: 1650:            error (0, 0,
        -: 1651:             _("ignoring invalid tab size in environment variable TABSIZE: %s"),
        -: 1652:                   quote (p));
        -: 1653:          }
        -: 1654:      }
        -: 1655:  }
        -: 1656:
      648: 1657:  while (true)
      648: 1658:    {
        -: 1659:      int oi = -1;
        -: 1660:      int c = getopt_long (argc, argv,
      648: 1661:                           "abcdfghiklmnopqrstuvw:xABCDFGHI:LNQRST:UXZ1",
        -: 1662:                           long_options, &oi);
        -: 1663:      if (c == -1)
      406: 1664:        break;
        -: 1665:
        -: 1666:      switch (c)
    #####: 1667:        {
    #####: 1668:        case 'a':
        -: 1669:          ignore_mode = IGNORE_MINIMAL;
        -: 1670:          break;
    #####: 1671:
    #####: 1672:        case 'b':
        -: 1673:          set_quoting_style (NULL, escape_quoting_style);
        -: 1674:          break;
    #####: 1675:
    #####: 1676:        case 'c':
        -: 1677:          time_type = time_ctime;
        -: 1678:          break;
      149: 1679:
      149: 1680:        case 'd':
        -: 1681:          immediate_dirs = true;
        -: 1682:          break;
        -: 1683:
    #####: 1684:        case 'f':
    #####: 1685:          /* Same as enabling -a -U and disabling -l -s.  */
    #####: 1686:          ignore_mode = IGNORE_MINIMAL;
        -: 1687:          sort_type = sort_none;
    #####: 1688:          sort_type_specified = true;
    #####: 1689:          /* disable -l */
    #####: 1690:          if (format == long_format)
    #####: 1691:            format = (isatty (STDOUT_FILENO) ? many_per_line : one_per_line);
    #####: 1692:          print_block_size = false;	/* disable -s */
        -: 1693:          print_with_color = false;	/* disable --color */
        -: 1694:          break;
    #####: 1695:
    #####: 1696:        case FILE_TYPE_INDICATOR_OPTION: /* --file-type */
        -: 1697:          indicator_style = file_type;
        -: 1698:          break;
    #####: 1699:
    #####: 1700:        case 'g':
    #####: 1701:          format = long_format;
        -: 1702:          print_owner = false;
        -: 1703:          break;
    #####: 1704:
        -: 1705:        case 'h':
    #####: 1706:          file_human_output_opts = human_output_opts =
    #####: 1707:            human_autoscale | human_SI | human_base_1024;
        -: 1708:          file_output_block_size = output_block_size = 1;
        -: 1709:          break;
       26: 1710:
       26: 1711:        case 'i':
        -: 1712:          print_inode = true;
        -: 1713:          break;
        -: 1714:
        -: 1715:        case 'k':
        -: 1716:          kibibytes_specified = true;
        -: 1717:          break;
      129: 1718:
      129: 1719:        case 'l':
        -: 1720:          format = long_format;
        -: 1721:          break;
    #####: 1722:
    #####: 1723:        case 'm':
        -: 1724:          format = with_commas;
        -: 1725:          break;
    #####: 1726:
    #####: 1727:        case 'n':
    #####: 1728:          numeric_ids = true;
        -: 1729:          format = long_format;
        -: 1730:          break;
    #####: 1731:
    #####: 1732:        case 'o':  /* Just like -l, but don't display group info.  */
    #####: 1733:          format = long_format;
        -: 1734:          print_group = false;
        -: 1735:          break;
    #####: 1736:
    #####: 1737:        case 'p':
        -: 1738:          indicator_style = slash;
        -: 1739:          break;
    #####: 1740:
    #####: 1741:        case 'q':
        -: 1742:          qmark_funny_chars = true;
        -: 1743:          break;
    #####: 1744:
    #####: 1745:        case 'r':
        -: 1746:          sort_reverse = true;
        -: 1747:          break;
    #####: 1748:
    #####: 1749:        case 's':
        -: 1750:          print_block_size = true;
        -: 1751:          break;
        7: 1752:
        7: 1753:        case 't':
        7: 1754:          sort_type = sort_time;
        -: 1755:          sort_type_specified = true;
        -: 1756:          break;
    #####: 1757:
    #####: 1758:        case 'u':
        -: 1759:          time_type = time_atime;
        -: 1760:          break;
    #####: 1761:
    #####: 1762:        case 'v':
    #####: 1763:          sort_type = sort_version;
        -: 1764:          sort_type_specified = true;
        -: 1765:          break;
    #####: 1766:
    #####: 1767:        case 'w':
        -: 1768:          if (! set_line_length (optarg))
        -: 1769:            error (LS_FAILURE, 0, "%s: %s", _("invalid line width"),
        -: 1770:                   quote (optarg));
        -: 1771:          break;
    #####: 1772:
    #####: 1773:        case 'x':
        -: 1774:          format = horizontal;
        -: 1775:          break;
    #####: 1776:
    #####: 1777:        case 'A':
        -: 1778:          if (ignore_mode == IGNORE_DEFAULT)
        -: 1779:            ignore_mode = IGNORE_DOT_AND_DOTDOT;
        -: 1780:          break;
    #####: 1781:
        -: 1782:        case 'B':
        -: 1783:          add_ignore_pattern ("*~");
        -: 1784:          add_ignore_pattern (".*~");
        -: 1785:          break;
        1: 1786:
        1: 1787:        case 'C':
        -: 1788:          format = many_per_line;
        -: 1789:          break;
    #####: 1790:
    #####: 1791:        case 'D':
        -: 1792:          dired = true;
        -: 1793:          break;
        1: 1794:
        1: 1795:        case 'F':
        -: 1796:          indicator_style = classify;
        -: 1797:          break;
    #####: 1798:
    #####: 1799:        case 'G':		/* inhibit display of group info */
        -: 1800:          print_group = false;
        -: 1801:          break;
    #####: 1802:
    #####: 1803:        case 'H':
        -: 1804:          dereference = DEREF_COMMAND_LINE_ARGUMENTS;
        -: 1805:          break;
    #####: 1806:
    #####: 1807:        case DEREFERENCE_COMMAND_LINE_SYMLINK_TO_DIR_OPTION:
        -: 1808:          dereference = DEREF_COMMAND_LINE_SYMLINK_TO_DIR;
        -: 1809:          break;
    #####: 1810:
        -: 1811:        case 'I':
        -: 1812:          add_ignore_pattern (optarg);
        -: 1813:          break;
        7: 1814:
        7: 1815:        case 'L':
        -: 1816:          dereference = DEREF_ALWAYS;
        -: 1817:          break;
    #####: 1818:
    #####: 1819:        case 'N':
        -: 1820:          set_quoting_style (NULL, literal_quoting_style);
        -: 1821:          break;
    #####: 1822:
    #####: 1823:        case 'Q':
        -: 1824:          set_quoting_style (NULL, c_quoting_style);
        -: 1825:          break;
    #####: 1826:
    #####: 1827:        case 'R':
        -: 1828:          recursive = true;
        -: 1829:          break;
    #####: 1830:
    #####: 1831:        case 'S':
    #####: 1832:          sort_type = sort_size;
        -: 1833:          sort_type_specified = true;
        -: 1834:          break;
    #####: 1835:
    #####: 1836:        case 'T':
    #####: 1837:          tabsize = xnumtoumax (optarg, 0, 0, SIZE_MAX, "",
        -: 1838:                                _("invalid tab size"), LS_FAILURE);
        -: 1839:          break;
    #####: 1840:
    #####: 1841:        case 'U':
    #####: 1842:          sort_type = sort_none;
        -: 1843:          sort_type_specified = true;
        -: 1844:          break;
    #####: 1845:
    #####: 1846:        case 'X':
    #####: 1847:          sort_type = sort_extension;
        -: 1848:          sort_type_specified = true;
        -: 1849:          break;
        -: 1850:
    #####: 1851:        case '1':
    #####: 1852:          /* -1 has no effect after -l.  */
        -: 1853:          if (format != long_format)
        -: 1854:            format = one_per_line;
        -: 1855:          break;
    #####: 1856:
    #####: 1857:        case AUTHOR_OPTION:
        -: 1858:          print_author = true;
        -: 1859:          break;
        -: 1860:
    #####: 1861:        case HIDE_OPTION:
    #####: 1862:          {
    #####: 1863:            struct ignore_pattern *hide = xmalloc (sizeof *hide);
    #####: 1864:            hide->pattern = optarg;
        -: 1865:            hide->next = hide_patterns;
    #####: 1866:            hide_patterns = hide;
        -: 1867:          }
        -: 1868:          break;
    #####: 1869:
    #####: 1870:        case SORT_OPTION:
    #####: 1871:          sort_type = XARGMATCH ("--sort", optarg, sort_args, sort_types);
        -: 1872:          sort_type_specified = true;
        -: 1873:          break;
    #####: 1874:
    #####: 1875:        case GROUP_DIRECTORIES_FIRST_OPTION:
        -: 1876:          directories_first = true;
        -: 1877:          break;
    #####: 1878:
    #####: 1879:        case TIME_OPTION:
        -: 1880:          time_type = XARGMATCH ("--time", optarg, time_args, time_types);
        -: 1881:          break;
    #####: 1882:
    #####: 1883:        case FORMAT_OPTION:
        -: 1884:          format = XARGMATCH ("--format", optarg, format_args, format_types);
        -: 1885:          break;
    #####: 1886:
    #####: 1887:        case FULL_TIME_OPTION:
    #####: 1888:          format = long_format;
        -: 1889:          time_style_option = bad_cast ("full-iso");
        -: 1890:          break;
        -: 1891:
        -: 1892:        case COLOR_OPTION:
       80: 1893:          {
       80: 1894:            int i;
        -: 1895:            if (optarg)
        -: 1896:              i = XARGMATCH ("--color", optarg, color_args, color_types);
        -: 1897:            else
        -: 1898:              /* Using --color with no argument is equivalent to using
        -: 1899:                 --color=always.  */
       80: 1900:              i = color_always;
      160: 1901:
       80: 1902:            print_with_color = (i == color_always
        -: 1903:                                || (i == color_if_tty
       80: 1904:                                    && isatty (STDOUT_FILENO)));
        -: 1905:
        -: 1906:            if (print_with_color)
        -: 1907:              {
        -: 1908:                /* Don't use TAB characters in output.  Some terminal
       80: 1909:                   emulators can't handle the combination of tabs and
        -: 1910:                   color codes on the same line.  */
        -: 1911:                tabsize = 0;
        -: 1912:              }
        -: 1913:            break;
        -: 1914:          }
    #####: 1915:
        -: 1916:        case INDICATOR_STYLE_OPTION:
        -: 1917:          indicator_style = XARGMATCH ("--indicator-style", optarg,
    #####: 1918:                                       indicator_style_args,
        -: 1919:                                       indicator_style_types);
        -: 1920:          break;
    #####: 1921:
    #####: 1922:        case QUOTING_STYLE_OPTION:
        -: 1923:          set_quoting_style (NULL,
        -: 1924:                             XARGMATCH ("--quoting-style", optarg,
    #####: 1925:                                        quoting_style_args,
        -: 1926:                                        quoting_style_vals));
        -: 1927:          break;
    #####: 1928:
    #####: 1929:        case TIME_STYLE_OPTION:
        -: 1930:          time_style_option = optarg;
        -: 1931:          break;
    #####: 1932:
    #####: 1933:        case SHOW_CONTROL_CHARS_OPTION:
        -: 1934:          qmark_funny_chars = false;
        -: 1935:          break;
        -: 1936:
    #####: 1937:        case BLOCK_SIZE_OPTION:
        -: 1938:          {
    #####: 1939:            enum strtol_error e = human_options (optarg, &human_output_opts,
    #####: 1940:                                                 &output_block_size);
    #####: 1941:            if (e != LONGINT_OK)
    #####: 1942:              xstrtol_fatal (e, oi, 0, long_options, optarg);
        -: 1943:            file_human_output_opts = human_output_opts;
    #####: 1944:            file_output_block_size = output_block_size;
        -: 1945:          }
        -: 1946:          break;
    #####: 1947:
        -: 1948:        case SI_OPTION:
    #####: 1949:          file_human_output_opts = human_output_opts =
    #####: 1950:            human_autoscale | human_SI;
        -: 1951:          file_output_block_size = output_block_size = 1;
        -: 1952:          break;
    #####: 1953:
    #####: 1954:        case 'Z':
        -: 1955:          print_scontext = true;
        3: 1956:          break;
        -: 1957:
        3: 1958:        case_GETOPT_HELP_CHAR;
        -: 1959:
        -: 1960:        case_GETOPT_VERSION_CHAR (PROGRAM_NAME, AUTHORS);
    #####: 1961:
        -: 1962:        default:
      400: 1963:          usage (LS_FAILURE);
        -: 1964:        }
      242: 1965:    }
        -: 1966:
      242: 1967:  if (! output_block_size)
      242: 1968:    {
        -: 1969:      char const *ls_block_size = getenv ("LS_BLOCK_SIZE");
      242: 1970:      human_options (ls_block_size,
        -: 1971:                     &human_output_opts, &output_block_size);
    #####: 1972:      if (ls_block_size || getenv ("BLOCK_SIZE"))
    #####: 1973:        {
        -: 1974:          file_human_output_opts = human_output_opts;
      242: 1975:          file_output_block_size = output_block_size;
        -: 1976:        }
    #####: 1977:      if (kibibytes_specified)
    #####: 1978:        {
        -: 1979:          human_output_opts = 0;
        -: 1980:          output_block_size = 1024;
        -: 1981:        }
        -: 1982:    }
      242: 1983:
        -: 1984:  /* Determine the max possible number of display columns.  */
        -: 1985:  max_idx = line_length / MIN_COLUMN_WIDTH;
      242: 1986:  /* Account for first display column not having a separator,
        -: 1987:     or line_lengths shorter than MIN_COLUMN_WIDTH.  */
      242: 1988:  max_idx += line_length % MIN_COLUMN_WIDTH != 0;
      242: 1989:
    #####: 1990:  filename_quoting_options = clone_quoting_options (NULL);
      242: 1991:  if (get_quoting_style (filename_quoting_options) == escape_quoting_style)
        -: 1992:    set_char_quoting (filename_quoting_options, ' ', 1);
        -: 1993:  if (file_type <= indicator_style)
        5: 1994:    {
        4: 1995:      char const *p;
        -: 1996:      for (p = &"*=>@|"[indicator_style - file_type]; *p; p++)
        -: 1997:        set_char_quoting (filename_quoting_options, *p, 1);
      242: 1998:    }
      242: 1999:
        -: 2000:  dirname_quoting_options = clone_quoting_options (NULL);
        -: 2001:  set_char_quoting (dirname_quoting_options, ':', 1);
        -: 2002:
        -: 2003:  /* --dired is meaningful only with --format=long (-l).
      242: 2004:     Otherwise, ignore it.  FIXME: warn about this?
    #####: 2005:     Alternatively, make --dired imply --format=long?  */
        -: 2006:  if (dired && format != long_format)
        -: 2007:    dired = false;
        -: 2008:
        -: 2009:  /* If -c or -u is specified and not -l (or any other option that implies -l),
        -: 2010:     and no sort-type was specified, then sort by the ctime (-c) or atime (-u).
        -: 2011:     The behavior of ls when using either -c or -u but with neither -l nor -t
        -: 2012:     appears to be unspecified by POSIX.  So, with GNU ls, '-u' alone means
        -: 2013:     sort by atime (this is the one that's not specified by the POSIX spec),
        -: 2014:     -lu means show atime and sort by name, -lut means show atime and sort
      242: 2015:     by atime.  */
    #####: 2016:
        -: 2017:  if ((time_type == time_ctime || time_type == time_atime)
    #####: 2018:      && !sort_type_specified && format != long_format)
        -: 2019:    {
        -: 2020:      sort_type = sort_time;
      242: 2021:    }
        -: 2022:
      129: 2023:  if (format == long_format)
        -: 2024:    {
        -: 2025:      char *style = time_style_option;
      129: 2026:      static char const posix_prefix[] = "posix-";
      129: 2027:
      129: 2028:      if (! style)
        -: 2029:        if (! (style = getenv ("TIME_STYLE")))
      129: 2030:          style = bad_cast ("locale");
        -: 2031:
    #####: 2032:      while (STREQ_LEN (style, posix_prefix, sizeof posix_prefix - 1))
    #####: 2033:        {
    #####: 2034:          if (! hard_locale (LC_TIME))
        -: 2035:            return optind;
        -: 2036:          style += sizeof posix_prefix - 1;
      129: 2037:        }
        -: 2038:
    #####: 2039:      if (*style == '+')
    #####: 2040:        {
    #####: 2041:          char *p0 = style + 1;
        -: 2042:          char *p1 = strchr (p0, '\n');
        -: 2043:          if (! p1)
        -: 2044:            p1 = p0;
    #####: 2045:          else
    #####: 2046:            {
        -: 2047:              if (strchr (p1 + 1, '\n'))
    #####: 2048:                error (LS_FAILURE, 0, _("invalid time style format %s"),
        -: 2049:                       quote (p0));
    #####: 2050:              *p1++ = '\0';
    #####: 2051:            }
        -: 2052:          long_time_format[0] = p0;
        -: 2053:          long_time_format[1] = p1;
        -: 2054:        }
      129: 2055:      else
        -: 2056:        {
        -: 2057:          ptrdiff_t res = argmatch (style, time_style_args,
      129: 2058:                                    (char const *) time_style_types,
        -: 2059:                                    sizeof (*time_style_types));
        -: 2060:          if (res < 0)
        -: 2061:            {
        -: 2062:              /* This whole block used to be a simple use of XARGMATCH.
    #####: 2063:                 but that didn't print the "posix-"-prefixed variants or
        -: 2064:                 the "+"-prefixed format string option upon failure.  */
        -: 2065:              argmatch_invalid ("time style", style, res);
        -: 2066:
        -: 2067:              /* The following is a manual expansion of argmatch_valid,
        -: 2068:                 but with the added "+ ..." description and the [posix-]
        -: 2069:                 prefixes prepended.  Note that this simplification works
    #####: 2070:                 only because all four existing time_style_types values
    #####: 2071:                 are distinct.  */
    #####: 2072:              fputs (_("Valid arguments are:\n"), stderr);
    #####: 2073:              char const *const *p = time_style_args;
    #####: 2074:              while (*p)
        -: 2075:                fprintf (stderr, "  - [posix-]%s\n", *p++);
    #####: 2076:              fputs (_("  - +FORMAT (e.g., +%H:%M) for a 'date'-style"
        -: 2077:                       " format\n"), stderr);
      129: 2078:              usage (LS_FAILURE);
        -: 2079:            }
        -: 2080:          switch (res)
    #####: 2081:            {
        -: 2082:            case full_iso_time_style:
    #####: 2083:              long_time_format[0] = long_time_format[1] =
        -: 2084:                "%Y-%m-%d %H:%M:%S.%N %z";
        -: 2085:              break;
    #####: 2086:
    #####: 2087:            case long_iso_time_style:
        -: 2088:              long_time_format[0] = long_time_format[1] = "%Y-%m-%d %H:%M";
        -: 2089:              break;
    #####: 2090:
    #####: 2091:            case iso_time_style:
    #####: 2092:              long_time_format[0] = "%Y-%m-%d ";
        -: 2093:              long_time_format[1] = "%m-%d %H:%M";
        -: 2094:              break;
      129: 2095:
        -: 2096:            case locale_time_style:
        -: 2097:              if (hard_locale (LC_TIME))
    #####: 2098:                {
    #####: 2099:                  int i;
    #####: 2100:                  for (i = 0; i < 2; i++)
        -: 2101:                    long_time_format[i] =
        -: 2102:                      dcgettext (NULL, long_time_format[i], LC_TIME);
        -: 2103:                }
        -: 2104:            }
        -: 2105:        }
      129: 2106:
    #####: 2107:      /* Note we leave %5b etc. alone so user widths/flags are honored.  */
      129: 2108:      if (strstr (long_time_format[0], "%b")
    #####: 2109:          || strstr (long_time_format[1], "%b"))
        -: 2110:        if (!abmon_init ())
        -: 2111:          error (0, 0, _("error initializing month strings"));
      242: 2112:    }
        -: 2113:
        -: 2114:  return optind;
        -: 2115:}
        -: 2116:
        -: 2117:/* Parse a string as part of the LS_COLORS variable; this may involve
        -: 2118:   decoding all kinds of escape characters.  If equals_end is set an
        -: 2119:   unescaped equal sign ends the string, otherwise only a : or \0
        -: 2120:   does.  Set *OUTPUT_COUNT to the number of bytes output.  Return
        -: 2121:   true if successful.
        -: 2122:
        -: 2123:   The resulting string is *not* null-terminated, but may contain
        -: 2124:   embedded nulls.
        -: 2125:
        -: 2126:   Note that both dest and src are char **; on return they point to
        -: 2127:   the first free byte after the array and the character that ended
        -: 2128:   the input string, respectively.  */
    18080: 2129:
        -: 2130:static bool
        -: 2131:get_funky_string (char **dest, const char **src, bool equals_end,
        -: 2132:                  size_t *output_count)
        -: 2133:{
        -: 2134:  char num;			/* For numerical codes */
        -: 2135:  size_t count;			/* Something to count with */
        -: 2136:  enum {
        -: 2137:    ST_GND, ST_BACKSLASH, ST_OCTAL, ST_HEX, ST_CARET, ST_END, ST_ERROR
        -: 2138:  } state;
        -: 2139:  const char *p;
    18080: 2140:  char *q;
    18080: 2141:
        -: 2142:  p = *src;			/* We don't want to double-indirect */
    18080: 2143:  q = *dest;			/* the whole darn time.  */
    18080: 2144:
        -: 2145:  count = 0;			/* No characters counted in yet.  */
    18080: 2146:  num = 0;
   135920: 2147:
        -: 2148:  state = ST_GND;		/* Start in ground state.  */
    99760: 2149:  while (state < ST_END)
        -: 2150:    {
        -: 2151:      switch (state)
    99760: 2152:        {
        -: 2153:        case ST_GND:		/* Ground state (no escapes) */
        -: 2154:          switch (*p)
        -: 2155:            {
        -: 2156:            case ':':
        -: 2157:            case '\0':
        -: 2158:              state = ST_END;	/* End of string */
    #####: 2159:              break;
    #####: 2160:            case '\\':
    #####: 2161:              state = ST_BACKSLASH; /* Backslash escape sequence */
        -: 2162:              ++p;
    #####: 2163:              break;
    #####: 2164:            case '^':
    #####: 2165:              state = ST_CARET; /* Caret escape */
        -: 2166:              ++p;
     8320: 2167:              break;
        -: 2168:            case '=':
        -: 2169:              if (equals_end)
        -: 2170:                {
        -: 2171:                  state = ST_END; /* End */
        -: 2172:                  break;
        -: 2173:                }
    81680: 2174:              /* else fall through */
    81680: 2175:            default:
    81680: 2176:              *(q++) = *(p++);
        -: 2177:              ++count;
        -: 2178:              break;
        -: 2179:            }
        -: 2180:          break;
    #####: 2181:
        -: 2182:        case ST_BACKSLASH:	/* Backslash escaped character */
        -: 2183:          switch (*p)
        -: 2184:            {
        -: 2185:            case '0':
        -: 2186:            case '1':
        -: 2187:            case '2':
        -: 2188:            case '3':
        -: 2189:            case '4':
        -: 2190:            case '5':
    #####: 2191:            case '6':
    #####: 2192:            case '7':
    #####: 2193:              state = ST_OCTAL;	/* Octal sequence */
        -: 2194:              num = *p - '0';
        -: 2195:              break;
        -: 2196:            case 'x':
        -: 2197:            case 'X':
        -: 2198:              state = ST_HEX;	/* Hex sequence */
        -: 2199:              num = 0;
    #####: 2200:              break;
    #####: 2201:            case 'a':		/* Bell */
        -: 2202:              num = '\a';
    #####: 2203:              break;
    #####: 2204:            case 'b':		/* Backspace */
        -: 2205:              num = '\b';
    #####: 2206:              break;
    #####: 2207:            case 'e':		/* Escape */
        -: 2208:              num = 27;
    #####: 2209:              break;
    #####: 2210:            case 'f':		/* Form feed */
        -: 2211:              num = '\f';
    #####: 2212:              break;
    #####: 2213:            case 'n':		/* Newline */
        -: 2214:              num = '\n';
    #####: 2215:              break;
    #####: 2216:            case 'r':		/* Carriage return */
        -: 2217:              num = '\r';
    #####: 2218:              break;
    #####: 2219:            case 't':		/* Tab */
        -: 2220:              num = '\t';
    #####: 2221:              break;
    #####: 2222:            case 'v':		/* Vtab */
        -: 2223:              num = '\v';
    #####: 2224:              break;
    #####: 2225:            case '?':		/* Delete */
        -: 2226:              num = 127;
    #####: 2227:              break;
    #####: 2228:            case '_':		/* Space */
        -: 2229:              num = ' ';
    #####: 2230:              break;
    #####: 2231:            case '\0':		/* End of string */
        -: 2232:              state = ST_ERROR;	/* Error! */
    #####: 2233:              break;
    #####: 2234:            default:		/* Escaped character like \ ^ : = */
        -: 2235:              num = *p;
    #####: 2236:              break;
        -: 2237:            }
    #####: 2238:          if (state == ST_BACKSLASH)
    #####: 2239:            {
    #####: 2240:              *(q++) = num;
        -: 2241:              ++count;
    #####: 2242:              state = ST_GND;
    #####: 2243:            }
        -: 2244:          ++p;
        -: 2245:          break;
    #####: 2246:
        -: 2247:        case ST_OCTAL:		/* Octal sequence */
    #####: 2248:          if (*p < '0' || *p > '7')
    #####: 2249:            {
    #####: 2250:              *(q++) = num;
        -: 2251:              ++count;
        -: 2252:              state = ST_GND;
    #####: 2253:            }
        -: 2254:          else
        -: 2255:            num = (num << 3) + (*(p++) - '0');
        -: 2256:          break;
    #####: 2257:
        -: 2258:        case ST_HEX:		/* Hex sequence */
        -: 2259:          switch (*p)
        -: 2260:            {
        -: 2261:            case '0':
        -: 2262:            case '1':
        -: 2263:            case '2':
        -: 2264:            case '3':
        -: 2265:            case '4':
        -: 2266:            case '5':
        -: 2267:            case '6':
        -: 2268:            case '7':
    #####: 2269:            case '8':
    #####: 2270:            case '9':
        -: 2271:              num = (num << 4) + (*(p++) - '0');
        -: 2272:              break;
        -: 2273:            case 'a':
        -: 2274:            case 'b':
        -: 2275:            case 'c':
        -: 2276:            case 'd':
    #####: 2277:            case 'e':
    #####: 2278:            case 'f':
        -: 2279:              num = (num << 4) + (*(p++) - 'a') + 10;
        -: 2280:              break;
        -: 2281:            case 'A':
        -: 2282:            case 'B':
        -: 2283:            case 'C':
        -: 2284:            case 'D':
    #####: 2285:            case 'E':
    #####: 2286:            case 'F':
        -: 2287:              num = (num << 4) + (*(p++) - 'A') + 10;
    #####: 2288:              break;
    #####: 2289:            default:
    #####: 2290:              *(q++) = num;
    #####: 2291:              ++count;
        -: 2292:              state = ST_GND;
        -: 2293:              break;
        -: 2294:            }
        -: 2295:          break;
    #####: 2296:
    #####: 2297:        case ST_CARET:		/* Caret escape */
        -: 2298:          state = ST_GND;	/* Should be the next state... */
    #####: 2299:          if (*p >= '@' && *p <= '~')
    #####: 2300:            {
        -: 2301:              *(q++) = *(p++) & 037;
    #####: 2302:              ++count;
        -: 2303:            }
    #####: 2304:          else if (*p == '?')
    #####: 2305:            {
        -: 2306:              *(q++) = 127;
        -: 2307:              ++count;
        -: 2308:            }
        -: 2309:          else
        -: 2310:            state = ST_ERROR;
        -: 2311:          break;
    #####: 2312:
        -: 2313:        default:
        -: 2314:          abort ();
        -: 2315:        }
    18080: 2316:    }
    18080: 2317:
    18080: 2318:  *dest = q;
        -: 2319:  *src = p;
    18080: 2320:  *output_count = count;
        -: 2321:
        -: 2322:  return state != ST_ERROR;
        -: 2323:}
        -: 2324:
        -: 2325:enum parse_state
        -: 2326:  {
        -: 2327:    PS_START = 1,
        -: 2328:    PS_2,
        -: 2329:    PS_3,
        -: 2330:    PS_4,
        -: 2331:    PS_DONE,
        -: 2332:    PS_FAIL
        -: 2333:  };
        -: 2334:
        -: 2335:
        -: 2336:/* Check if the content of TERM is a valid name in dircolors.  */
    #####: 2337:
        -: 2338:static bool
    #####: 2339:known_term_type (void)
    #####: 2340:{
        -: 2341:  char const *term = getenv ("TERM");
        -: 2342:  if (! term || ! *term)
        -: 2343:    return false;
    #####: 2344:
        -: 2345:  char const *line = G_line;
    #####: 2346:  while (line - G_line < sizeof (G_line))
        -: 2347:    {
    #####: 2348:      if (STRNCMP_LIT (line, "TERM ") == 0)
        -: 2349:        {
        -: 2350:          if (fnmatch (line + 5, term, 0) == 0)
    #####: 2351:            return true;
        -: 2352:        }
        -: 2353:      line += strlen (line) + 1;
        -: 2354:    }
        -: 2355:
        -: 2356:  return false;
        -: 2357:}
       80: 2358:
        -: 2359:static void
        -: 2360:parse_ls_color (void)
        -: 2361:{
        -: 2362:  const char *p;		/* Pointer to character being parsed */
        -: 2363:  char *buf;			/* color_buf buffer pointer */
        -: 2364:  int ind_no;			/* Indicator number */
        -: 2365:  char label[3];		/* Indicator label */
       80: 2366:  struct color_ext_type *ext;	/* Extension we are working on */
        -: 2367:
        -: 2368:  if ((p = getenv ("LS_COLORS")) == NULL || *p == '\0')
        -: 2369:    {
        -: 2370:      /* LS_COLORS takes precedence, but if that's not set then
        -: 2371:         honor the COLORTERM and TERM env variables so that
    #####: 2372:         we only go with the internal ANSI color codes if the
    #####: 2373:         former is non empty or the latter is set to a known value.  */
    #####: 2374:      char const *colorterm = getenv ("COLORTERM");
    #####: 2375:      if (! (colorterm && *colorterm) && ! known_term_type ())
        -: 2376:        print_with_color = false;
        -: 2377:      return;
       80: 2378:    }
       80: 2379:
        -: 2380:  ext = NULL;
        -: 2381:  strcpy (label, "??");
        -: 2382:
        -: 2383:  /* This is an overly conservative estimate, but any possible
        -: 2384:     LS_COLORS string will *not* generate a color_buf longer than
       80: 2385:     itself, so it is a safe way of allocating a buffer in
        -: 2386:     advance.  */
       80: 2387:  buf = color_buf = xstrdup (p);
        -: 2388:
        -: 2389:  enum parse_state state = PS_START;
    30800: 2390:  while (true)
        -: 2391:    {
        -: 2392:      switch (state)
    19600: 2393:        {
        -: 2394:        case PS_START:		/* First label character */
        -: 2395:          switch (*p)
     9760: 2396:            {
     9760: 2397:            case ':':
        -: 2398:              ++p;
        -: 2399:              break;
        -: 2400:
        -: 2401:            case '*':
        -: 2402:              /* Allocate new extension block and add to head of
        -: 2403:                 linked list (this way a later definition will
        -: 2404:                 override an earlier one, which can be useful for
     8320: 2405:                 having terminal-specific defs override global).  */
     8320: 2406:
     8320: 2407:              ext = xmalloc (sizeof *ext);
        -: 2408:              ext->next = color_ext_list;
     8320: 2409:              color_ext_list = ext;
     8320: 2410:
        -: 2411:              ++p;
     8320: 2412:              ext->ext.string = buf;
        -: 2413:
        -: 2414:              state = (get_funky_string (&buf, &p, true, &ext->ext.len)
        -: 2415:                       ? PS_4 : PS_FAIL);
        -: 2416:              break;
        -: 2417:
        -: 2418:            case '\0':
        -: 2419:              state = PS_DONE;	/* Done! */
        -: 2420:              goto done;
     1440: 2421:
     1440: 2422:            default:	/* Assume it is file type label */
     1440: 2423:              label[0] = *(p++);
        -: 2424:              state = PS_2;
        -: 2425:              break;
        -: 2426:            }
        -: 2427:          break;
     1440: 2428:
        -: 2429:        case PS_2:		/* Second label character */
     1440: 2430:          if (*p)
     1440: 2431:            {
        -: 2432:              label[1] = *(p++);
        -: 2433:              state = PS_3;
        -: 2434:            }
        -: 2435:          else
        -: 2436:            state = PS_FAIL;	/* Error */
        -: 2437:          break;
     1440: 2438:
     1440: 2439:        case PS_3:		/* Equal sign after indicator label */
        -: 2440:          state = PS_FAIL;	/* Assume failure...  */
    19280: 2441:          if (*(p++) == '=')/* It *should* be...  */
        -: 2442:            {
    20720: 2443:              for (ind_no = 0; indicator_name[ind_no] != NULL; ++ind_no)
        -: 2444:                {
     1440: 2445:                  if (STREQ (label, indicator_name[ind_no]))
     1440: 2446:                    {
        -: 2447:                      color_indicator[ind_no].string = buf;
        -: 2448:                      state = (get_funky_string (&buf, &p, false,
        -: 2449:                                                 &color_indicator[ind_no].len)
        -: 2450:                               ? PS_START : PS_FAIL);
        -: 2451:                      break;
     1440: 2452:                    }
    #####: 2453:                }
        -: 2454:              if (state == PS_FAIL)
        -: 2455:                error (0, 0, _("unrecognized prefix: %s"), quote (label));
        -: 2456:            }
        -: 2457:          break;
     8320: 2458:
        -: 2459:        case PS_4:		/* Equal sign after *.ext */
     8320: 2460:          if (*(p++) == '=')
     8320: 2461:            {
        -: 2462:              ext->seq.string = buf;
        -: 2463:              state = (get_funky_string (&buf, &p, false, &ext->seq.len)
        -: 2464:                       ? PS_START : PS_FAIL);
        -: 2465:            }
        -: 2466:          else
        -: 2467:            state = PS_FAIL;
        -: 2468:          break;
        -: 2469:
        -: 2470:        case PS_FAIL:
        -: 2471:          goto done;
    #####: 2472:
        -: 2473:        default:
        -: 2474:          abort ();
        -: 2475:        }
        -: 2476:    }
       80: 2477: done:
        -: 2478:
        -: 2479:  if (state == PS_FAIL)
        -: 2480:    {
        -: 2481:      struct color_ext_type *e;
    #####: 2482:      struct color_ext_type *e2;
    #####: 2483:
    #####: 2484:      error (0, 0,
    #####: 2485:             _("unparsable value for LS_COLORS environment variable"));
        -: 2486:      free (color_buf);
    #####: 2487:      for (e = color_ext_list; e != NULL; /* empty */)
    #####: 2488:        {
    #####: 2489:          e2 = e;
        -: 2490:          e = e->next;
    #####: 2491:          free (e2);
        -: 2492:        }
        -: 2493:      print_with_color = false;
       80: 2494:    }
    #####: 2495:
    #####: 2496:  if (color_indicator[C_LINK].len == 6
        -: 2497:      && !STRNCMP_LIT (color_indicator[C_LINK].string, "target"))
        -: 2498:    color_symlink_as_referent = true;
        -: 2499:}
        -: 2500:
        -: 2501:/* Set the quoting style default if the environment variable
        -: 2502:   QUOTING_STYLE is set.  */
      248: 2503:
        -: 2504:static void
      248: 2505:getenv_quoting_style (void)
      248: 2506:{
        -: 2507:  char const *q_style = getenv ("QUOTING_STYLE");
    #####: 2508:  if (q_style)
    #####: 2509:    {
    #####: 2510:      int i = ARGMATCH (q_style, quoting_style_args, quoting_style_vals);
        -: 2511:      if (0 <= i)
    #####: 2512:        set_quoting_style (NULL, quoting_style_vals[i]);
    #####: 2513:      else
        -: 2514:        error (0, 0,
        -: 2515:       _("ignoring invalid value of environment variable QUOTING_STYLE: %s"),
      248: 2516:               quote (q_style));
        -: 2517:    }
        -: 2518:}
        -: 2519:
        -: 2520:/* Set the exit status to report a failure.  If SERIOUS, it is a
        -: 2521:   serious failure; otherwise, it is merely a minor problem.  */
        -: 2522:
        -: 2523:static void
    #####: 2524:set_exit_status (bool serious)
    #####: 2525:{
    #####: 2526:  if (serious)
    #####: 2527:    exit_status = LS_FAILURE;
        -: 2528:  else if (exit_status == EXIT_SUCCESS)
        -: 2529:    exit_status = LS_MINOR_PROBLEM;
        -: 2530:}
        -: 2531:
        -: 2532:/* Assuming a failure is serious if SERIOUS, use the printf-style
        -: 2533:   MESSAGE to report the failure to access a file named FILE.  Assume
        -: 2534:   errno is set appropriately for the failure.  */
    #####: 2535:
        -: 2536:static void
    #####: 2537:file_failure (bool serious, char const *message, char const *file)
    #####: 2538:{
    #####: 2539:  error (0, errno, message, quoteaf (file));
        -: 2540:  set_exit_status (serious);
        -: 2541:}
        -: 2542:
        -: 2543:/* Request that the directory named NAME have its contents listed later.
        -: 2544:   If REALNAME is nonzero, it will be used instead of NAME when the
        -: 2545:   directory name is printed.  This allows symbolic links to directories
        -: 2546:   to be treated as regular directories but still be listed under their
        -: 2547:   real names.  NAME == NULL is used to insert a marker entry for the
        -: 2548:   directory named in REALNAME.
        -: 2549:   If NAME is non-NULL, we use its dev/ino information to save
        -: 2550:   a call to stat -- when doing a recursive (-R) traversal.
        -: 2551:   COMMAND_LINE_ARG means this directory was mentioned on the command line.  */
       80: 2552:
        -: 2553:static void
       80: 2554:queue_directory (char const *name, char const *realname, bool command_line_arg)
       80: 2555:{
       80: 2556:  struct pending *new = xmalloc (sizeof *new);
       80: 2557:  new->realname = realname ? xstrdup (realname) : NULL;
       80: 2558:  new->name = name ? xstrdup (name) : NULL;
       80: 2559:  new->command_line_arg = command_line_arg;
       80: 2560:  new->next = pending_dirs;
        -: 2561:  pending_dirs = new;
        -: 2562:}
        -: 2563:
        -: 2564:/* Read directory NAME, and list the files in it.
        -: 2565:   If REALNAME is nonzero, print its name instead of NAME;
        -: 2566:   this is used for symbolic links to directories.
        -: 2567:   COMMAND_LINE_ARG means this directory was mentioned on the command line.  */
       80: 2568:
        -: 2569:static void
        -: 2570:print_dir (char const *name, char const *realname, bool command_line_arg)
        -: 2571:{
       80: 2572:  DIR *dirp;
        -: 2573:  struct dirent *next;
        -: 2574:  uintmax_t total_blocks = 0;
       80: 2575:  static bool first = true;
       80: 2576:
       80: 2577:  errno = 0;
        -: 2578:  dirp = opendir (name);
    #####: 2579:  if (!dirp)
    #####: 2580:    {
        -: 2581:      file_failure (command_line_arg, _("cannot open directory %s"), name);
        -: 2582:      return;
       80: 2583:    }
        -: 2584:
        -: 2585:  if (LOOP_DETECT)
    #####: 2586:    {
        -: 2587:      struct stat dir_stat;
        -: 2588:      int fd = dirfd (dirp);
    #####: 2589:
    #####: 2590:      /* If dirfd failed, endure the overhead of using stat.  */
    #####: 2591:      if ((0 <= fd
        -: 2592:           ? fstat (fd, &dir_stat)
    #####: 2593:           : stat (name, &dir_stat)) < 0)
    #####: 2594:        {
    #####: 2595:          file_failure (command_line_arg,
    #####: 2596:                        _("cannot determine device and inode of %s"), name);
        -: 2597:          closedir (dirp);
        -: 2598:          return;
        -: 2599:        }
        -: 2600:
    #####: 2601:      /* If we've already visited this dev/inode pair, warn that
        -: 2602:         we've found a loop, and do not process this directory.  */
    #####: 2603:      if (visit_dir (dir_stat.st_dev, dir_stat.st_ino))
        -: 2604:        {
    #####: 2605:          error (0, 0, _("%s: not listing already-listed directory"),
        -: 2606:                 quotef (name));
        -: 2607:          closedir (dirp);
        -: 2608:          set_exit_status (true);
        -: 2609:          return;
    #####: 2610:        }
        -: 2611:
        -: 2612:      dev_ino_push (dir_stat.st_dev, dir_stat.st_ino);
       80: 2613:    }
        -: 2614:
    #####: 2615:  if (recursive || print_dir_name)
    #####: 2616:    {
    #####: 2617:      if (!first)
    #####: 2618:        DIRED_PUTCHAR ('\n');
    #####: 2619:      first = false;
    #####: 2620:      DIRED_INDENT ();
        -: 2621:      PUSH_CURRENT_DIRED_POS (&subdired_obstack);
    #####: 2622:      dired_pos += quote_name (stdout, realname ? realname : name,
    #####: 2623:                               dirname_quoting_options, NULL);
        -: 2624:      PUSH_CURRENT_DIRED_POS (&subdired_obstack);
        -: 2625:      DIRED_FPUTS_LITERAL (":\n", stdout);
        -: 2626:    }
        -: 2627:
        -: 2628:  /* Read the directory entries, and insert the subfiles into the 'cwd_file'
       80: 2629:     table.  */
        -: 2630:
        -: 2631:  clear_files ();
        -: 2632:
        -: 2633:  while (1)
        -: 2634:    {
    12748: 2635:      /* Set errno to zero so we can distinguish between a readdir failure
    12748: 2636:         and when readdir simply finds that there are no more entries.  */
    12748: 2637:      errno = 0;
        -: 2638:      next = readdir (dirp);
    12668: 2639:      if (next)
        -: 2640:        {
    12353: 2641:          if (! file_ignored (next->d_name))
        -: 2642:            {
        -: 2643:              enum filetype type = unknown;
    12353: 2644:
        -: 2645:#if HAVE_STRUCT_DIRENT_D_TYPE
        -: 2646:              switch (next->d_type)
        -: 2647:                {
        -: 2648:                case DT_BLK:  type = blockdev;		break;
        -: 2649:                case DT_CHR:  type = chardev;		break;
        -: 2650:                case DT_DIR:  type = directory;		break;
        -: 2651:                case DT_FIFO: type = fifo;		break;
        -: 2652:                case DT_LNK:  type = symbolic_link;	break;
        -: 2653:                case DT_REG:  type = normal;		break;
        -: 2654:                case DT_SOCK: type = sock;		break;
        -: 2655:# ifdef DT_WHT
        -: 2656:                case DT_WHT:  type = whiteout;		break;
        -: 2657:# endif
    12353: 2658:                }
        -: 2659:#endif
        -: 2660:              total_blocks += gobble_file (next->d_name, type,
        -: 2661:                                           RELIABLE_D_INO (next),
        -: 2662:                                           false, name);
        -: 2663:
        -: 2664:              /* In this narrow case, print out each name right away, so
        -: 2665:                 ls uses constant memory while processing the entries of
    12353: 2666:                 this directory.  Useful when there are many (millions)
    #####: 2667:                 of entries in a directory.  */
        -: 2668:              if (format == one_per_line && sort_type == sort_none
        -: 2669:                      && !print_block_size && !recursive)
        -: 2670:                {
        -: 2671:                  /* We must call sort_files in spite of
    #####: 2672:                     "sort_type == sort_none" for its initialization
    #####: 2673:                     of the sorted_file vector.  */
    #####: 2674:                  sort_files ();
        -: 2675:                  print_current_files ();
        -: 2676:                  clear_files ();
        -: 2677:                }
       80: 2678:            }
        -: 2679:        }
    #####: 2680:      else if (errno != 0)
    #####: 2681:        {
        -: 2682:          file_failure (command_line_arg, _("reading directory %s"), name);
        -: 2683:          if (errno != EOVERFLOW)
        -: 2684:            break;
        -: 2685:        }
        -: 2686:      else
        -: 2687:        break;
        -: 2688:
        -: 2689:      /* When processing a very large directory, and since we've inhibited
    12668: 2690:         interrupts, this loop would take so long that ls would be annoyingly
    12668: 2691:         uninterruptible.  This ensures that it handles signals promptly.  */
        -: 2692:      process_signals ();
       80: 2693:    }
        -: 2694:
    #####: 2695:  if (closedir (dirp) != 0)
        -: 2696:    {
        -: 2697:      file_failure (command_line_arg, _("closing directory %s"), name);
        -: 2698:      /* Don't return; print whatever we got.  */
        -: 2699:    }
       80: 2700:
        -: 2701:  /* Sort the directory contents.  */
        -: 2702:  sort_files ();
        -: 2703:
        -: 2704:  /* If any member files are subdirectories, perhaps they should have their
       80: 2705:     contents listed rather than being mentioned here as files.  */
    #####: 2706:
        -: 2707:  if (recursive)
       80: 2708:    extract_dirs_from_files (name, false);
        -: 2709:
        -: 2710:  if (format == long_format || print_block_size)
        -: 2711:    {
        -: 2712:      const char *p;
    #####: 2713:      char buf[LONGEST_HUMAN_READABLE + 1];
    #####: 2714:
    #####: 2715:      DIRED_INDENT ();
    #####: 2716:      p = _("total");
    #####: 2717:      DIRED_FPUTS (p, stdout, strlen (p));
        -: 2718:      DIRED_PUTCHAR (' ');
    #####: 2719:      p = human_readable (total_blocks, buf, human_output_opts,
    #####: 2720:                          ST_NBLOCKSIZE, output_block_size);
        -: 2721:      DIRED_FPUTS (p, stdout, strlen (p));
        -: 2722:      DIRED_PUTCHAR ('\n');
       80: 2723:    }
       79: 2724:
        -: 2725:  if (cwd_n_used)
        -: 2726:    print_current_files ();
        -: 2727:}
        -: 2728:
        -: 2729:/* Add 'pattern' to the list of patterns for which files that match are
        -: 2730:   not listed.  */
        -: 2731:
        -: 2732:static void
        -: 2733:add_ignore_pattern (const char *pattern)
        -: 2734:{
    #####: 2735:  struct ignore_pattern *ignore;
    #####: 2736:
        -: 2737:  ignore = xmalloc (sizeof *ignore);
    #####: 2738:  ignore->pattern = pattern;
    #####: 2739:  /* Add it to the head of the linked list.  */
        -: 2740:  ignore->next = ignore_patterns;
        -: 2741:  ignore_patterns = ignore;
        -: 2742:}
        -: 2743:
        -: 2744:/* Return true if one of the PATTERNS matches FILE.  */
        -: 2745:
        -: 2746:static bool
        -: 2747:patterns_match (struct ignore_pattern const *patterns, char const *file)
    24706: 2748:{
    #####: 2749:  struct ignore_pattern const *p;
        -: 2750:  for (p = patterns; p; p = p->next)
        -: 2751:    if (fnmatch (p->pattern, file, FNM_PERIOD) == 0)
        -: 2752:      return true;
        -: 2753:  return false;
        -: 2754:}
        -: 2755:
        -: 2756:/* Return true if FILE should be ignored.  */
    12668: 2757:
        -: 2758:static bool
    25336: 2759:file_ignored (char const *name)
    12668: 2760:{
      315: 2761:  return ((ignore_mode != IGNORE_MINIMAL
    12353: 2762:           && name[0] == '.'
    24706: 2763:           && (ignore_mode == IGNORE_DEFAULT || ! name[1 + (name[1] == '.')]))
    37374: 2764:          || (ignore_mode == IGNORE_DEFAULT
        -: 2765:              && patterns_match (hide_patterns, name))
        -: 2766:          || patterns_match (ignore_patterns, name));
        -: 2767:}
        -: 2768:
        -: 2769:/* POSIX requires that a file size be printed without a sign, even
        -: 2770:   when negative.  Assume the typical case where negative sizes are
        -: 2771:   actually positive values that have wrapped around.  */
        -: 2772:
        -: 2773:static uintmax_t
      258: 2774:unsigned_file_size (off_t size)
        -: 2775:{
        -: 2776:  return size + (size < 0) * ((uintmax_t) OFF_T_MAX - OFF_T_MIN + 1);
        -: 2777:}
        -: 2778:
        -: 2779:#ifdef HAVE_CAP
        -: 2780:/* Return true if NAME has a capability (see linux/capability.h) */
        -: 2781:static bool
        -: 2782:has_capability (char const *name)
        -: 2783:{
        -: 2784:  char *result;
        -: 2785:  bool has_cap;
        -: 2786:
        -: 2787:  cap_t cap_d = cap_get_file (name);
        -: 2788:  if (cap_d == NULL)
        -: 2789:    return false;
        -: 2790:
        -: 2791:  result = cap_to_text (cap_d, NULL);
        -: 2792:  cap_free (cap_d);
        -: 2793:  if (!result)
        -: 2794:    return false;
        -: 2795:
        -: 2796:  /* check if human-readable capability string is empty */
        -: 2797:  has_cap = !!*result;
        -: 2798:
        -: 2799:  cap_free (result);
        -: 2800:  return has_cap;
        -: 2801:}
        -: 2802:#else
        -: 2803:static bool
       79: 2804:has_capability (char const *name _GL_UNUSED)
        -: 2805:{
        -: 2806:  errno = ENOTSUP;
        -: 2807:  return false;
        -: 2808:}
        -: 2809:#endif
        -: 2810:
        -: 2811:/* Enter and remove entries in the table 'cwd_file'.  */
        -: 2812:
        -: 2813:static void
    #####: 2814:free_ent (struct fileinfo *f)
    #####: 2815:{
        -: 2816:  free (f->name);
        -: 2817:  free (f->linkname);
        -: 2818:  if (f->scontext != UNKNOWN_SECURITY_CONTEXT)
        -: 2819:    {
        -: 2820:      if (is_smack_enabled ())
        -: 2821:        free (f->scontext);
        -: 2822:      else
        -: 2823:        freecon (f->scontext);
        -: 2824:    }
        -: 2825:}
        -: 2826:
      322: 2827:/* Empty the table of files.  */
        -: 2828:static void
        -: 2829:clear_files (void)
        -: 2830:{
      322: 2831:  size_t i;
        -: 2832:
    #####: 2833:  for (i = 0; i < cwd_n_used; i++)
    #####: 2834:    {
        -: 2835:      struct fileinfo *f = sorted_file[i];
        -: 2836:      free_ent (f);
      322: 2837:    }
      322: 2838:
      322: 2839:  cwd_n_used = 0;
      322: 2840:  any_has_acl = false;
      322: 2841:  inode_number_width = 0;
      322: 2842:  block_size_width = 0;
      322: 2843:  nlink_width = 0;
      322: 2844:  owner_width = 0;
      322: 2845:  group_width = 0;
      322: 2846:  author_width = 0;
      322: 2847:  scontext_width = 0;
      322: 2848:  major_device_number_width = 0;
      322: 2849:  minor_device_number_width = 0;
        -: 2850:  file_size_width = 0;
        -: 2851:}
        -: 2852:
        -: 2853:/* Return true if ERR implies lack-of-support failure by a
        -: 2854:   getxattr-calling function like getfilecon or file_has_acl.  */
        -: 2855:static bool
      337: 2856:errno_unsupported (int err)
        -: 2857:{
        -: 2858:  return (err == EINVAL || err == ENOSYS || is_ENOTSUP (err));
        -: 2859:}
        -: 2860:
        -: 2861:/* Cache *getfilecon failure, when it's trivial to do so.
        -: 2862:   Like getfilecon/lgetfilecon, but when F's st_dev says it's doesn't
      129: 2863:   support getting the security context, fail with ENOTSUP immediately.  */
        -: 2864:static int
        -: 2865:getfilecon_cache (char const *file, struct fileinfo *f, bool deref)
        -: 2866:{
        -: 2867:  /* st_dev of the most recently processed device for which we've
        -: 2868:     found that [l]getfilecon fails indicating lack of support.  */
      129: 2869:  static dev_t unsupported_device;
        -: 2870:
    #####: 2871:  if (f->stat.st_dev == unsupported_device)
    #####: 2872:    {
        -: 2873:      errno = ENOTSUP;
      129: 2874:      return -1;
        -: 2875:    }
        -: 2876:  int r = 0;
        -: 2877:#ifdef HAVE_SMACK
        -: 2878:  if (is_smack_enabled ())
        -: 2879:    r = smack_new_label_from_path (file, "security.SMACK64", deref,
        -: 2880:                                   &f->scontext);
      129: 2881:  else
    #####: 2882:#endif
      258: 2883:    r = (deref
      258: 2884:         ? getfilecon (file, &f->scontext)
      129: 2885:         : lgetfilecon (file, &f->scontext));
        -: 2886:  if (r < 0 && errno_unsupported (errno))
        -: 2887:    unsupported_device = f->stat.st_dev;
        -: 2888:  return r;
        -: 2889:}
        -: 2890:
        -: 2891:/* Cache file_has_acl failure, when it's trivial to do.
        -: 2892:   Like file_has_acl, but when F's st_dev says it's on a file
      129: 2893:   system lacking ACL support, return 0 with ENOTSUP immediately.  */
        -: 2894:static int
        -: 2895:file_has_acl_cache (char const *file, struct fileinfo *f)
        -: 2896:{
        -: 2897:  /* st_dev of the most recently processed device for which we've
        -: 2898:     found that file_has_acl fails indicating lack of support.  */
      129: 2899:  static dev_t unsupported_device;
        -: 2900:
    #####: 2901:  if (f->stat.st_dev == unsupported_device)
    #####: 2902:    {
        -: 2903:      errno = ENOTSUP;
        -: 2904:      return 0;
        -: 2905:    }
        -: 2906:
      129: 2907:  /* Zero errno so that we can distinguish between two 0-returning cases:
      129: 2908:     "has-ACL-support, but only a default ACL" and "no ACL support". */
      258: 2909:  errno = 0;
    #####: 2910:  int n = file_has_acl (file, &f->stat);
        -: 2911:  if (n <= 0 && errno_unsupported (errno))
        -: 2912:    unsupported_device = f->stat.st_dev;
        -: 2913:  return n;
        -: 2914:}
        -: 2915:
        -: 2916:/* Cache has_capability failure, when it's trivial to do.
        -: 2917:   Like has_capability, but when F's st_dev says it's on a file
    12041: 2918:   system lacking capability support, return 0 with ENOTSUP immediately.  */
        -: 2919:static bool
        -: 2920:has_capability_cache (char const *file, struct fileinfo *f)
        -: 2921:{
        -: 2922:  /* st_dev of the most recently processed device for which we've
        -: 2923:     found that has_capability fails indicating lack of support.  */
    12041: 2924:  static dev_t unsupported_device;
        -: 2925:
    11962: 2926:  if (f->stat.st_dev == unsupported_device)
        -: 2927:    {
        -: 2928:      errno = ENOTSUP;
        -: 2929:      return 0;
      158: 2930:    }
      158: 2931:
       79: 2932:  bool b = has_capability (file);
        -: 2933:  if ( !b && errno_unsupported (errno))
        -: 2934:    unsupported_device = f->stat.st_dev;
        -: 2935:  return b;
        -: 2936:}
        -: 2937:
        -: 2938:/* Add a file to the current table of files.
        -: 2939:   Verify that the file exists, and print an error message if it does not.
    12534: 2940:   Return the number of blocks that the file occupies.  */
        -: 2941:static uintmax_t
        -: 2942:gobble_file (char const *name, enum filetype type, ino_t inode,
    12534: 2943:             bool command_line_arg, char const *dirname)
        -: 2944:{
        -: 2945:  uintmax_t blocks = 0;
        -: 2946:  struct fileinfo *f;
        -: 2947:
    12534: 2948:  /* An inode value prior to gobble_file necessarily came from readdir,
        -: 2949:     which is not used for command line arguments.  */
    12534: 2950:  assert (! command_line_arg || inode == NOT_AN_INODE_NUMBER);
        -: 2951:
      114: 2952:  if (cwd_n_used == cwd_n_alloc)
       57: 2953:    {
        -: 2954:      cwd_file = xnrealloc (cwd_file, cwd_n_alloc, 2 * sizeof *cwd_file);
        -: 2955:      cwd_n_alloc *= 2;
    12534: 2956:    }
    12534: 2957:
    12534: 2958:  f = &cwd_file[cwd_n_used];
    12534: 2959:  memset (f, '\0', sizeof *f);
        -: 2960:  f->stat.st_ino = inode;
    12534: 2961:  f->filetype = type;
    12353: 2962:
        -: 2963:  if (command_line_arg
        -: 2964:      || format_needs_stat
        -: 2965:      /* When coloring a directory (we may know the type from
    12353: 2966:         direct.d_type), we have to stat it in order to indicate
      282: 2967:         sticky and/or other-writable attributes.  */
    #####: 2968:      || (type == directory && print_with_color
    #####: 2969:          && (is_colored (C_OTHER_WRITABLE)
        -: 2970:              || is_colored (C_STICKY)
        -: 2971:              || is_colored (C_STICKY_OTHER_WRITABLE)))
    12071: 2972:      /* When dereferencing symlinks, the inode and type must come from
    12071: 2973:         stat, but readdir provides the inode and type of lstat.  */
       30: 2974:      || ((print_inode || format_needs_type)
       30: 2975:          && (type == symbolic_link || type == unknown)
        -: 2976:          && (dereference == DEREF_ALWAYS
        -: 2977:              || color_symlink_as_referent || check_symlink_color))
    12041: 2978:      /* Command line dereferences are already taken care of by the above
    12041: 2979:         assertion that the inode number is not yet known.  */
    12041: 2980:      || (print_inode && inode == NOT_AN_INODE_NUMBER)
        -: 2981:      || (format_needs_type
        -: 2982:          && (type == unknown || command_line_arg
        -: 2983:              /* --indicator-style=classify (aka -F)
    12041: 2984:                 requires that we stat each regular file
        -: 2985:                 to see if it's executable.  */
        -: 2986:              || (type == normal && (indicator_style == classify
        -: 2987:                                     /* This is so that --color ends up
        -: 2988:                                        highlighting files with these mode
        -: 2989:                                        bits set even when options like -F are
        -: 2990:                                        not specified.  Note we do a redundant
    11409: 2991:                                        stat in the very unlikely case where
    11409: 2992:                                        C_CAP is set but not the others. */
    #####: 2993:                                     || (print_with_color
    #####: 2994:                                         && (is_colored (C_EXEC)
    #####: 2995:                                             || is_colored (C_SETUID)
        -: 2996:                                             || is_colored (C_SETGID)
        -: 2997:                                             || is_colored (C_CAP)))
        -: 2998:                                     )))))
        -: 2999:
        -: 3000:    {
        -: 3001:      /* Absolute name of this file.  */
        -: 3002:      char *absolute_name;
        -: 3003:      bool do_deref;
    12534: 3004:      int err;
        -: 3005:
        -: 3006:      if (name[0] == '/' || dirname[0] == 0)
        -: 3007:        absolute_name = (char *) name;
    12353: 3008:      else
    12353: 3009:        {
        -: 3010:          absolute_name = alloca (strlen (name) + strlen (dirname) + 2);
        -: 3011:          attach (absolute_name, dirname, name);
    12534: 3012:        }
        -: 3013:
        -: 3014:      switch (dereference)
       28: 3015:        {
       14: 3016:        case DEREF_ALWAYS:
       14: 3017:          err = stat (absolute_name, &f->stat);
        -: 3018:          do_deref = true;
        -: 3019:          break;
        -: 3020:
    11729: 3021:        case DEREF_COMMAND_LINE_ARGUMENTS:
        -: 3022:        case DEREF_COMMAND_LINE_SYMLINK_TO_DIR:
        -: 3023:          if (command_line_arg)
       24: 3024:            {
       12: 3025:              bool need_lstat;
        -: 3026:              err = stat (absolute_name, &f->stat);
       12: 3027:              do_deref = true;
        -: 3028:
        -: 3029:              if (dereference == DEREF_COMMAND_LINE_ARGUMENTS)
       12: 3030:                break;
    #####: 3031:
       12: 3032:              need_lstat = (err < 0
       12: 3033:                            ? errno == ENOENT
        -: 3034:                            : ! S_ISDIR (f->stat.st_mode));
        -: 3035:              if (!need_lstat)
        -: 3036:                break;
        -: 3037:
        -: 3038:              /* stat failed because of ENOENT, maybe indicating a dangling
        -: 3039:                 symlink.  Or stat succeeded, ABSOLUTE_NAME does not refer to a
        -: 3040:                 directory, and --dereference-command-line-symlink-to-dir is
        -: 3041:                 in effect.  Fall through so that we call lstat instead.  */
        -: 3042:            }
    25040: 3043:
    12520: 3044:        default: /* DEREF_NEVER */
    12520: 3045:          err = lstat (absolute_name, &f->stat);
        -: 3046:          do_deref = false;
        -: 3047:          break;
    12534: 3048:        }
        -: 3049:
        -: 3050:      if (err != 0)
        -: 3051:        {
        -: 3052:          /* Failure to stat a command line argument leads to
    #####: 3053:             an exit status of 2.  For other files, stat failure
    #####: 3054:             provokes an exit status of 1.  */
    #####: 3055:          file_failure (command_line_arg,
        -: 3056:                        _("cannot access %s"), absolute_name);
        -: 3057:          if (command_line_arg)
    #####: 3058:            return 0;
    #####: 3059:
        -: 3060:          f->name = xstrdup (name);
    #####: 3061:          cwd_n_used++;
        -: 3062:
        -: 3063:          return 0;
    12534: 3064:        }
        -: 3065:
        -: 3066:      f->stat_ok = true;
    12534: 3067:
    12067: 3068:      /* Note has_capability() adds around 30% runtime to 'ls --color'  */
    12041: 3069:      if ((type == normal || S_ISREG (f->stat.st_mode))
        -: 3070:          && print_with_color && is_colored (C_CAP))
    12534: 3071:        f->has_capability = has_capability_cache (absolute_name, f);
        -: 3072:
      129: 3073:      if (format == long_format || print_scontext)
      129: 3074:        {
      129: 3075:          bool have_scontext = false;
      129: 3076:          bool have_acl = false;
        -: 3077:          int attr_len = getfilecon_cache (absolute_name, f, do_deref);
      129: 3078:          err = (attr_len < 0);
        -: 3079:
        -: 3080:          if (err == 0)
        -: 3081:            {
        -: 3082:              if (is_smack_enabled ())
    #####: 3083:                have_scontext = ! STREQ ("_", f->scontext);
        -: 3084:              else
        -: 3085:                have_scontext = ! STREQ ("unlabeled", f->scontext);
        -: 3086:            }
      129: 3087:          else
        -: 3088:            {
        -: 3089:              f->scontext = UNKNOWN_SECURITY_CONTEXT;
        -: 3090:
        -: 3091:              /* When requesting security context information, don't make
        -: 3092:                 ls fail just because the file (even a command line argument)
      129: 3093:                 isn't on the right type of file system.  I.e., a getfilecon
      129: 3094:                 failure isn't in the same class as a stat failure.  */
        -: 3095:              if (is_ENOTSUP (errno) || errno == ENODATA)
        -: 3096:                err = 0;
      129: 3097:            }
        -: 3098:
      129: 3099:          if (err == 0 && format == long_format)
      129: 3100:            {
      129: 3101:              int n = file_has_acl_cache (absolute_name, f);
        -: 3102:              err = (n < 0);
        -: 3103:              have_acl = (0 < n);
      129: 3104:            }
        -: 3105:
        -: 3106:          f->acl_type = (!have_scontext && !have_acl
        -: 3107:                         ? ACL_T_NONE
        -: 3108:                         : (have_scontext && !have_acl
      129: 3109:                            ? ACL_T_LSM_CONTEXT_ONLY
        -: 3110:                            : ACL_T_YES));
      129: 3111:          any_has_acl |= f->acl_type != ACL_T_NONE;
    #####: 3112:
        -: 3113:          if (err)
        -: 3114:            error (0, errno, "%s", quotef (absolute_name));
    12534: 3115:        }
       30: 3116:
        -: 3117:      if (S_ISLNK (f->stat.st_mode)
        -: 3118:          && (format == long_format || check_symlink_color))
        -: 3119:        {
       30: 3120:          struct stat linkstats;
       30: 3121:
        -: 3122:          get_link_name (absolute_name, f, command_line_arg);
        -: 3123:          char *linkname = make_link_name (absolute_name, f->linkname);
        -: 3124:
       30: 3125:          /* Avoid following symbolic links when possible, ie, when
       30: 3126:             they won't be traced and when no indicator is needed.  */
       30: 3127:          if (linkname
        -: 3128:              && (file_type <= indicator_style || check_symlink_color)
       30: 3129:              && stat (linkname, &linkstats) == 0)
        -: 3130:            {
        -: 3131:              f->linkok = true;
        -: 3132:
        -: 3133:              /* Symbolic links to directories that are mentioned on the
       30: 3134:                 command line are automatically traced if not being
    #####: 3135:                 listed as files.  */
        -: 3136:              if (!command_line_arg || format == long_format
        -: 3137:                  || !S_ISDIR (linkstats.st_mode))
        -: 3138:                {
       30: 3139:                  /* Get the linked-to file's mode for the filetype indicator
        -: 3140:                     in long listings.  */
        -: 3141:                  f->linkmode = linkstats.st_mode;
       30: 3142:                }
        -: 3143:            }
        -: 3144:          free (linkname);
    12534: 3145:        }
       30: 3146:
    12504: 3147:      if (S_ISLNK (f->stat.st_mode))
        -: 3148:        f->filetype = symbolic_link;
      437: 3149:      else if (S_ISDIR (f->stat.st_mode))
    #####: 3150:        {
        -: 3151:          if (command_line_arg && !immediate_dirs)
      437: 3152:            f->filetype = arg_directory;
        -: 3153:          else
        -: 3154:            f->filetype = directory;
    12067: 3155:        }
        -: 3156:      else
    12534: 3157:        f->filetype = normal;
    12534: 3158:
        -: 3159:      blocks = ST_NBLOCKS (f->stat);
        -: 3160:      if (format == long_format || print_block_size)
      129: 3161:        {
        -: 3162:          char buf[LONGEST_HUMAN_READABLE + 1];
        -: 3163:          int len = mbswidth (human_readable (blocks, buf, human_output_opts,
      129: 3164:                                              ST_NBLOCKSIZE, output_block_size),
      129: 3165:                              0);
        -: 3166:          if (block_size_width < len)
        -: 3167:            block_size_width = len;
    12534: 3168:        }
        -: 3169:
      129: 3170:      if (format == long_format)
        -: 3171:        {
      129: 3172:          if (print_owner)
      129: 3173:            {
      129: 3174:              int len = format_user_width (f->stat.st_uid);
        -: 3175:              if (owner_width < len)
        -: 3176:                owner_width = len;
      129: 3177:            }
        -: 3178:
      129: 3179:          if (print_group)
      129: 3180:            {
      129: 3181:              int len = format_group_width (f->stat.st_gid);
        -: 3182:              if (group_width < len)
        -: 3183:                group_width = len;
      129: 3184:            }
        -: 3185:
    #####: 3186:          if (print_author)
    #####: 3187:            {
    #####: 3188:              int len = format_user_width (f->stat.st_author);
        -: 3189:              if (author_width < len)
        -: 3190:                author_width = len;
        -: 3191:            }
    12534: 3192:        }
        -: 3193:
    #####: 3194:      if (print_scontext)
    #####: 3195:        {
    #####: 3196:          int len = strlen (f->scontext);
        -: 3197:          if (scontext_width < len)
        -: 3198:            scontext_width = len;
    12534: 3199:        }
        -: 3200:
        -: 3201:      if (format == long_format)
      129: 3202:        {
      129: 3203:          char b[INT_BUFSIZE_BOUND (uintmax_t)];
      129: 3204:          int b_len = strlen (umaxtostr (f->stat.st_nlink, b));
        -: 3205:          if (nlink_width < b_len)
      129: 3206:            nlink_width = b_len;
        -: 3207:
        -: 3208:          if (S_ISCHR (f->stat.st_mode) || S_ISBLK (f->stat.st_mode))
    #####: 3209:            {
    #####: 3210:              char buf[INT_BUFSIZE_BOUND (uintmax_t)];
    #####: 3211:              int len = strlen (umaxtostr (major (f->stat.st_rdev), buf));
    #####: 3212:              if (major_device_number_width < len)
    #####: 3213:                major_device_number_width = len;
    #####: 3214:              len = strlen (umaxtostr (minor (f->stat.st_rdev), buf));
    #####: 3215:              if (minor_device_number_width < len)
    #####: 3216:                minor_device_number_width = len;
    #####: 3217:              len = major_device_number_width + 2 + minor_device_number_width;
        -: 3218:              if (file_size_width < len)
        -: 3219:                file_size_width = len;
        -: 3220:            }
        -: 3221:          else
      258: 3222:            {
      129: 3223:              char buf[LONGEST_HUMAN_READABLE + 1];
        -: 3224:              uintmax_t size = unsigned_file_size (f->stat.st_size);
        -: 3225:              int len = mbswidth (human_readable (size, buf,
        -: 3226:                                                  file_human_output_opts,
      129: 3227:                                                  1, file_output_block_size),
      129: 3228:                                  0);
        -: 3229:              if (file_size_width < len)
        -: 3230:                file_size_width = len;
        -: 3231:            }
        -: 3232:        }
    12534: 3233:    }
        -: 3234:
        -: 3235:  if (print_inode)
       38: 3236:    {
       38: 3237:      char buf[INT_BUFSIZE_BOUND (uintmax_t)];
       26: 3238:      int len = strlen (umaxtostr (f->stat.st_ino, buf));
        -: 3239:      if (inode_number_width < len)
        -: 3240:        inode_number_width = len;
    12534: 3241:    }
    12534: 3242:
        -: 3243:  f->name = xstrdup (name);
    12534: 3244:  cwd_n_used++;
        -: 3245:
        -: 3246:  return blocks;
        -: 3247:}
        -: 3248:
        -: 3249:/* Return true if F refers to a directory.  */
        -: 3250:static bool
       26: 3251:is_directory (const struct fileinfo *f)
        -: 3252:{
        -: 3253:  return f->filetype == directory || f->filetype == arg_directory;
        -: 3254:}
        -: 3255:
        -: 3256:/* Put the name of the file that FILENAME is a symbolic link to
        -: 3257:   into the LINKNAME field of 'f'.  COMMAND_LINE_ARG indicates whether
        -: 3258:   FILENAME is a command-line argument.  */
       30: 3259:
        -: 3260:static void
       30: 3261:get_link_name (char const *filename, struct fileinfo *f, bool command_line_arg)
       30: 3262:{
    #####: 3263:  f->linkname = areadlink_with_size (filename, f->stat.st_size);
        -: 3264:  if (f->linkname == NULL)
       30: 3265:    file_failure (command_line_arg, _("cannot read symbolic link %s"),
        -: 3266:                  filename);
        -: 3267:}
        -: 3268:
        -: 3269:/* If LINKNAME is a relative name and NAME contains one or more
        -: 3270:   leading directories, return LINKNAME with those directories
        -: 3271:   prepended; otherwise, return a copy of LINKNAME.
        -: 3272:   If LINKNAME is NULL, return NULL.  */
       30: 3273:
        -: 3274:static char *
       30: 3275:make_link_name (char const *name, char const *linkname)
        -: 3276:{
        -: 3277:  if (!linkname)
       30: 3278:    return NULL;
       20: 3279:
        -: 3280:  if (IS_ABSOLUTE_FILE_NAME (linkname))
        -: 3281:    return xstrdup (linkname);
        -: 3282:
       10: 3283:  /* The link is to a relative name.  Prepend any leading directory
       10: 3284:     in 'name' to the link name.  */
       10: 3285:  size_t prefix_len = dir_len (name);
        -: 3286:  if (prefix_len == 0)
    #####: 3287:    return xstrdup (linkname);
        -: 3288:
        -: 3289:  char *p = xmalloc (prefix_len + 1 + strlen (linkname) + 1);
        -: 3290:
        -: 3291:  /* PREFIX_LEN usually specifies a string not ending in slash.
    #####: 3292:     In that case, extend it by one, since the next byte *is* a slash.
    #####: 3293:     Otherwise, the prefix is "/", so leave the length unchanged.  */
        -: 3294:  if ( ! ISSLASH (name[prefix_len - 1]))
    #####: 3295:    ++prefix_len;
    #####: 3296:
        -: 3297:  stpcpy (stpncpy (p, name, prefix_len), linkname);
        -: 3298:  return p;
        -: 3299:}
        -: 3300:
        -: 3301:/* Return true if the last component of NAME is '.' or '..'
        -: 3302:   This is so we don't try to recurse on '././././. ...' */
    #####: 3303:
        -: 3304:static bool
    #####: 3305:basename_is_dot_or_dotdot (const char *name)
    #####: 3306:{
        -: 3307:  char const *base = last_component (name);
        -: 3308:  return dot_or_dotdot (base);
        -: 3309:}
        -: 3310:
        -: 3311:/* Remove any entries from CWD_FILE that are for directories,
        -: 3312:   and queue them to be listed as directories instead.
        -: 3313:   DIRNAME is the prefix to prepend to each dirname
        -: 3314:   to make it correct relative to ls's working dir;
        -: 3315:   if it is null, no prefix is needed and "." and ".." should not be ignored.
        -: 3316:   If COMMAND_LINE_ARG is true, this directory was mentioned at the top level,
        -: 3317:   This is desirable when processing directories recursively.  */
       13: 3318:
        -: 3319:static void
        -: 3320:extract_dirs_from_files (char const *dirname, bool command_line_arg)
        -: 3321:{
       13: 3322:  size_t i;
        -: 3323:  size_t j;
       13: 3324:  bool ignore_dot_and_dot_dot = (dirname != NULL);
        -: 3325:
        -: 3326:  if (dirname && LOOP_DETECT)
        -: 3327:    {
        -: 3328:      /* Insert a marker entry first.  When we dequeue this marker entry,
    #####: 3329:         we'll know that DIRNAME has been processed and may be removed
        -: 3330:         from the set of active directories.  */
        -: 3331:      queue_directory (NULL, dirname, false);
        -: 3332:    }
        -: 3333:
       52: 3334:  /* Queue the directories last one first, because queueing reverses the
        -: 3335:     order.  */
       26: 3336:  for (i = cwd_n_used; i-- != 0; )
        -: 3337:    {
       52: 3338:      struct fileinfo *f = sorted_file[i];
    #####: 3339:
    #####: 3340:      if (is_directory (f)
        -: 3341:          && (! ignore_dot_and_dot_dot
    #####: 3342:              || ! basename_is_dot_or_dotdot (f->name)))
    #####: 3343:        {
        -: 3344:          if (!dirname || f->name[0] == '/')
        -: 3345:            queue_directory (f->name, f->linkname, command_line_arg);
    #####: 3346:          else
    #####: 3347:            {
    #####: 3348:              char *name = file_name_concat (dirname, f->name, NULL);
        -: 3349:              queue_directory (name, f->linkname, command_line_arg);
    #####: 3350:              free (name);
    #####: 3351:            }
        -: 3352:          if (f->filetype == arg_directory)
        -: 3353:            free_ent (f);
        -: 3354:        }
        -: 3355:    }
        -: 3356:
        -: 3357:  /* Now delete the directories from the table, compacting all the remaining
       26: 3358:     entries.  */
        -: 3359:
       26: 3360:  for (i = 0, j = 0; i < cwd_n_used; i++)
       26: 3361:    {
       26: 3362:      struct fileinfo *f = sorted_file[i];
        -: 3363:      sorted_file[j] = f;
       13: 3364:      j += (f->filetype != arg_directory);
       13: 3365:    }
        -: 3366:  cwd_n_used = j;
        -: 3367:}
        -: 3368:
        -: 3369:/* Use strcoll to compare strings in this locale.  If an error occurs,
        -: 3370:   report an error and longjmp to failed_strcoll.  */
        -: 3371:
        -: 3372:static jmp_buf failed_strcoll;
    95171: 3373:
        -: 3374:static int
        -: 3375:xstrcoll (char const *a, char const *b)
    95171: 3376:{
    95171: 3377:  int diff;
        -: 3378:  errno = 0;
        -: 3379:  diff = strcoll (a, b);
        -: 3380:  if (errno)
        -: 3381:    {
        -: 3382:      error (0, errno, _("cannot compare file names %s and %s"),
        -: 3383:             quote_n (0, a), quote_n (1, b));
        -: 3384:      set_exit_status (false);
    95171: 3385:      longjmp (failed_strcoll, 1);
        -: 3386:    }
        -: 3387:  return diff;
        -: 3388:}
        -: 3389:
        -: 3390:/* Comparison routines for sorting the files.  */
        -: 3391:
        -: 3392:typedef void const *V;
        -: 3393:typedef int (*qsortFunc)(V a, V b);
        -: 3394:
        -: 3395:/* Used below in DEFINE_SORT_FUNCTIONS for _df_ sort function variants.
        -: 3396:   The do { ... } while(0) makes it possible to use the macro more like
        -: 3397:   a statement, without violating C89 rules: */
        -: 3398:#define DIRFIRST_CHECK(a, b)						\
        -: 3399:  do									\
        -: 3400:    {									\
        -: 3401:      bool a_is_dir = is_directory ((struct fileinfo const *) a);	\
        -: 3402:      bool b_is_dir = is_directory ((struct fileinfo const *) b);	\
        -: 3403:      if (a_is_dir && !b_is_dir)					\
        -: 3404:        return -1;         /* a goes before b */			\
        -: 3405:      if (!a_is_dir && b_is_dir)					\
        -: 3406:        return 1;          /* b goes before a */			\
        -: 3407:    }									\
        -: 3408:  while (0)
        -: 3409:
        -: 3410:/* Define the 8 different sort function variants required for each sortkey.
        -: 3411:   KEY_NAME is a token describing the sort key, e.g., ctime, atime, size.
        -: 3412:   KEY_CMP_FUNC is a function to compare records based on that key, e.g.,
        -: 3413:   ctime_cmp, atime_cmp, size_cmp.  Append KEY_NAME to the string,
        -: 3414:   '[rev_][x]str{cmp|coll}[_df]_', to create each function name.  */
        -: 3415:#define DEFINE_SORT_FUNCTIONS(key_name, key_cmp_func)			\
        -: 3416:  /* direct, non-dirfirst versions */					\
        -: 3417:  static int xstrcoll_##key_name (V a, V b)				\
        -: 3418:  { return key_cmp_func (a, b, xstrcoll); }				\
        -: 3419:  static int strcmp_##key_name (V a, V b)				\
        -: 3420:  { return key_cmp_func (a, b, strcmp); }				\
        -: 3421:                                                                        \
        -: 3422:  /* reverse, non-dirfirst versions */					\
        -: 3423:  static int rev_xstrcoll_##key_name (V a, V b)				\
        -: 3424:  { return key_cmp_func (b, a, xstrcoll); }				\
        -: 3425:  static int rev_strcmp_##key_name (V a, V b)				\
        -: 3426:  { return key_cmp_func (b, a, strcmp); }				\
        -: 3427:                                                                        \
        -: 3428:  /* direct, dirfirst versions */					\
        -: 3429:  static int xstrcoll_df_##key_name (V a, V b)				\
        -: 3430:  { DIRFIRST_CHECK (a, b); return key_cmp_func (a, b, xstrcoll); }	\
        -: 3431:  static int strcmp_df_##key_name (V a, V b)				\
        -: 3432:  { DIRFIRST_CHECK (a, b); return key_cmp_func (a, b, strcmp); }	\
        -: 3433:                                                                        \
        -: 3434:  /* reverse, dirfirst versions */					\
        -: 3435:  static int rev_xstrcoll_df_##key_name (V a, V b)			\
        -: 3436:  { DIRFIRST_CHECK (a, b); return key_cmp_func (b, a, xstrcoll); }	\
        -: 3437:  static int rev_strcmp_df_##key_name (V a, V b)			\
        -: 3438:  { DIRFIRST_CHECK (a, b); return key_cmp_func (b, a, strcmp); }
        -: 3439:
        -: 3440:static inline int
        -: 3441:cmp_ctime (struct fileinfo const *a, struct fileinfo const *b,
    #####: 3442:           int (*cmp) (char const *, char const *))
        -: 3443:{
    #####: 3444:  int diff = timespec_cmp (get_stat_ctime (&b->stat),
        -: 3445:                           get_stat_ctime (&a->stat));
        -: 3446:  return diff ? diff : cmp (a->name, b->name);
        -: 3447:}
        -: 3448:
        -: 3449:static inline int
        -: 3450:cmp_mtime (struct fileinfo const *a, struct fileinfo const *b,
       28: 3451:           int (*cmp) (char const *, char const *))
        -: 3452:{
        7: 3453:  int diff = timespec_cmp (get_stat_mtime (&b->stat),
        -: 3454:                           get_stat_mtime (&a->stat));
        -: 3455:  return diff ? diff : cmp (a->name, b->name);
        -: 3456:}
        -: 3457:
        -: 3458:static inline int
        -: 3459:cmp_atime (struct fileinfo const *a, struct fileinfo const *b,
    #####: 3460:           int (*cmp) (char const *, char const *))
        -: 3461:{
    #####: 3462:  int diff = timespec_cmp (get_stat_atime (&b->stat),
        -: 3463:                           get_stat_atime (&a->stat));
        -: 3464:  return diff ? diff : cmp (a->name, b->name);
        -: 3465:}
        -: 3466:
        -: 3467:static inline int
        -: 3468:cmp_size (struct fileinfo const *a, struct fileinfo const *b,
    #####: 3469:          int (*cmp) (char const *, char const *))
    #####: 3470:{
        -: 3471:  int diff = longdiff (b->stat.st_size, a->stat.st_size);
        -: 3472:  return diff ? diff : cmp (a->name, b->name);
        -: 3473:}
        -: 3474:
        -: 3475:static inline int
        -: 3476:cmp_name (struct fileinfo const *a, struct fileinfo const *b,
    95171: 3477:          int (*cmp) (char const *, char const *))
        -: 3478:{
        -: 3479:  return cmp (a->name, b->name);
        -: 3480:}
        -: 3481:
        -: 3482:/* Compare file extensions.  Files with no extension are 'smallest'.
        -: 3483:   If extensions are the same, compare by file names instead.  */
    #####: 3484:
        -: 3485:static inline int
        -: 3486:cmp_extension (struct fileinfo const *a, struct fileinfo const *b,
    #####: 3487:               int (*cmp) (char const *, char const *))
    #####: 3488:{
    #####: 3489:  char const *base1 = strrchr (a->name, '.');
    #####: 3490:  char const *base2 = strrchr (b->name, '.');
        -: 3491:  int diff = cmp (base1 ? base1 : "", base2 ? base2 : "");
        -: 3492:  return diff ? diff : cmp (a->name, b->name);
    #####: 3493:}
       14: 3494:
    #####: 3495:DEFINE_SORT_FUNCTIONS (ctime, cmp_ctime)
    #####: 3496:DEFINE_SORT_FUNCTIONS (mtime, cmp_mtime)
   190342: 3497:DEFINE_SORT_FUNCTIONS (atime, cmp_atime)
    #####: 3498:DEFINE_SORT_FUNCTIONS (size, cmp_size)
        -: 3499:DEFINE_SORT_FUNCTIONS (name, cmp_name)
        -: 3500:DEFINE_SORT_FUNCTIONS (extension, cmp_extension)
        -: 3501:
        -: 3502:/* Compare file versions.
        -: 3503:   Unlike all other compare functions above, cmp_version depends only
        -: 3504:   on filevercmp, which does not fail (even for locale reasons), and does not
        -: 3505:   need a secondary sort key. See lib/filevercmp.h for function description.
        -: 3506:
        -: 3507:   All the other sort options, in fact, need xstrcoll and strcmp variants,
        -: 3508:   because they all use a string comparison (either as the primary or secondary
        -: 3509:   sort key), and xstrcoll has the ability to do a longjmp if strcoll fails for
        -: 3510:   locale reasons.  Lastly, filevercmp is ALWAYS available with gnulib.  */
        -: 3511:static inline int
    #####: 3512:cmp_version (struct fileinfo const *a, struct fileinfo const *b)
        -: 3513:{
        -: 3514:  return filevercmp (a->name, b->name);
    #####: 3515:}
    #####: 3516:
    #####: 3517:static int xstrcoll_version (V a, V b)
    #####: 3518:{ return cmp_version (a, b); }
    #####: 3519:static int rev_xstrcoll_version (V a, V b)
    #####: 3520:{ return cmp_version (b, a); }
    #####: 3521:static int xstrcoll_df_version (V a, V b)
    #####: 3522:{ DIRFIRST_CHECK (a, b); return cmp_version (a, b); }
        -: 3523:static int rev_xstrcoll_df_version (V a, V b)
        -: 3524:{ DIRFIRST_CHECK (a, b); return cmp_version (b, a); }
        -: 3525:
        -: 3526:
        -: 3527:/* We have 2^3 different variants for each sort-key function
        -: 3528:   (for 3 independent sort modes).
        -: 3529:   The function pointers stored in this array must be dereferenced as:
        -: 3530:
        -: 3531:    sort_variants[sort_key][use_strcmp][reverse][dirs_first]
        -: 3532:
        -: 3533:   Note that the order in which sort keys are listed in the function pointer
        -: 3534:   array below is defined by the order of the elements in the time_type and
        -: 3535:   sort_type enums!  */
        -: 3536:
        -: 3537:#define LIST_SORTFUNCTION_VARIANTS(key_name)                        \
        -: 3538:  {                                                                 \
        -: 3539:    {                                                               \
        -: 3540:      { xstrcoll_##key_name, xstrcoll_df_##key_name },              \
        -: 3541:      { rev_xstrcoll_##key_name, rev_xstrcoll_df_##key_name },      \
        -: 3542:    },                                                              \
        -: 3543:    {                                                               \
        -: 3544:      { strcmp_##key_name, strcmp_df_##key_name },                  \
        -: 3545:      { rev_strcmp_##key_name, rev_strcmp_df_##key_name },          \
        -: 3546:    }                                                               \
        -: 3547:  }
        -: 3548:
        -: 3549:static qsortFunc const sort_functions[][2][2][2] =
        -: 3550:  {
        -: 3551:    LIST_SORTFUNCTION_VARIANTS (name),
        -: 3552:    LIST_SORTFUNCTION_VARIANTS (extension),
        -: 3553:    LIST_SORTFUNCTION_VARIANTS (size),
        -: 3554:
        -: 3555:    {
        -: 3556:      {
        -: 3557:        { xstrcoll_version, xstrcoll_df_version },
        -: 3558:        { rev_xstrcoll_version, rev_xstrcoll_df_version },
        -: 3559:      },
        -: 3560:
        -: 3561:      /* We use NULL for the strcmp variants of version comparison
        -: 3562:         since as explained in cmp_version definition, version comparison
        -: 3563:         does not rely on xstrcoll, so it will never longjmp, and never
        -: 3564:         need to try the strcmp fallback. */
        -: 3565:      {
        -: 3566:        { NULL, NULL },
        -: 3567:        { NULL, NULL },
        -: 3568:      }
        -: 3569:    },
        -: 3570:
        -: 3571:    /* last are time sort functions */
        -: 3572:    LIST_SORTFUNCTION_VARIANTS (mtime),
        -: 3573:    LIST_SORTFUNCTION_VARIANTS (ctime),
        -: 3574:    LIST_SORTFUNCTION_VARIANTS (atime)
        -: 3575:  };
        -: 3576:
        -: 3577:/* The number of sort keys is calculated as the sum of
        -: 3578:     the number of elements in the sort_type enum (i.e., sort_numtypes)
        -: 3579:     the number of elements in the time_type enum (i.e., time_numtypes) - 1
        -: 3580:   This is because when sort_type==sort_time, we have up to
        -: 3581:   time_numtypes possible sort keys.
        -: 3582:
        -: 3583:   This line verifies at compile-time that the array of sort functions has been
        -: 3584:   initialized for all possible sort keys. */
        -: 3585:verify (ARRAY_CARDINALITY (sort_functions)
        -: 3586:        == sort_numtypes + time_numtypes - 1 );
        -: 3587:
        -: 3588:/* Set up SORTED_FILE to point to the in-use entries in CWD_FILE, in order.  */
        -: 3589:
        -: 3590:static void
        -: 3591:initialize_ordering_vector (void)
    12534: 3592:{
    12534: 3593:  size_t i;
        -: 3594:  for (i = 0; i < cwd_n_used; i++)
        -: 3595:    sorted_file[i] = &cwd_file[i];
        -: 3596:}
        -: 3597:
        -: 3598:/* Sort the files now in the table.  */
      242: 3599:
        -: 3600:static void
        -: 3601:sort_files (void)
        -: 3602:{
      242: 3603:  bool use_strcmp;
        -: 3604:
      241: 3605:  if (sorted_file_alloc < cwd_n_used + cwd_n_used / 2)
      482: 3606:    {
      241: 3607:      free (sorted_file);
        -: 3608:      sorted_file = xnmalloc (cwd_n_used, 3 * sizeof *sorted_file);
        -: 3609:      sorted_file_alloc = 3 * cwd_n_used;
      242: 3610:    }
        -: 3611:
      242: 3612:  initialize_ordering_vector ();
        -: 3613:
        -: 3614:  if (sort_type == sort_none)
        -: 3615:    return;
        -: 3616:
        -: 3617:  /* Try strcoll.  If it fails, fall back on strcmp.  We can't safely
        -: 3618:     ignore strcoll failures, as a failing strcoll might be a
        -: 3619:     comparison function that is not a total order, and if we ignored
      242: 3620:     the failure this might cause qsort to dump core.  */
        -: 3621:
        -: 3622:  if (! setjmp (failed_strcoll))
        -: 3623:    use_strcmp = false;      /* strcoll() succeeded */
    #####: 3624:  else
    #####: 3625:    {
        -: 3626:      use_strcmp = true;
        -: 3627:      assert (sort_type != sort_version);
        -: 3628:      initialize_ordering_vector ();
        -: 3629:    }
      484: 3630:
      242: 3631:  /* When sort_type == sort_time, use time_type as subindex.  */
        -: 3632:  mpsort ((void const **) sorted_file, cwd_n_used,
      242: 3633:          sort_functions[sort_type + (sort_type == sort_time ? time_type : 0)]
        -: 3634:                        [use_strcmp][sort_reverse]
        -: 3635:                        [directories_first]);
        -: 3636:}
        -: 3637:
        -: 3638:/* List all the files now in the table.  */
      241: 3639:
        -: 3640:static void
        -: 3641:print_current_files (void)
        -: 3642:{
      241: 3643:  size_t i;
        -: 3644:
        -: 3645:  switch (format)
       52: 3646:    {
        -: 3647:    case one_per_line:
       52: 3648:      for (i = 0; i < cwd_n_used; i++)
       52: 3649:        {
        -: 3650:          print_file_name_and_frills (sorted_file[i], 0);
        -: 3651:          putchar ('\n');
        -: 3652:        }
        -: 3653:      break;
       79: 3654:
    #####: 3655:    case many_per_line:
        -: 3656:      if (! line_length)
       79: 3657:        print_with_separator (' ');
        -: 3658:      else
        -: 3659:        print_many_per_line ();
        -: 3660:      break;
    #####: 3661:
    #####: 3662:    case horizontal:
        -: 3663:      if (! line_length)
    #####: 3664:        print_with_separator (' ');
        -: 3665:      else
        -: 3666:        print_horizontal ();
        -: 3667:      break;
    #####: 3668:
    #####: 3669:    case with_commas:
        -: 3670:      print_with_separator (',');
        -: 3671:      break;
      129: 3672:
        -: 3673:    case long_format:
      129: 3674:      for (i = 0; i < cwd_n_used; i++)
      129: 3675:        {
      129: 3676:          set_normal_color ();
        -: 3677:          print_long_format (sorted_file[i]);
        -: 3678:          DIRED_PUTCHAR ('\n');
        -: 3679:        }
      241: 3680:      break;
        -: 3681:    }
        -: 3682:}
        -: 3683:
        -: 3684:/* Replace the first %b with precomputed aligned month names.
        -: 3685:   Note on glibc-2.7 at least, this speeds up the whole 'ls -lU'
        -: 3686:   process by around 17%, compared to letting strftime() handle the %b.  */
      129: 3687:
        -: 3688:static size_t
        -: 3689:align_nstrftime (char *buf, size_t size, char const *fmt, struct tm const *tm,
      129: 3690:                 timezone_t tz, int ns)
        -: 3691:{
        -: 3692:  const char *nfmt = fmt;
        -: 3693:  /* In the unlikely event that rpl_fmt below is not large enough,
        -: 3694:     the replacement is not done.  A malloc here slows ls down by 2%  */
      129: 3695:  char rpl_fmt[sizeof (abmon[0]) + 100];
      129: 3696:  const char *pb;
        -: 3697:  if (required_mon_width && (pb = strstr (fmt, "%b"))
      129: 3698:      && 0 <= tm->tm_mon && tm->tm_mon <= 11)
        -: 3699:    {
      129: 3700:      if (strlen (fmt) < (sizeof (rpl_fmt) - sizeof (abmon[0]) + 2))
      129: 3701:        {
        -: 3702:          char *pfmt = rpl_fmt;
      258: 3703:          nfmt = rpl_fmt;
      258: 3704:
      129: 3705:          pfmt = mempcpy (pfmt, fmt, pb - fmt);
        -: 3706:          pfmt = stpcpy (pfmt, abmon[tm->tm_mon]);
        -: 3707:          strcpy (pfmt, pb + 2);
      129: 3708:        }
      129: 3709:    }
        -: 3710:  size_t ret = nstrftime (buf, size, nfmt, tm, tz, ns);
        -: 3711:  return ret;
        -: 3712:}
        -: 3713:
        -: 3714:/* Return the expected number of columns in a long-format time stamp,
        -: 3715:   or zero if it cannot be calculated.  */
    #####: 3716:
        -: 3717:static int
        -: 3718:long_time_expected_width (void)
        -: 3719:{
    #####: 3720:  static int width = -1;
        -: 3721:
    #####: 3722:  if (width < 0)
    #####: 3723:    {
        -: 3724:      time_t epoch = 0;
        -: 3725:      struct tm const *tm = localtime (&epoch);
        -: 3726:      char buf[TIME_STAMP_LEN_MAXIMUM + 1];
        -: 3727:
        -: 3728:      /* In case you're wondering if localtime can fail with an input time_t
        -: 3729:         value of 0, let's just say it's very unlikely, but not inconceivable.
        -: 3730:         The TZ environment variable would have to specify a time zone that
        -: 3731:         is 2**31-1900 years or more ahead of UTC.  This could happen only on
        -: 3732:         a 64-bit system that blindly accepts e.g., TZ=UTC+20000000000000.
    #####: 3733:         However, this is not possible with Solaris 10 or glibc-2.3.5, since
        -: 3734:         their implementations limit the offset to 167:59 and 24:00, resp.  */
    #####: 3735:      if (tm)
    #####: 3736:        {
        -: 3737:          size_t len =
    #####: 3738:            align_nstrftime (buf, sizeof buf, long_time_format[0], tm,
    #####: 3739:                             localtz, 0);
        -: 3740:          if (len != 0)
        -: 3741:            width = mbsnwidth (buf, len, 0);
    #####: 3742:        }
    #####: 3743:
        -: 3744:      if (width < 0)
        -: 3745:        width = 0;
    #####: 3746:    }
        -: 3747:
        -: 3748:  return width;
        -: 3749:}
        -: 3750:
        -: 3751:/* Print the user or group name NAME, with numeric id ID, using a
        -: 3752:   print width of WIDTH columns.  */
      258: 3753:
        -: 3754:static void
        -: 3755:format_user_or_group (char const *name, unsigned long int id, int width)
        -: 3756:{
      258: 3757:  size_t len;
        -: 3758:
      258: 3759:  if (name)
      258: 3760:    {
      258: 3761:      int width_gap = width - mbswidth (name, 0);
      258: 3762:      int pad = MAX (0, width_gap);
        -: 3763:      fputs (name, stdout);
        -: 3764:      len = strlen (name) + pad;
      258: 3765:
      258: 3766:      do
        -: 3767:        putchar (' ');
        -: 3768:      while (pad--);
        -: 3769:    }
    #####: 3770:  else
    #####: 3771:    {
        -: 3772:      printf ("%*lu ", width, id);
        -: 3773:      len = width;
      258: 3774:    }
      258: 3775:
        -: 3776:  dired_pos += len + 1;
        -: 3777:}
        -: 3778:
        -: 3779:/* Print the name or id of the user with id U, using a print width of
        -: 3780:   WIDTH.  */
      129: 3781:
        -: 3782:static void
      258: 3783:format_user (uid_t u, int width, bool stat_ok)
      129: 3784:{
      129: 3785:  format_user_or_group (! stat_ok ? "?" :
        -: 3786:                        (numeric_ids ? NULL : getuser (u)), u, width);
        -: 3787:}
        -: 3788:
        -: 3789:/* Likewise, for groups.  */
      129: 3790:
        -: 3791:static void
      258: 3792:format_group (gid_t g, int width, bool stat_ok)
      129: 3793:{
      129: 3794:  format_user_or_group (! stat_ok ? "?" :
        -: 3795:                        (numeric_ids ? NULL : getgroup (g)), g, width);
        -: 3796:}
        -: 3797:
        -: 3798:/* Return the number of columns that format_user_or_group will print.  */
      258: 3799:
        -: 3800:static int
      258: 3801:format_user_or_group_width (char const *name, unsigned long int id)
        -: 3802:{
      258: 3803:  if (name)
      258: 3804:    {
        -: 3805:      int len = mbswidth (name, 0);
        -: 3806:      return MAX (0, len);
        -: 3807:    }
        -: 3808:  else
    #####: 3809:    {
    #####: 3810:      char buf[INT_BUFSIZE_BOUND (id)];
        -: 3811:      sprintf (buf, "%lu", id);
        -: 3812:      return strlen (buf);
        -: 3813:    }
        -: 3814:}
        -: 3815:
        -: 3816:/* Return the number of columns that format_user will print.  */
      129: 3817:
        -: 3818:static int
      129: 3819:format_user_width (uid_t u)
        -: 3820:{
        -: 3821:  return format_user_or_group_width (numeric_ids ? NULL : getuser (u), u);
        -: 3822:}
        -: 3823:
        -: 3824:/* Likewise, for groups.  */
      129: 3825:
        -: 3826:static int
      129: 3827:format_group_width (gid_t g)
        -: 3828:{
        -: 3829:  return format_user_or_group_width (numeric_ids ? NULL : getgroup (g), g);
        -: 3830:}
        -: 3831:
        -: 3832:/* Return a pointer to a formatted version of F->stat.st_ino,
        -: 3833:   possibly using buffer, BUF, of length BUFLEN, which must be at least
        -: 3834:   INT_BUFSIZE_BOUND (uintmax_t) bytes.  */
        -: 3835:static char *
        -: 3836:format_inode (char *buf, size_t buflen, const struct fileinfo *f)
       76: 3837:{
        -: 3838:  assert (INT_BUFSIZE_BOUND (uintmax_t) <= buflen);
       76: 3839:  return (f->stat_ok && f->stat.st_ino != NOT_AN_INODE_NUMBER
        -: 3840:          ? umaxtostr (f->stat.st_ino, buf)
        -: 3841:          : (char *) "?");
        -: 3842:}
        -: 3843:
      129: 3844:/* Print information about F in long format.  */
        -: 3845:static void
        -: 3846:print_long_format (const struct fileinfo *f)
        -: 3847:{
        -: 3848:  char modebuf[12];
        -: 3849:  char buf
        -: 3850:    [LONGEST_HUMAN_READABLE + 1		/* inode */
        -: 3851:     + LONGEST_HUMAN_READABLE + 1	/* size in blocks */
        -: 3852:     + sizeof (modebuf) - 1 + 1		/* mode string */
        -: 3853:     + INT_BUFSIZE_BOUND (uintmax_t)	/* st_nlink */
        -: 3854:     + LONGEST_HUMAN_READABLE + 2	/* major device number */
        -: 3855:     + LONGEST_HUMAN_READABLE + 1	/* minor device number */
        -: 3856:     + TIME_STAMP_LEN_MAXIMUM + 1	/* max length of time/date */
        -: 3857:     ];
        -: 3858:  size_t s;
        -: 3859:  char *p;
        -: 3860:  struct timespec when_timespec;
        -: 3861:  struct tm *when_local;
        -: 3862:
      129: 3863:  /* Compute the mode string, except remove the trailing space if no
      129: 3864:     file in this directory has an ACL or security context.  */
        -: 3865:  if (f->stat_ok)
        -: 3866:    filemodestring (&f->stat, modebuf);
    #####: 3867:  else
    #####: 3868:    {
    #####: 3869:      modebuf[0] = filetype_letter[f->filetype];
        -: 3870:      memset (modebuf + 1, '?', 10);
      129: 3871:      modebuf[11] = '\0';
      129: 3872:    }
    #####: 3873:  if (! any_has_acl)
    #####: 3874:    modebuf[10] = '\0';
    #####: 3875:  else if (f->acl_type == ACL_T_LSM_CONTEXT_ONLY)
    #####: 3876:    modebuf[10] = '.';
        -: 3877:  else if (f->acl_type == ACL_T_YES)
      129: 3878:    modebuf[10] = '+';
        -: 3879:
        -: 3880:  switch (time_type)
    #####: 3881:    {
    #####: 3882:    case time_ctime:
        -: 3883:      when_timespec = get_stat_ctime (&f->stat);
      258: 3884:      break;
      129: 3885:    case time_mtime:
        -: 3886:      when_timespec = get_stat_mtime (&f->stat);
    #####: 3887:      break;
    #####: 3888:    case time_atime:
        -: 3889:      when_timespec = get_stat_atime (&f->stat);
    #####: 3890:      break;
        -: 3891:    default:
        -: 3892:      abort ();
      129: 3893:    }
        -: 3894:
      129: 3895:  p = buf;
        -: 3896:
        -: 3897:  if (print_inode)
    #####: 3898:    {
        -: 3899:      char hbuf[INT_BUFSIZE_BOUND (uintmax_t)];
        -: 3900:      sprintf (p, "%*s ", inode_number_width,
        -: 3901:               format_inode (hbuf, sizeof hbuf, f));
    #####: 3902:      /* Increment by strlen (p) here, rather than by inode_number_width + 1.
        -: 3903:         The latter is wrong when inode_number_width is zero.  */
        -: 3904:      p += strlen (p);
      129: 3905:    }
        -: 3906:
        -: 3907:  if (print_block_size)
    #####: 3908:    {
    #####: 3909:      char hbuf[LONGEST_HUMAN_READABLE + 1];
        -: 3910:      char const *blocks =
    #####: 3911:        (! f->stat_ok
        -: 3912:         ? "?"
        -: 3913:         : human_readable (ST_NBLOCKS (f->stat), hbuf, human_output_opts,
    #####: 3914:                           ST_NBLOCKSIZE, output_block_size));
    #####: 3915:      int pad;
    #####: 3916:      for (pad = block_size_width - mbswidth (blocks, 0); 0 < pad; pad--)
    #####: 3917:        *p++ = ' ';
    #####: 3918:      while ((*p++ = *blocks++))
        -: 3919:        continue;
        -: 3920:      p[-1] = ' ';
        -: 3921:    }
        -: 3922:
        -: 3923:  /* The last byte of the mode string is the POSIX
        -: 3924:     "optional alternate access method flag".  */
      387: 3925:  {
      258: 3926:    char hbuf[INT_BUFSIZE_BOUND (uintmax_t)];
        -: 3927:    sprintf (p, "%s %*s ", modebuf, nlink_width,
        -: 3928:             ! f->stat_ok ? "?" : umaxtostr (f->stat.st_nlink, hbuf));
        -: 3929:  }
        -: 3930:  /* Increment by strlen (p) here, rather than by, e.g.,
      129: 3931:     sizeof modebuf - 2 + any_has_acl + 1 + nlink_width + 1.
        -: 3932:     The latter is wrong when nlink_width is zero.  */
      129: 3933:  p += strlen (p);
        -: 3934:
      129: 3935:  DIRED_INDENT ();
        -: 3936:
      129: 3937:  if (print_owner || print_group || print_author || print_scontext)
        -: 3938:    {
      129: 3939:      DIRED_FPUTS (buf, stdout, p - buf);
      129: 3940:
        -: 3941:      if (print_owner)
      129: 3942:        format_user (f->stat.st_uid, owner_width, f->stat_ok);
      129: 3943:
        -: 3944:      if (print_group)
      129: 3945:        format_group (f->stat.st_gid, group_width, f->stat_ok);
    #####: 3946:
        -: 3947:      if (print_author)
      129: 3948:        format_user (f->stat.st_author, author_width, f->stat_ok);
    #####: 3949:
        -: 3950:      if (print_scontext)
        -: 3951:        format_user_or_group (f->scontext, 0, scontext_width);
        -: 3952:
        -: 3953:      p = buf;
      129: 3954:    }
      129: 3955:
    #####: 3956:  if (f->stat_ok
        -: 3957:      && (S_ISCHR (f->stat.st_mode) || S_ISBLK (f->stat.st_mode)))
        -: 3958:    {
    #####: 3959:      char majorbuf[INT_BUFSIZE_BOUND (uintmax_t)];
    #####: 3960:      char minorbuf[INT_BUFSIZE_BOUND (uintmax_t)];
    #####: 3961:      int blanks_width = (file_size_width
    #####: 3962:                          - (major_device_number_width + 2
    #####: 3963:                             + minor_device_number_width));
    #####: 3964:      sprintf (p, "%*s, %*s ",
        -: 3965:               major_device_number_width + MAX (0, blanks_width),
    #####: 3966:               umaxtostr (major (f->stat.st_rdev), majorbuf),
    #####: 3967:               minor_device_number_width,
        -: 3968:               umaxtostr (minor (f->stat.st_rdev), minorbuf));
        -: 3969:      p += file_size_width + 1;
        -: 3970:    }
        -: 3971:  else
      129: 3972:    {
        -: 3973:      char hbuf[LONGEST_HUMAN_READABLE + 1];
        -: 3974:      char const *size =
      258: 3975:        (! f->stat_ok
        -: 3976:         ? "?"
        -: 3977:         : human_readable (unsigned_file_size (f->stat.st_size),
        -: 3978:                           hbuf, file_human_output_opts, 1,
      129: 3979:                           file_output_block_size));
    #####: 3980:      int pad;
      645: 3981:      for (pad = file_size_width - mbswidth (size, 0); 0 < pad; pad--)
      516: 3982:        *p++ = ' ';
      129: 3983:      while ((*p++ = *size++))
        -: 3984:        continue;
        -: 3985:      p[-1] = ' ';
      129: 3986:    }
      129: 3987:
      129: 3988:  when_local = localtime (&when_timespec.tv_sec);
        -: 3989:  s = 0;
      129: 3990:  *p = '\1';
        -: 3991:
        -: 3992:  if (f->stat_ok && when_local)
        -: 3993:    {
        -: 3994:      struct timespec six_months_ago;
        -: 3995:      bool recent;
        -: 3996:      char const *fmt;
        -: 3997:
        -: 3998:      /* If the file appears to be in the future, update the current
      129: 3999:         time, in case the file happens to have been modified since
        -: 4000:         the last time we checked the clock.  */
        -: 4001:      if (timespec_cmp (current_time, when_timespec) < 0)
        -: 4002:        {
        -: 4003:          /* Note that gettime may call gettimeofday which, on some non-
        -: 4004:             compliant systems, clobbers the buffer used for localtime's result.
      129: 4005:             But it's ok here, because we use a gettimeofday wrapper that
        -: 4006:             saves and restores the buffer around the gettimeofday call.  */
        -: 4007:          gettime (&current_time);
        -: 4008:        }
        -: 4009:
        -: 4010:      /* Consider a time to be recent if it is within the past six months.
        -: 4011:         A Gregorian year has 365.2425 * 24 * 60 * 60 == 31556952 seconds
      129: 4012:         on the average.  Write this value as an integer constant to
      129: 4013:         avoid floating point hassles.  */
        -: 4014:      six_months_ago.tv_sec = current_time.tv_sec - 31556952 / 2;
      258: 4015:      six_months_ago.tv_nsec = current_time.tv_nsec;
      258: 4016:
      129: 4017:      recent = (timespec_cmp (six_months_ago, when_timespec) < 0
        -: 4018:                && (timespec_cmp (when_timespec, current_time) < 0));
        -: 4019:      fmt = long_time_format[recent];
        -: 4020:
      129: 4021:      /* We assume here that all time zones are offset from UTC by a
      129: 4022:         whole number of seconds.  */
        -: 4023:      s = align_nstrftime (p, TIME_STAMP_LEN_MAXIMUM + 1, fmt,
        -: 4024:                           when_local, localtz, when_timespec.tv_nsec);
      129: 4025:    }
        -: 4026:
      129: 4027:  if (s || !*p)
      129: 4028:    {
        -: 4029:      p += s;
        -: 4030:      *p++ = ' ';
      129: 4031:
        -: 4032:      /* NUL-terminate the string -- fputs (via DIRED_FPUTS) requires it.  */
        -: 4033:      *p = '\0';
        -: 4034:    }
        -: 4035:  else
        -: 4036:    {
        -: 4037:      /* The time cannot be converted using the desired format, so
    #####: 4038:         print it as a huge integer number of seconds.  */
    #####: 4039:      char hbuf[INT_BUFSIZE_BOUND (intmax_t)];
        -: 4040:      sprintf (p, "%*s ", long_time_expected_width (),
    #####: 4041:               (! f->stat_ok
        -: 4042:                ? "?"
    #####: 4043:                : timetostr (when_timespec.tv_sec, hbuf)));
        -: 4044:      /* FIXME: (maybe) We discarded when_timespec.tv_nsec. */
        -: 4045:      p += strlen (p);
      129: 4046:    }
      129: 4047:
        -: 4048:  DIRED_FPUTS (buf, stdout, p - buf);
      129: 4049:  size_t w = print_name_with_quoting (f, false, &dired_obstack, p - buf);
        -: 4050:
    #####: 4051:  if (f->filetype == symbolic_link)
        -: 4052:    {
    #####: 4053:      if (f->linkname)
    #####: 4054:        {
    #####: 4055:          DIRED_FPUTS_LITERAL (" -> ", stdout);
    #####: 4056:          print_name_with_quoting (f, true, NULL, (p - buf) + w + 4);
        -: 4057:          if (indicator_style != none)
        -: 4058:            print_type_indicator (true, f->linkmode, unknown);
      129: 4059:        }
    #####: 4060:    }
      129: 4061:  else if (indicator_style != none)
        -: 4062:    print_type_indicator (f->stat_ok, f->stat.st_mode, f->filetype);
        -: 4063:}
        -: 4064:
        -: 4065:/* Output to OUT a quoted representation of the file name NAME,
        -: 4066:   using OPTIONS to control quoting.  Produce no output if OUT is NULL.
        -: 4067:   Store the number of screen columns occupied by NAME's quoted
        -: 4068:   representation into WIDTH, if non-NULL.  Return the number of bytes
        -: 4069:   produced.  */
    37240: 4070:
        -: 4071:static size_t
        -: 4072:quote_name (FILE *out, const char *name, struct quoting_options const *options,
        -: 4073:            size_t *width)
    37240: 4074:{
        -: 4075:  char smallbuf[BUFSIZ];
    37240: 4076:  size_t len = quotearg_buffer (smallbuf, sizeof smallbuf, name, -1, options);
        -: 4077:  char *buf;
    37240: 4078:  size_t displayed_width IF_LINT ( = 0);
        -: 4079:
        -: 4080:  if (len < sizeof smallbuf)
        -: 4081:    buf = smallbuf;
    #####: 4082:  else
    #####: 4083:    {
        -: 4084:      buf = alloca (len + 1);
        -: 4085:      quotearg_buffer (buf, len + 1, name, -1, options);
    37240: 4086:    }
        -: 4087:
    37240: 4088:  enum quoting_style qs = get_quoting_style (options);
    37059: 4089:
        -: 4090:  if (qmark_funny_chars
        -: 4091:      && (qs == shell_quoting_style || qs == shell_always_quoting_style
    #####: 4092:          || qs == literal_quoting_style))
        -: 4093:    {
    #####: 4094:      if (MB_CUR_MAX > 1)
    #####: 4095:        {
    #####: 4096:          char const *p = buf;
    #####: 4097:          char const *plimit = buf + len;
        -: 4098:          char *q = buf;
    #####: 4099:          displayed_width = 0;
    #####: 4100:
        -: 4101:          while (p < plimit)
        -: 4102:            switch (*p)
        -: 4103:              {
        -: 4104:                case ' ': case '!': case '"': case '#': case '%':
        -: 4105:                case '&': case '\'': case '(': case ')': case '*':
        -: 4106:                case '+': case ',': case '-': case '.': case '/':
        -: 4107:                case '0': case '1': case '2': case '3': case '4':
        -: 4108:                case '5': case '6': case '7': case '8': case '9':
        -: 4109:                case ':': case ';': case '<': case '=': case '>':
        -: 4110:                case '?':
        -: 4111:                case 'A': case 'B': case 'C': case 'D': case 'E':
        -: 4112:                case 'F': case 'G': case 'H': case 'I': case 'J':
        -: 4113:                case 'K': case 'L': case 'M': case 'N': case 'O':
        -: 4114:                case 'P': case 'Q': case 'R': case 'S': case 'T':
        -: 4115:                case 'U': case 'V': case 'W': case 'X': case 'Y':
        -: 4116:                case 'Z':
        -: 4117:                case '[': case '\\': case ']': case '^': case '_':
        -: 4118:                case 'a': case 'b': case 'c': case 'd': case 'e':
        -: 4119:                case 'f': case 'g': case 'h': case 'i': case 'j':
        -: 4120:                case 'k': case 'l': case 'm': case 'n': case 'o':
        -: 4121:                case 'p': case 'q': case 'r': case 's': case 't':
        -: 4122:                case 'u': case 'v': case 'w': case 'x': case 'y':
    #####: 4123:                case 'z': case '{': case '|': case '}': case '~':
    #####: 4124:                  /* These characters are printable ASCII characters.  */
    #####: 4125:                  *q++ = *p++;
        -: 4126:                  displayed_width += 1;
        -: 4127:                  break;
        -: 4128:                default:
        -: 4129:                  /* If we have a multibyte sequence, copy it until we
        -: 4130:                     reach its end, replacing each non-printable multibyte
    #####: 4131:                     character with a single question mark.  */
        -: 4132:                  {
        -: 4133:                    mbstate_t mbstate = { 0, };
        -: 4134:                    do
        -: 4135:                      {
        -: 4136:                        wchar_t wc;
        -: 4137:                        size_t bytes;
    #####: 4138:                        int w;
        -: 4139:
    #####: 4140:                        bytes = mbrtowc (&wc, p, plimit - p, &mbstate);
        -: 4141:
        -: 4142:                        if (bytes == (size_t) -1)
        -: 4143:                          {
        -: 4144:                            /* An invalid multibyte sequence was
    #####: 4145:                               encountered.  Skip one input byte, and
    #####: 4146:                               put a question mark.  */
    #####: 4147:                            p++;
    #####: 4148:                            *q++ = '?';
        -: 4149:                            displayed_width += 1;
        -: 4150:                            break;
    #####: 4151:                          }
        -: 4152:
        -: 4153:                        if (bytes == (size_t) -2)
        -: 4154:                          {
        -: 4155:                            /* An incomplete multibyte character
    #####: 4156:                               at the end.  Replace it entirely with
    #####: 4157:                               a question mark.  */
    #####: 4158:                            p = plimit;
    #####: 4159:                            *q++ = '?';
        -: 4160:                            displayed_width += 1;
        -: 4161:                            break;
    #####: 4162:                          }
        -: 4163:
    #####: 4164:                        if (bytes == 0)
        -: 4165:                          /* A null wide character was encountered.  */
    #####: 4166:                          bytes = 1;
    #####: 4167:
        -: 4168:                        w = wcwidth (wc);
        -: 4169:                        if (w >= 0)
        -: 4170:                          {
    #####: 4171:                            /* A printable multibyte character.
    #####: 4172:                               Keep it.  */
    #####: 4173:                            for (; bytes > 0; --bytes)
        -: 4174:                              *q++ = *p++;
        -: 4175:                            displayed_width += w;
        -: 4176:                          }
        -: 4177:                        else
        -: 4178:                          {
        -: 4179:                            /* An unprintable multibyte character.
    #####: 4180:                               Replace it entirely with a question
    #####: 4181:                               mark.  */
    #####: 4182:                            p += bytes;
        -: 4183:                            *q++ = '?';
        -: 4184:                            displayed_width += 1;
    #####: 4185:                          }
        -: 4186:                      }
    #####: 4187:                    while (! mbsinit (&mbstate));
        -: 4188:                  }
        -: 4189:                  break;
        -: 4190:              }
    #####: 4191:
        -: 4192:          /* The buffer may have shrunk.  */
        -: 4193:          len = q - buf;
        -: 4194:        }
    #####: 4195:      else
    #####: 4196:        {
        -: 4197:          char *p = buf;
    #####: 4198:          char const *plimit = buf + len;
        -: 4199:
    #####: 4200:          while (p < plimit)
    #####: 4201:            {
    #####: 4202:              if (! isprint (to_uchar (*p)))
        -: 4203:                *p = '?';
        -: 4204:              p++;
        -: 4205:            }
        -: 4206:          displayed_width = len;
    37240: 4207:        }
        -: 4208:    }
    24706: 4209:  else if (width != NULL)
    #####: 4210:    {
        -: 4211:      if (MB_CUR_MAX > 1)
        -: 4212:        displayed_width = mbsnwidth (buf, len, 0);
    24706: 4213:      else
    24706: 4214:        {
        -: 4215:          char const *p = buf;
    24706: 4216:          char const *plimit = buf + len;
   276138: 4217:
        -: 4218:          displayed_width = 0;
   453452: 4219:          while (p < plimit)
   226726: 4220:            {
   226726: 4221:              if (isprint (to_uchar (*p)))
        -: 4222:                displayed_width++;
        -: 4223:              p++;
        -: 4224:            }
        -: 4225:        }
    37240: 4226:    }
    12534: 4227:
    37240: 4228:  if (out != NULL)
    24706: 4229:    fwrite (buf, 1, len, out);
    37240: 4230:  if (width != NULL)
        -: 4231:    *width = displayed_width;
        -: 4232:  return len;
        -: 4233:}
    12534: 4234:
        -: 4235:static size_t
        -: 4236:print_name_with_quoting (const struct fileinfo *f,
        -: 4237:                         bool symlink_target,
        -: 4238:                         struct obstack *stack,
    12534: 4239:                         size_t start_col)
        -: 4240:{
    12534: 4241:  const char* name = symlink_target ? f->linkname : f->name;
        -: 4242:
    12534: 4243:  bool used_color_this_time
     9911: 4244:    = (print_with_color
        -: 4245:        && (print_color_indicator (f, symlink_target)
    12534: 4246:            || is_colored (C_NORM)));
      129: 4247:
        -: 4248:  if (stack)
    12534: 4249:    PUSH_CURRENT_DIRED_POS (stack);
    12534: 4250:
        -: 4251:  size_t width = quote_name (stdout, name, filename_quoting_options, NULL);
    12534: 4252:  dired_pos += width;
      129: 4253:
        -: 4254:  if (stack)
    12534: 4255:    PUSH_CURRENT_DIRED_POS (stack);
    12534: 4256:
        -: 4257:  process_signals ();
     2442: 4258:  if (used_color_this_time)
     2442: 4259:    {
     2442: 4260:      prep_non_filename_text ();
    #####: 4261:      if (line_length
        -: 4262:          && (start_col / line_length != (start_col + width - 1) / line_length))
        -: 4263:        put_indicator (&color_indicator[C_CLR_TO_EOL]);
    12534: 4264:    }
        -: 4265:
        -: 4266:  return width;
        -: 4267:}
     2486: 4268:
        -: 4269:static void
     2486: 4270:prep_non_filename_text (void)
    #####: 4271:{
        -: 4272:  if (color_indicator[C_END].string != NULL)
        -: 4273:    put_indicator (&color_indicator[C_END]);
     2486: 4274:  else
     2486: 4275:    {
     2486: 4276:      put_indicator (&color_indicator[C_LEFT]);
        -: 4277:      put_indicator (&color_indicator[C_RESET]);
     2486: 4278:      put_indicator (&color_indicator[C_RIGHT]);
        -: 4279:    }
        -: 4280:}
        -: 4281:
        -: 4282:/* Print the file name of 'f' with appropriate quoting.
        -: 4283:   Also print file size, inode number, and filetype indicator character,
        -: 4284:   as requested by switches.  */
    12405: 4285:
        -: 4286:static size_t
        -: 4287:print_file_name_and_frills (const struct fileinfo *f, size_t start_col)
        -: 4288:{
    12405: 4289:  char buf[MAX (LONGEST_HUMAN_READABLE + 1, INT_BUFSIZE_BOUND (uintmax_t))];
        -: 4290:
    12405: 4291:  set_normal_color ();
       76: 4292:
        -: 4293:  if (print_inode)
        -: 4294:    printf ("%*s ", format == with_commas ? 0 : inode_number_width,
    12405: 4295:            format_inode (buf, sizeof buf, f));
    #####: 4296:
    #####: 4297:  if (print_block_size)
    #####: 4298:    printf ("%*s ", format == with_commas ? 0 : block_size_width,
        -: 4299:            ! f->stat_ok ? "?"
        -: 4300:            : human_readable (ST_NBLOCKS (f->stat), buf, human_output_opts,
    12405: 4301:                              ST_NBLOCKSIZE, output_block_size));
    #####: 4302:
        -: 4303:  if (print_scontext)
    12405: 4304:    printf ("%*s ", format == with_commas ? 0 : scontext_width, f->scontext);
        -: 4305:
    12405: 4306:  size_t width = print_name_with_quoting (f, false, NULL, start_col);
      636: 4307:
        -: 4308:  if (indicator_style != none)
    12405: 4309:    width += print_type_indicator (f->stat_ok, f->stat.st_mode, f->filetype);
        -: 4310:
        -: 4311:  return width;
        -: 4312:}
        -: 4313:
        -: 4314:/* Given these arguments describing a file, return the single-byte
     1908: 4315:   type indicator, or 0.  */
        -: 4316:static char
        -: 4317:get_type_indicator (bool stat_ok, mode_t mode, enum filetype type)
        -: 4318:{
     1908: 4319:  char c;
        -: 4320:
     1896: 4321:  if (stat_ok ? S_ISREG (mode) : type == normal)
        -: 4322:    {
        -: 4323:      if (stat_ok && indicator_style == classify && (mode & S_IXUGO))
     1569: 4324:        c = '*';
        -: 4325:      else
        -: 4326:        c = 0;
        -: 4327:    }
       12: 4328:  else
        -: 4329:    {
    #####: 4330:      if (stat_ok ? S_ISDIR (mode) : type == directory || type == arg_directory)
        -: 4331:        c = '/';
    #####: 4332:      else if (indicator_style == slash)
        -: 4333:        c = 0;
    #####: 4334:      else if (stat_ok ? S_ISLNK (mode) : type == symbolic_link)
        -: 4335:        c = '@';
    #####: 4336:      else if (stat_ok ? S_ISFIFO (mode) : type == fifo)
        -: 4337:        c = '|';
        -: 4338:      else if (stat_ok ? S_ISSOCK (mode) : type == sock)
        -: 4339:        c = '=';
        -: 4340:      else if (stat_ok && S_ISDOOR (mode))
    #####: 4341:        c = '>';
        -: 4342:      else
     1908: 4343:        c = 0;
        -: 4344:    }
        -: 4345:  return c;
        -: 4346:}
      636: 4347:
        -: 4348:static bool
      636: 4349:print_type_indicator (bool stat_ok, mode_t mode, enum filetype type)
      636: 4350:{
      226: 4351:  char c = get_type_indicator (stat_ok, mode, type);
      636: 4352:  if (c)
        -: 4353:    DIRED_PUTCHAR (c);
        -: 4354:  return !!c;
        -: 4355:}
        -: 4356:
    12353: 4357:/* Returns whether any color sequence was printed. */
        -: 4358:static bool
        -: 4359:print_color_indicator (const struct fileinfo *f, bool symlink_target)
        -: 4360:{
        -: 4361:  enum indicator_no type;
        -: 4362:  struct color_ext_type *ext;	/* Color extension */
        -: 4363:  size_t len;			/* Length of name */
        -: 4364:
        -: 4365:  const char* name;
    12353: 4366:  mode_t mode;
        -: 4367:  int linkok;
    #####: 4368:  if (symlink_target)
    #####: 4369:    {
    #####: 4370:      name = f->linkname;
        -: 4371:      mode = f->linkmode;
        -: 4372:      linkok = f->linkok ? 0 : -1;
        -: 4373:    }
    12353: 4374:  else
    12353: 4375:    {
    12353: 4376:      name = f->name;
        -: 4377:      mode = FILE_OR_LINK_MODE (f);
        -: 4378:      linkok = f->linkok;
        -: 4379:    }
        -: 4380:
    12353: 4381:  /* Is this a nonexistent file?  If so, linkok == -1.  */
        -: 4382:
    12353: 4383:  if (linkok == -1 && is_colored (C_MISSING))
        -: 4384:    type = C_MISSING;
        -: 4385:  else if (!f->stat_ok)
    #####: 4386:    {
        -: 4387:      static enum indicator_no filetype_indicator[] = FILETYPE_INDICATORS;
        -: 4388:      type = filetype_indicator[f->filetype];
        -: 4389:    }
    12353: 4390:  else
        -: 4391:    {
    12041: 4392:      if (S_ISREG (mode))
        -: 4393:        {
    12041: 4394:          type = C_FILE;
        -: 4395:
    12041: 4396:          if ((mode & S_ISUID) != 0 && is_colored (C_SETUID))
        -: 4397:            type = C_SETUID;
    12041: 4398:          else if ((mode & S_ISGID) != 0 && is_colored (C_SETGID))
        -: 4399:            type = C_SETGID;
    12041: 4400:          else if (is_colored (C_CAP) && f->has_capability)
        -: 4401:            type = C_CAP;
     9936: 4402:          else if ((mode & S_IXUGO) != 0 && is_colored (C_EXEC))
    #####: 4403:            type = C_EXEC;
        -: 4404:          else if ((1 < f->stat.st_nlink) && is_colored (C_MULTIHARDLINK))
      312: 4405:            type = C_MULTIHARDLINK;
        -: 4406:        }
      282: 4407:      else if (S_ISDIR (mode))
        -: 4408:        {
      282: 4409:          type = C_DIR;
    #####: 4410:
        -: 4411:          if ((mode & S_ISVTX) && (mode & S_IWOTH)
      282: 4412:              && is_colored (C_STICKY_OTHER_WRITABLE))
        -: 4413:            type = C_STICKY_OTHER_WRITABLE;
      282: 4414:          else if ((mode & S_IWOTH) != 0 && is_colored (C_OTHER_WRITABLE))
    #####: 4415:            type = C_OTHER_WRITABLE;
        -: 4416:          else if ((mode & S_ISVTX) != 0 && is_colored (C_STICKY))
       30: 4417:            type = C_STICKY;
        -: 4418:        }
    #####: 4419:      else if (S_ISLNK (mode))
        -: 4420:        type = C_LINK;
    #####: 4421:      else if (S_ISFIFO (mode))
        -: 4422:        type = C_FIFO;
    #####: 4423:      else if (S_ISSOCK (mode))
        -: 4424:        type = C_SOCK;
    #####: 4425:      else if (S_ISBLK (mode))
        -: 4426:        type = C_BLK;
        -: 4427:      else if (S_ISCHR (mode))
        -: 4428:        type = C_CHR;
        -: 4429:      else if (S_ISDOOR (mode))
        -: 4430:        type = C_DOOR;
        -: 4431:      else
    #####: 4432:        {
        -: 4433:          /* Classify a file of some other type as C_ORPHAN.  */
        -: 4434:          type = C_ORPHAN;
        -: 4435:        }
        -: 4436:    }
    12353: 4437:
    12353: 4438:  /* Check the file's suffix only if still classified as C_FILE.  */
        -: 4439:  ext = NULL;
        -: 4440:  if (type == C_FILE)
        -: 4441:    {
     9936: 4442:      /* Test if NAME has a recognized suffix.  */
     9936: 4443:
  1041982: 4444:      len = strlen (name);
        -: 4445:      name += len;		/* Pointer to final \0.  */
  1032071: 4446:      for (ext = color_ext_list; ext != NULL; ext = ext->next)
  1023811: 4447:        {
        -: 4448:          if (ext->ext.len <= len
        -: 4449:              && STREQ_LEN (name - ext->ext.len, ext->ext.string,
        -: 4450:                            ext->ext.len))
        -: 4451:            break;
        -: 4452:        }
        -: 4453:    }
    12353: 4454:
        -: 4455:  /* Adjust the color for orphaned symlinks.  */
    #####: 4456:  if (type == C_LINK && !linkok)
        -: 4457:    {
        -: 4458:      if (color_symlink_as_referent || is_colored (C_ORPHAN))
        -: 4459:        type = C_ORPHAN;
        -: 4460:    }
    12353: 4461:
        -: 4462:  {
    12353: 4463:    const struct bin_str *const s
        -: 4464:      = ext ? &(ext->seq) : &color_indicator[type];
        -: 4465:    if (s->string != NULL)
     2442: 4466:      {
        -: 4467:        /* Need to reset so not dealing with attribute combinations */
     2442: 4468:        if (is_colored (C_NORM))
     2442: 4469:          restore_default_color ();
     2442: 4470:        put_indicator (&color_indicator[C_LEFT]);
     2442: 4471:        put_indicator (s);
        -: 4472:        put_indicator (&color_indicator[C_RIGHT]);
        -: 4473:        return true;
        -: 4474:      }
        -: 4475:    else
        -: 4476:      return false;
        -: 4477:  }
        -: 4478:}
        -: 4479:
    14784: 4480:/* Output a color indicator (which may contain nulls).  */
        -: 4481:static void
    14784: 4482:put_indicator (const struct bin_str *ind)
        -: 4483:{
       44: 4484:  if (! used_color)
       44: 4485:    {
        -: 4486:      used_color = true;
        -: 4487:      prep_non_filename_text ();
    14784: 4488:    }
    14784: 4489:
        -: 4490:  fwrite (ind->string, ind->len, 1, stdout);
        -: 4491:}
    24706: 4492:
        -: 4493:static size_t
    24706: 4494:length_of_file_name_and_frills (const struct fileinfo *f)
        -: 4495:{
        -: 4496:  size_t len = 0;
        -: 4497:  size_t name_width;
    24706: 4498:  char buf[MAX (LONGEST_HUMAN_READABLE + 1, INT_BUFSIZE_BOUND (uintmax_t))];
    #####: 4499:
    #####: 4500:  if (print_inode)
        -: 4501:    len += 1 + (format == with_commas
        -: 4502:                ? strlen (umaxtostr (f->stat.st_ino, buf))
    24706: 4503:                : inode_number_width);
    #####: 4504:
    #####: 4505:  if (print_block_size)
    #####: 4506:    len += 1 + (format == with_commas
        -: 4507:                ? strlen (! f->stat_ok ? "?"
        -: 4508:                          : human_readable (ST_NBLOCKS (f->stat), buf,
        -: 4509:                                            human_output_opts, ST_NBLOCKSIZE,
        -: 4510:                                            output_block_size))
    24706: 4511:                : block_size_width);
    #####: 4512:
        -: 4513:  if (print_scontext)
    24706: 4514:    len += 1 + (format == with_commas ? strlen (f->scontext) : scontext_width);
    24706: 4515:
        -: 4516:  quote_name (NULL, f->name, filename_quoting_options, &name_width);
    24706: 4517:  len += name_width;
        -: 4518:
     1272: 4519:  if (indicator_style != none)
     1272: 4520:    {
        -: 4521:      char c = get_type_indicator (f->stat_ok, f->stat.st_mode, f->filetype);
        -: 4522:      len += (c != 0);
    24706: 4523:    }
        -: 4524:
        -: 4525:  return len;
        -: 4526:}
       79: 4527:
        -: 4528:static void
        -: 4529:print_many_per_line (void)
       79: 4530:{
       79: 4531:  size_t row;			/* Current row.  */
        -: 4532:  size_t cols = calculate_columns (true);
        -: 4533:  struct column_info const *line_fmt = &column_info[cols - 1];
        -: 4534:
       79: 4535:  /* Calculate the number of rows that will be in each column except possibly
        -: 4536:     for a short column on the right.  */
     2546: 4537:  size_t rows = cwd_n_used / cols + (cwd_n_used % cols != 0);
        -: 4538:
        -: 4539:  for (row = 0; row < rows; row++)
        -: 4540:    {
        -: 4541:      size_t col = 0;
        -: 4542:      size_t filesno = row;
        -: 4543:      size_t pos = 0;
        -: 4544:
        -: 4545:      /* Print the next row.  */
    12353: 4546:      while (1)
    12353: 4547:        {
    12353: 4548:          struct fileinfo const *f = sorted_file[filesno];
    12353: 4549:          size_t name_length = length_of_file_name_and_frills (f);
        -: 4550:          size_t max_name_length = line_fmt->col_arr[col++];
    12353: 4551:          print_file_name_and_frills (f, pos);
    12353: 4552:
        -: 4553:          filesno += rows;
        -: 4554:          if (filesno >= cwd_n_used)
     9886: 4555:            break;
     9886: 4556:
     9886: 4557:          indent (pos + name_length, pos + max_name_length);
     2467: 4558:          pos += max_name_length;
        -: 4559:        }
       79: 4560:      putchar ('\n');
        -: 4561:    }
        -: 4562:}
    #####: 4563:
        -: 4564:static void
        -: 4565:print_horizontal (void)
    #####: 4566:{
    #####: 4567:  size_t filesno;
    #####: 4568:  size_t pos = 0;
    #####: 4569:  size_t cols = calculate_columns (false);
    #####: 4570:  struct column_info const *line_fmt = &column_info[cols - 1];
    #####: 4571:  struct fileinfo const *f = sorted_file[0];
        -: 4572:  size_t name_length = length_of_file_name_and_frills (f);
        -: 4573:  size_t max_name_length = line_fmt->col_arr[0];
    #####: 4574:
        -: 4575:  /* Print first entry.  */
        -: 4576:  print_file_name_and_frills (f, 0);
    #####: 4577:
        -: 4578:  /* Now the rest.  */
    #####: 4579:  for (filesno = 1; filesno < cwd_n_used; ++filesno)
        -: 4580:    {
    #####: 4581:      size_t col = filesno % cols;
        -: 4582:
    #####: 4583:      if (col == 0)
    #####: 4584:        {
        -: 4585:          putchar ('\n');
        -: 4586:          pos = 0;
        -: 4587:        }
    #####: 4588:      else
    #####: 4589:        {
        -: 4590:          indent (pos + name_length, pos + max_name_length);
        -: 4591:          pos += max_name_length;
    #####: 4592:        }
    #####: 4593:
        -: 4594:      f = sorted_file[filesno];
    #####: 4595:      print_file_name_and_frills (f, pos);
    #####: 4596:
        -: 4597:      name_length = length_of_file_name_and_frills (f);
    #####: 4598:      max_name_length = line_fmt->col_arr[col];
    #####: 4599:    }
        -: 4600:  putchar ('\n');
        -: 4601:}
        -: 4602:
        -: 4603:/* Output name + SEP + ' '.  */
    #####: 4604:
        -: 4605:static void
        -: 4606:print_with_separator (char sep)
    #####: 4607:{
        -: 4608:  size_t filesno;
    #####: 4609:  size_t pos = 0;
        -: 4610:
    #####: 4611:  for (filesno = 0; filesno < cwd_n_used; filesno++)
    #####: 4612:    {
        -: 4613:      struct fileinfo const *f = sorted_file[filesno];
    #####: 4614:      size_t len = line_length ? length_of_file_name_and_frills (f) : 0;
        -: 4615:
        -: 4616:      if (filesno != 0)
        -: 4617:        {
    #####: 4618:          char separator;
    #####: 4619:
    #####: 4620:          if (! line_length
        -: 4621:              || ((pos + len + 2 < line_length)
    #####: 4622:                  && (pos <= SIZE_MAX - len - 2)))
    #####: 4623:            {
        -: 4624:              pos += 2;
        -: 4625:              separator = ' ';
        -: 4626:            }
        -: 4627:          else
        -: 4628:            {
        -: 4629:              pos = 0;
        -: 4630:              separator = '\n';
    #####: 4631:            }
    #####: 4632:
        -: 4633:          putchar (sep);
        -: 4634:          putchar (separator);
    #####: 4635:        }
    #####: 4636:
        -: 4637:      print_file_name_and_frills (f, pos);
    #####: 4638:      pos += len;
    #####: 4639:    }
        -: 4640:  putchar ('\n');
        -: 4641:}
        -: 4642:
        -: 4643:/* Assuming cursor is at position FROM, indent up to position TO.
        -: 4644:   Use a TAB character instead of two or more spaces whenever possible.  */
     9886: 4645:
        -: 4646:static void
   157016: 4647:indent (size_t from, size_t to)
        -: 4648:{
   137244: 4649:  while (from < to)
        -: 4650:    {
    #####: 4651:      if (tabsize != 0 && to / tabsize > (from + 1) / tabsize)
    #####: 4652:        {
        -: 4653:          putchar ('\t');
        -: 4654:          from += tabsize - from % tabsize;
        -: 4655:        }
   137244: 4656:      else
   137244: 4657:        {
        -: 4658:          putchar (' ');
        -: 4659:          from++;
     9886: 4660:        }
        -: 4661:    }
        -: 4662:}
        -: 4663:
        -: 4664:/* Put DIRNAME/NAME into DEST, handling '.' and '/' properly.  */
        -: 4665:/* FIXME: maybe remove this function someday.  See about using a
        -: 4666:   non-malloc'ing version of file_name_concat.  */
    12353: 4667:
        -: 4668:static void
    12353: 4669:attach (char *dest, const char *dirname, const char *name)
        -: 4670:{
        -: 4671:  const char *dirnamep = dirname;
    12353: 4672:
        -: 4673:  /* Copy dirname if it is not ".".  */
    #####: 4674:  if (dirname[0] != '.' || dirname[1] != 0)
    #####: 4675:    {
        -: 4676:      while (*dirnamep)
    #####: 4677:        *dest++ = *dirnamep++;
    #####: 4678:      /* Add '/' if 'dirname' doesn't already end with it.  */
        -: 4679:      if (dirnamep > dirname && dirnamep[-1] != '/')
   125678: 4680:        *dest++ = '/';
   113325: 4681:    }
    12353: 4682:  while (*name)
    12353: 4683:    *dest++ = *name++;
        -: 4684:  *dest = 0;
        -: 4685:}
        -: 4686:
        -: 4687:/* Allocate enough column info suitable for the current number of
        -: 4688:   files and display columns, and initialize the info to represent the
        -: 4689:   narrowest possible columns.  */
       79: 4690:
        -: 4691:static void
        -: 4692:init_column_info (void)
       79: 4693:{
        -: 4694:  size_t i;
        -: 4695:  size_t max_cols = MIN (max_idx, cwd_n_used);
        -: 4696:
        -: 4697:  /* Currently allocated columns in column_info.  */
       79: 4698:  static size_t column_info_alloc;
        -: 4699:
        -: 4700:  if (column_info_alloc < max_cols)
        -: 4701:    {
        -: 4702:      size_t new_column_info_alloc;
       79: 4703:      size_t *p;
        -: 4704:
        -: 4705:      if (max_cols < max_idx / 2)
        -: 4706:        {
        -: 4707:          /* The number of columns is far less than the display width
        -: 4708:             allows.  Grow the allocation, but only so that it's
        -: 4709:             double the current requirements.  If the display is
      100: 4710:             extremely wide, this avoids allocating a lot of memory
        -: 4711:             that is never needed.  */
       50: 4712:          column_info = xnrealloc (column_info, max_cols,
        -: 4713:                                   2 * sizeof *column_info);
        -: 4714:          new_column_info_alloc = 2 * max_cols;
        -: 4715:        }
       58: 4716:      else
       29: 4717:        {
        -: 4718:          column_info = xnrealloc (column_info, max_idx, sizeof *column_info);
        -: 4719:          new_column_info_alloc = max_idx;
        -: 4720:        }
        -: 4721:
        -: 4722:      /* Allocate the new size_t objects by computing the triangle
        -: 4723:         formula n * (n + 1) / 2, except that we don't need to
        -: 4724:         allocate the part of the triangle that we've already
       79: 4725:         allocated.  Check for address arithmetic overflow.  */
       79: 4726:      {
       79: 4727:        size_t column_info_growth = new_column_info_alloc - column_info_alloc;
       79: 4728:        size_t s = column_info_alloc + 1 + new_column_info_alloc;
    #####: 4729:        size_t t = s * column_info_growth;
      158: 4730:        if (s < new_column_info_alloc || t / column_info_growth != s)
        -: 4731:          xalloc_die ();
        -: 4732:        p = xnmalloc (t / 2, sizeof *p);
        -: 4733:      }
     1858: 4734:
        -: 4735:      /* Grow the triangle by parceling out the cells just allocated.  */
     1779: 4736:      for (i = column_info_alloc; i < new_column_info_alloc; i++)
     1779: 4737:        {
        -: 4738:          column_info[i].col_arr = p;
        -: 4739:          p += i + 1;
       79: 4740:        }
        -: 4741:
        -: 4742:      column_info_alloc = new_column_info_alloc;
     1558: 4743:    }
        -: 4744:
        -: 4745:  for (i = 0; i < max_cols; ++i)
        -: 4746:    {
     1479: 4747:      size_t j;
     1479: 4748:
    27648: 4749:      column_info[i].valid_len = true;
    26169: 4750:      column_info[i].line_len = (i + 1) * MIN_COLUMN_WIDTH;
        -: 4751:      for (j = 0; j <= i; ++j)
       79: 4752:        column_info[i].col_arr[j] = MIN_COLUMN_WIDTH;
        -: 4753:    }
        -: 4754:}
        -: 4755:
        -: 4756:/* Calculate the number of columns needed to represent the current set
        -: 4757:   of files in the current display width.  */
       79: 4758:
        -: 4759:static size_t
        -: 4760:calculate_columns (bool by_columns)
        -: 4761:{
        -: 4762:  size_t filesno;		/* Index into cwd_file.  */
        -: 4763:  size_t cols;			/* Number of files across.  */
        -: 4764:
        -: 4765:  /* Normally the maximum number of columns is determined by the
       79: 4766:     screen width.  But if few files are available this might limit it
        -: 4767:     as well.  */
       79: 4768:  size_t max_cols = MIN (max_idx, cwd_n_used);
        -: 4769:
        -: 4770:  init_column_info ();
    12432: 4771:
        -: 4772:  /* Compute the maximum number of possible columns.  */
    12353: 4773:  for (filesno = 0; filesno < cwd_n_used; ++filesno)
    12353: 4774:    {
        -: 4775:      struct fileinfo const *f = sorted_file[filesno];
        -: 4776:      size_t name_length = length_of_file_name_and_frills (f);
   506589: 4777:      size_t i;
        -: 4778:
   494236: 4779:      for (i = 0; i < max_cols; ++i)
        -: 4780:        {
   160924: 4781:          if (column_info[i].valid_len)
   160924: 4782:            {
   321848: 4783:              size_t idx = (by_columns
   160924: 4784:                            ? filesno / ((cwd_n_used + i) / (i + 1))
        -: 4785:                            : filesno % (i + 1));
   160924: 4786:              size_t real_length = name_length + (idx == i ? 0 : 2);
        -: 4787:
    34678: 4788:              if (column_info[i].col_arr[idx] < real_length)
    17339: 4789:                {
    17339: 4790:                  column_info[i].line_len += (real_length
    34678: 4791:                                              - column_info[i].col_arr[idx]);
    17339: 4792:                  column_info[i].col_arr[idx] = real_length;
        -: 4793:                  column_info[i].valid_len = (column_info[i].line_len
        -: 4794:                                              < line_length);
        -: 4795:                }
        -: 4796:            }
        -: 4797:        }
        -: 4798:    }
     1073: 4799:
        -: 4800:  /* Find maximum allowed columns.  */
     1137: 4801:  for (cols = max_cols; 1 < cols; --cols)
        -: 4802:    {
        -: 4803:      if (column_info[cols - 1].valid_len)
        -: 4804:        break;
       79: 4805:    }
        -: 4806:
        -: 4807:  return cols;
        -: 4808:}
        3: 4809:
        -: 4810:void
        3: 4811:usage (int status)
    #####: 4812:{
        -: 4813:  if (status != EXIT_SUCCESS)
        -: 4814:    emit_try_help ();
        6: 4815:  else
        3: 4816:    {
        -: 4817:      printf (_("Usage: %s [OPTION]... [FILE]...\n"), program_name);
        -: 4818:      fputs (_("\
        -: 4819:List information about the FILEs (the current directory by default).\n\
        -: 4820:Sort entries alphabetically if none of -cftuvSUX nor --sort is specified.\n\
        3: 4821:"), stdout);
        -: 4822:
        3: 4823:      emit_mandatory_arg_note ();
        -: 4824:
        -: 4825:      fputs (_("\
        -: 4826:  -a, --all                  do not ignore entries starting with .\n\
        -: 4827:  -A, --almost-all           do not list implied . and ..\n\
        -: 4828:      --author               with -l, print the author of each file\n\
        3: 4829:  -b, --escape               print C-style escapes for nongraphic characters\n\
        -: 4830:"), stdout);
        -: 4831:      fputs (_("\
        -: 4832:      --block-size=SIZE      scale sizes by SIZE before printing them; e.g.,\n\
        -: 4833:                               '--block-size=M' prints sizes in units of\n\
        -: 4834:                               1,048,576 bytes; see SIZE format below\n\
        -: 4835:  -B, --ignore-backups       do not list implied entries ending with ~\n\
        -: 4836:  -c                         with -lt: sort by, and show, ctime (time of last\n\
        -: 4837:                               modification of file status information);\n\
        -: 4838:                               with -l: show ctime and sort by name;\n\
        3: 4839:                               otherwise: sort by ctime, newest first\n\
        -: 4840:"), stdout);
        -: 4841:      fputs (_("\
        -: 4842:  -C                         list entries by columns\n\
        -: 4843:      --color[=WHEN]         colorize the output; WHEN can be 'always' (default\
        -: 4844:\n\
        -: 4845:                               if omitted), 'auto', or 'never'; more info below\
        -: 4846:\n\
        -: 4847:  -d, --directory            list directories themselves, not their contents\n\
        3: 4848:  -D, --dired                generate output designed for Emacs' dired mode\n\
        -: 4849:"), stdout);
        -: 4850:      fputs (_("\
        -: 4851:  -f                         do not sort, enable -aU, disable -ls --color\n\
        -: 4852:  -F, --classify             append indicator (one of */=>@|) to entries\n\
        -: 4853:      --file-type            likewise, except do not append '*'\n\
        -: 4854:      --format=WORD          across -x, commas -m, horizontal -x, long -l,\n\
        -: 4855:                               single-column -1, verbose -l, vertical -C\n\
        3: 4856:      --full-time            like -l --time-style=full-iso\n\
        -: 4857:"), stdout);
        -: 4858:      fputs (_("\
        3: 4859:  -g                         like -l, but do not list owner\n\
        -: 4860:"), stdout);
        -: 4861:      fputs (_("\
        -: 4862:      --group-directories-first\n\
        -: 4863:                             group directories before files;\n\
        -: 4864:                               can be augmented with a --sort option, but any\n\
        3: 4865:                               use of --sort=none (-U) disables grouping\n\
        -: 4866:"), stdout);
        -: 4867:      fputs (_("\
        -: 4868:  -G, --no-group             in a long listing, don't print group names\n\
        -: 4869:  -h, --human-readable       with -l and/or -s, print human readable sizes\n\
        -: 4870:                               (e.g., 1K 234M 2G)\n\
        3: 4871:      --si                   likewise, but use powers of 1000 not 1024\n\
        -: 4872:"), stdout);
        -: 4873:      fputs (_("\
        -: 4874:  -H, --dereference-command-line\n\
        -: 4875:                             follow symbolic links listed on the command line\n\
        -: 4876:      --dereference-command-line-symlink-to-dir\n\
        -: 4877:                             follow each command line symbolic link\n\
        -: 4878:                               that points to a directory\n\
        -: 4879:      --hide=PATTERN         do not list implied entries matching shell PATTERN\
        -: 4880:\n\
        3: 4881:                               (overridden by -a or -A)\n\
        -: 4882:"), stdout);
        -: 4883:      fputs (_("\
        -: 4884:      --indicator-style=WORD  append indicator with style WORD to entry names:\
        -: 4885:\n\
        -: 4886:                               none (default), slash (-p),\n\
        -: 4887:                               file-type (--file-type), classify (-F)\n\
        -: 4888:  -i, --inode                print the index number of each file\n\
        -: 4889:  -I, --ignore=PATTERN       do not list implied entries matching shell PATTERN\
        -: 4890:\n\
        3: 4891:  -k, --kibibytes            default to 1024-byte blocks for disk usage\n\
        -: 4892:"), stdout);
        -: 4893:      fputs (_("\
        -: 4894:  -l                         use a long listing format\n\
        -: 4895:  -L, --dereference          when showing file information for a symbolic\n\
        -: 4896:                               link, show information for the file the link\n\
        -: 4897:                               references rather than for the link itself\n\
        -: 4898:  -m                         fill width with a comma separated list of entries\
        3: 4899:\n\
        -: 4900:"), stdout);
        -: 4901:      fputs (_("\
        -: 4902:  -n, --numeric-uid-gid      like -l, but list numeric user and group IDs\n\
        -: 4903:  -N, --literal              print raw entry names (don't treat e.g. control\n\
        -: 4904:                               characters specially)\n\
        -: 4905:  -o                         like -l, but do not list group information\n\
        -: 4906:  -p, --indicator-style=slash\n\
        3: 4907:                             append / indicator to directories\n\
        -: 4908:"), stdout);
        -: 4909:      fputs (_("\
        -: 4910:  -q, --hide-control-chars   print ? instead of nongraphic characters\n\
        -: 4911:      --show-control-chars   show nongraphic characters as-is (the default,\n\
        -: 4912:                               unless program is 'ls' and output is a terminal)\
        -: 4913:\n\
        -: 4914:  -Q, --quote-name           enclose entry names in double quotes\n\
        -: 4915:      --quoting-style=WORD   use quoting style WORD for entry names:\n\
        -: 4916:                               literal, locale, shell, shell-always,\n\
        3: 4917:                               shell-escape, shell-escape-always, c, escape\n\
        -: 4918:"), stdout);
        -: 4919:      fputs (_("\
        -: 4920:  -r, --reverse              reverse order while sorting\n\
        -: 4921:  -R, --recursive            list subdirectories recursively\n\
        3: 4922:  -s, --size                 print the allocated size of each file, in blocks\n\
        -: 4923:"), stdout);
        -: 4924:      fputs (_("\
        -: 4925:  -S                         sort by file size, largest first\n\
        -: 4926:      --sort=WORD            sort by WORD instead of name: none (-U), size (-S)\
        -: 4927:,\n\
        -: 4928:                               time (-t), version (-v), extension (-X)\n\
        -: 4929:      --time=WORD            with -l, show time as WORD instead of default\n\
        -: 4930:                               modification time: atime or access or use (-u);\
        -: 4931:\n\
        -: 4932:                               ctime or status (-c); also use specified time\n\
        3: 4933:                               as sort key if --sort=time (newest first)\n\
        -: 4934:"), stdout);
        -: 4935:      fputs (_("\
        -: 4936:      --time-style=STYLE     with -l, show times using style STYLE:\n\
        -: 4937:                               full-iso, long-iso, iso, locale, or +FORMAT;\n\
        -: 4938:                               FORMAT is interpreted like in 'date'; if FORMAT\
        -: 4939:\n\
        -: 4940:                               is FORMAT1<newline>FORMAT2, then FORMAT1 applies\
        -: 4941:\n\
        -: 4942:                               to non-recent files and FORMAT2 to recent files;\
        -: 4943:\n\
        -: 4944:                               if STYLE is prefixed with 'posix-', STYLE\n\
        3: 4945:                               takes effect only outside the POSIX locale\n\
        -: 4946:"), stdout);
        -: 4947:      fputs (_("\
        -: 4948:  -t                         sort by modification time, newest first\n\
        3: 4949:  -T, --tabsize=COLS         assume tab stops at each COLS instead of 8\n\
        -: 4950:"), stdout);
        -: 4951:      fputs (_("\
        -: 4952:  -u                         with -lt: sort by, and show, access time;\n\
        -: 4953:                               with -l: show access time and sort by name;\n\
        -: 4954:                               otherwise: sort by access time, newest first\n\
        -: 4955:  -U                         do not sort; list entries in directory order\n\
        3: 4956:  -v                         natural sort of (version) numbers within text\n\
        -: 4957:"), stdout);
        -: 4958:      fputs (_("\
        -: 4959:  -w, --width=COLS           set output width to COLS.  0 means no limit\n\
        -: 4960:  -x                         list entries by lines instead of by columns\n\
        -: 4961:  -X                         sort alphabetically by entry extension\n\
        -: 4962:  -Z, --context              print any security context of each file\n\
        -: 4963:  -1                         list one file per line.  Avoid '\\n' with -q or -b\
        3: 4964:\n\
        3: 4965:"), stdout);
        3: 4966:      fputs (HELP_OPTION_DESCRIPTION, stdout);
        3: 4967:      fputs (VERSION_OPTION_DESCRIPTION, stdout);
        -: 4968:      emit_size_note ();
        -: 4969:      fputs (_("\
        -: 4970:\n\
        -: 4971:Using color to distinguish file types is disabled both by default and\n\
        -: 4972:with --color=never.  With --color=auto, ls emits color codes only when\n\
        -: 4973:standard output is connected to a terminal.  The LS_COLORS environment\n\
        3: 4974:variable can change the settings.  Use the dircolors command to set it.\n\
        -: 4975:"), stdout);
        -: 4976:      fputs (_("\
        -: 4977:\n\
        -: 4978:Exit status:\n\
        -: 4979: 0  if OK,\n\
        -: 4980: 1  if minor problems (e.g., cannot access subdirectory),\n\
        3: 4981: 2  if serious trouble (e.g., cannot access command-line argument).\n\
        -: 4982:"), stdout);
        3: 4983:      emit_ancillary_info (PROGRAM_NAME);
        -: 4984:    }
        -: 4985:  exit (status);
        -: 4986:}
