## Fuzzing competition on ffmpeg 4.2
----
Christer Winge (cwing@kth.se)

###Background,research and preparation
This part of the course was very interesting to me from the start, as I do have quite the interest with most things around security. I was not very familiar with the term fuzzing either, except seeing some mentions here and there about white and black-box fuzzing, but not what it actually entails.

Quite quickly after beginning to research the topic, you start stumbling over different tools that are available to help with fuzzing applications. As I am sure you are aware, it is quite easy to get locked in on [AFL](https://lcamtuf.coredump.cx/afl/). Which indeed is what I did. I started going over the documentation and checking some source code, and did some trial runs to see if I could even get it working,which I did, but not in a very helpful way for the actual assignment. I was at this point and quite a while later too focused on trying out tools I stumbled upon as well as trying to figure out how to use them to their best ability for something as complex and big as ffmpeg.

I happened to find an AFL-fork called [AFLplusplus](https://github.com/AFLplusplus/AFLplusplus), which is a lot more active and has a bunch of additions, fixes and speedups compared to the mostly inactive original. After some hiccups I eventually got it running, and it did perform substantially better compared to the regular AFL with the same commands, just that the fork has LLVM support which is supposed to make it a lot faster. 

It was at this point that I however finally took a better look at what was actually required for the input.txt that should be turned in. Can the output from AFL actually be used for it? Then I would need to somehow get the commands taken for the advantageous paths, which I never managed to get working. I attempted to go through the source code so that I could add my own logging into a file with preciously the information that I would need. It was a bit too ambitions, the source code is not very easy to read, making it harder. I ended up going back to AFL to try out the experimental argv fuzzing in AFL, but never got it working at a decent enough performance. 

I also stumbled upon another promising tool, but never had the time to test it, called [AFLsmart](https://github.com/aflsmart/aflsmart), which obviously is another fork of AFL but that is quite heavily modified in some areas.

### What to do... what to do?
As the actual assignment was about code coverage and not actually fuzzing to find bugs, I had to figure out how to proceed. Fuzzing with AFL seemed like a good choice still, if I could manage to get argv-fuzzing to work as desired, but even after working with that for ages there was other problems arising. This kind of fuzzing might have been fine for a much much smaller program with a lot simpler syntax and fewer options available. But for something as big as ffmpeg it seemed pretty damn hard to even get it working as desired. 

Getting some small valid input files was not a problem, but getting some actually valid and good combinations of ideally almost all available options for ffmpeg seemed increasingly impossible. Especially to get it done automatically, in some way. I explored and tried to use directories, with options gathered and hopefully get AFL to use it in a desired way. This did not go well at all, which is quite understandable since I figured it wouldn't be very complex in that regard. Another problem is how the order of commands has to be for ffmpeg. The output has to be at the end, AFL doesn't provide a way to make sure something is at the end if you want to use mutations or dictionaries to slump some input together. Ideally I would have wanted to be able to choose several files as inputs, at different places in a determined way, to be able to ensure the syntax almost always will be valid and produce an outcome. I didn't manage to find anything that let me do just that, which would require me to write it myself, but as time was a huge factor at this point, it was simply not possible.

### Final solution
The final solution that I had to unfortunately resort to, was to rather quickly take the dictionary I had created for AFL together with some more options added, to create the final inputs through some manual work and a bunch of scripts written in python to create a bunch of valid inputs and some combinations where I would think it would require some different functions to resolve things. I ended up with just under 1GB, but after some more thought put into it, decided to make a lot fewer combinations as in most cases it will be a very marginal increase in coverage overall. It feels like a big letdown to resort to this as a solution.

### What to take home?
Making sure what is needed to be the end result is obviously a big part. But from the whole experience, there a lot more tools for fuzzing than what might be expected, but the resources online that covers them are quite limited as a whole. The tools do a lot of great things, but far from everything they can do is necessary for such a task as this one, at least if the focus is only on code coverage. Finding a tool and sticking to it, if it works, would have been a lot better. A ton of time can be wasted on installations and recompilation of the binary(which in this case was far from problem free).

It will be interesting to see what the others results will be, I'm sure mine will be quite terrible, but even looking at the percentage covered by ffmpeg's own [FATE-suite](http://coverage.ffmpeg.org/), their code coverage is *only* around 55%. I didn't feel like it would be right to look into that project while doing this challenge, I'm sure some parts would have helped. Going through their test cases, it sure has required a ton of manual work for them with the code and the specially crafted files for all of them. One very handy thing with creating input files for ffmpeg is that if you find a really small crafted file of some format, it can easily be converted using ffmpeg, so that the converted files can be used for more test cases albeit slightly larger.