<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="Simon Larsén - slarse@kth.se" />
  <meta name="author" content="DD2482 DevOps and Automated Testing" />
  <meta name="dcterms.date" content="2019-04-27" />
  <title>An Introduction to Graph Databases</title>
  <style>
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <style>
a.sourceLine { display: inline-block; line-height: 1.25; }
a.sourceLine { pointer-events: none; color: inherit; text-decoration: inherit; }
a.sourceLine:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
a.sourceLine { text-indent: -1em; padding-left: 1em; }
}
pre.numberSource a.sourceLine
  { position: relative; left: -4em; }
pre.numberSource a.sourceLine::before
  { content: attr(title);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; pointer-events: all; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {  }
@media screen {
a.sourceLine::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <link rel="stylesheet" href="pandoc.css" />
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
  
  
  
  
  
</head>
<body>
<header id="title-block-header">
<h1 class="title">An Introduction to Graph Databases</h1>
<p class="author">Simon Larsén - slarse@kth.se</p>
<p class="author">DD2482 DevOps and Automated Testing</p>
<p class="date">2019-04-27</p>
</header>
<nav id="TOC" role="doc-toc">
<ul>
<li><a href="#introduction"><span class="toc-section-number">1</span> Introduction</a></li>
<li><a href="#background"><span class="toc-section-number">2</span> Background</a><ul>
<li><a href="#sec:rdf"><span class="toc-section-number">2.1</span> Resource Description Framework (RDF) databases</a></li>
<li><a href="#sec:pg"><span class="toc-section-number">2.2</span> Property graph databases</a></li>
<li><a href="#sec:performance"><span class="toc-section-number">2.3</span> A note on performance</a></li>
</ul></li>
<li><a href="#sec:usage"><span class="toc-section-number">3</span> Usage examples: SQL versus PG</a><ul>
<li><a href="#sec:sql-def"><span class="toc-section-number">3.1</span> SQL database definition</a></li>
<li><a href="#sec:neo4j-def"><span class="toc-section-number">3.2</span> Property graph database definition</a></li>
<li><a href="#sec:queries"><span class="toc-section-number">3.3</span> Querying the databases</a><ul>
<li><a href="#sec:query1"><span class="toc-section-number">3.3.1</span> Query #1: Find all actors and the roles they have played</a></li>
<li><a href="#sec:query2"><span class="toc-section-number">3.3.2</span> Query #2: Find all self-directed actors</a></li>
<li><a href="#sec:query3"><span class="toc-section-number">3.3.3</span> Query #3: Rumors about Ben</a></li>
</ul></li>
</ul></li>
<li><a href="#sec:discussion"><span class="toc-section-number">4</span> Discussion</a></li>
<li><a href="#references"><span class="toc-section-number">5</span> References</a></li>
<li><a href="#appendix"><span class="toc-section-number">6</span> Appendix</a><ul>
<li><a href="#sec:appendix-a"><span class="toc-section-number">6.1</span> Appendix A</a></li>
<li><a href="#sec:appendix-b"><span class="toc-section-number">6.2</span> Appendix B</a></li>
<li><a href="#sec:appendix-c"><span class="toc-section-number">6.3</span> Appendix C</a></li>
</ul></li>
</ul>
</nav>



<h1 id="introduction"><span class="header-section-number">1</span> Introduction</h1>
<p>For decades, the word database has been more or less synonymous with relational database, which in turn is more or less synonymous with SQL database. There is no denying that SQL database systems are both performant and reliable, and have served many purposes very well. However, using a single technology to tackle all storage-related problems fundamentally contradicts a simple intuition about software engineering: there is no one size fits all solution. This article presents an introduction to graph databases, which is a different take on data storage that does not build on the relational model. Readers are expected to at least have a cursory understanding of SQL and the relational model, as these will be used for comparison without being explained in detail. The meat of the article is a theoretical presentation of two common graph database models, as well as a by-example usage comparison of the Neo4j graph database system with the PostgreSQL relational database system. After having read this article, a reader with some previous experience of using SQL databases should walk away away with some rudimentary knowledge of when it may be appropriate to use a graph database instead, and how to get started doing so.</p>
<h1 id="background"><span class="header-section-number">2</span> Background</h1>
<p>Most real world applications need persistent data storage, and for a long time, the relational database model has been the go-to for most such data stores <span class="citation" data-cites="vicknair2010comparison">[<a href="#ref-vicknair2010comparison" role="doc-biblioref">1</a>]</span>. The 1970s saw the inception of the <em>Standard Query Language</em> (SQL), as well as seminal work on performance optimizations that paved the way for relational databases in the world outside of academia <span class="citation" data-cites="selinger1979access">[<a href="#ref-selinger1979access" role="doc-biblioref">2</a>]</span>. Adoption rose sharply in the 1980s and SQL-based databases has since been the de-facto standard. In the past few years, there has been an increase in interest for non-relational database systems, collectively known as NoSQL <span class="citation" data-cites="vicknair2010comparison">[<a href="#ref-vicknair2010comparison" role="doc-biblioref">1</a>]</span>. It is important to note that NoSQL is not <em>one</em> technology, but rather denotes a collection of storage technologies that are not based on the relational database model. Graph databases form a subset of the NoSQL technologies <span class="citation" data-cites="buerli2012current">[<a href="#ref-buerli2012current" role="doc-biblioref">3</a>]</span>. The concept of graph databases has been around since the 1980s, but was more or less forgotten about in the mid 1990s due to the emergence of other new technologies, such as XML. It is not until recently that graph databases have seen a resurgence in popularity. Much due to this fact, the field is still in flux, and there are many different types of graph database models around. Angles et al. provides a fairly comprehensive but slightly dated overview of several different models and their origins <span class="citation" data-cites="angles2008survey">[<a href="#ref-angles2008survey" role="doc-biblioref">4</a>]</span>. As there is such a large amount of different graph database models, this article will not cover all of them. Rather, I will introduce the <em>property graph</em> database, and show by practical example how using such a database compares to the use of a traditional SQL database. I will also present the concepts of a different kind of graph database based on the RDF standards, as such databases frequently appeared during background research of the subject <span class="citation" data-cites="hartig2014reconciliation angles2018g">[<a href="#ref-hartig2014reconciliation" role="doc-biblioref">5</a>], [<a href="#ref-angles2018g" role="doc-biblioref">6</a>]</span>. The point of including some theory on RDF graph databases is mostly to show that just as NoSQL is not one technology, graph databases is not one technology. The focus of the rest of the article is on property graphs. Note also that in this article, the term graph database is used interchangeably with property graph database, and any other type of graph database is referred to by a different name. The rest of the article is structured as follows. Section 2.1 presents the concepts behind RDF databases, while Sec. 2.2 does the same for property graph databases. Section 2.3 makes a brief detour into the complicated area of performance measurements. Section 3 compares creation and subsequent querying of a movie database using the relational PostgreSQL system, and the property graph Neo4j system. Finally, Section 4 presents a discussion of the potential pros and cons of using a graph database over a relational database.</p>
<h2 id="sec:rdf"><span class="header-section-number">2.1</span> Resource Description Framework (RDF) databases</h2>
<p>The <em>Resource Description Framework</em> (RDF) is a set of specifications for expressing metadata for websites, and is a key part of the WWW Consortium’s (W3C) effort to standardize a Semantic Web that a machine can not only navigate, but also understand <span class="citation" data-cites="rdf semanticweb">[<a href="#ref-rdf" role="doc-biblioref">7</a>], [<a href="#ref-semanticweb" role="doc-biblioref">8</a>]</span>. Lately, it has also seen use as general purpose data storage in several products, including AllegroGraph<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a> and GraphDB<a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a>. An RDF graph is a set of triples of <em>subject</em>, <em>predicate</em> and <em>object</em>. The subject is that which we want to say something about, the predicate is what kind of statement we are making, and the object the value of that statement. For example, the triples in Table 1 is an RDF-like encoding of the data “The Town is a movie”, “Ben is a person”, “Ben acted in The Town”, and “The Town was directed by Ben”.</p>
<div id="tbl:rdf-example">
<table>
<caption>Table 1: RDF triples example.</caption>
<thead>
<tr class="header">
<th>Subject</th>
<th>Predicate</th>
<th>Object</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>The Town</td>
<td>type</td>
<td>Movie</td>
</tr>
<tr class="even">
<td>Ben</td>
<td>type</td>
<td>Person</td>
</tr>
<tr class="odd">
<td>Ben</td>
<td>actedIn</td>
<td>The Town</td>
</tr>
<tr class="even">
<td>The Town</td>
<td>directedBy</td>
<td>Ben</td>
</tr>
</tbody>
</table>
</div>
<p>There is an interesting observation to be made regarding the triples presented in Table 1: it is not immediately apparent that they constitute a graph. In fact, it is possible to have for example the object of one triple be the predicate of another, so the triples do not by themselves represent a graph in the traditional sense <span class="citation" data-cites="hayes2004bipartite">[<a href="#ref-hayes2004bipartite" role="doc-biblioref">9</a>]</span>. In the case of Table 1 however, viewing the set union of subjects and objects as nodes, and the set of predicates as labeled edges, it is clear that the triples of Table 1 induce the graph in Fig. 1.</p>
<figure>
<img src="images/rdf-example.png" alt="Figure 1: Visualisation of Table 1" id="fig:rdf-example" style="width:60.0%" /><figcaption>Figure 1: Visualisation of Table 1</figcaption>
</figure>
<p>Another interesting observation is that Table 1 looks similar to a traditional relational database table, and indeed, there are ways to implement RDF stores on top of a relational database system <span class="citation" data-cites="bornea2013building">[<a href="#ref-bornea2013building" role="doc-biblioref">10</a>]</span>.</p>
<h2 id="sec:pg"><span class="header-section-number">2.2</span> Property graph databases</h2>
<p>Unlike RDF graphs, property graphs (PG) are not formally defined <span class="citation" data-cites="hartig2014reconciliation">[<a href="#ref-hartig2014reconciliation" role="doc-biblioref">5</a>]</span>. The term also seems to be fairly new; the earliest mention that I can find is from 2010 <span class="citation" data-cites="rodriguez2010constructions">[<a href="#ref-rodriguez2010constructions" role="doc-biblioref">11</a>]</span>, while another contemporary author does not use the term to describe the same concept <span class="citation" data-cites="srinivasa2012data">[<a href="#ref-srinivasa2012data" role="doc-biblioref">12</a>]</span>. There is however a general agreement about what a property graph is: a directed graph in which nodes and edges are distinct, labeled entities that can contain properties in the form of key-value pairs. Note that the edges of a PG are often referred to as <em>relationships</em>, but I will refer to them as edges. Slightly adding to the confusion is that the term property graph is often used interchangeably with <em>labeled property graph</em> (LPG) <span class="citation" data-cites="barrasa2017rdfvslpg hartig2014reconciliation wiki2018graphdatabases">[<a href="#ref-hartig2014reconciliation" role="doc-biblioref">5</a>], [<a href="#ref-barrasa2017rdfvslpg" role="doc-biblioref">13</a>], [<a href="#ref-wiki2018graphdatabases" role="doc-biblioref">14</a>]</span>. The L in LPG simply emphasizes the fact that nodes and edges are labeled, which is sensible considering the important role that labels play in a PG model. Labels are used to categorize nodes and edges, and are roughly equivalent to type assignments <span class="citation" data-cites="srinivasa2012data">[<a href="#ref-srinivasa2012data" role="doc-biblioref">12</a>]</span>. For example, a node representing a person could have the label “Person”, which makes it easy to query for Person node. Figure 2 shows a property graph example of the same data that was presented in Fig. 1.</p>
<figure>
<img src="images/pg.png" alt="Figure 2: Visualisation of a property graph. Labels are in bold and properties are written key: value" id="fig:pg" style="width:60.0%" /><figcaption>Figure 2: Visualisation of a property graph. Labels are in bold and properties are written <code>key: value</code></figcaption>
</figure>
<p>Another important difference between RDF graphs and property graphs is that the latter has no standardized query language, although it should be noted that efforts are underway to standardize a <em>Graph Query Language</em> (GQL) <span class="citation" data-cites="gqlstandard gqlmanifesto w3c2019workshop angles2018g">[<a href="#ref-angles2018g" role="doc-biblioref">6</a>], [<a href="#ref-gqlstandard" role="doc-biblioref">15</a>]–[<a href="#ref-w3c2019workshop" role="doc-biblioref">17</a>]</span>. Examples of current PG databases are Neo4j<a href="#fn3" class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a>, which uses the Cypher query language<a href="#fn4" class="footnote-ref" id="fnref4" role="doc-noteref"><sup>4</sup></a> (open-sourced as openCypher<a href="#fn5" class="footnote-ref" id="fnref5" role="doc-noteref"><sup>5</sup></a>), and JanusGraph<a href="#fn6" class="footnote-ref" id="fnref6" role="doc-noteref"><sup>6</sup></a>, which uses the Gremlin query language<a href="#fn7" class="footnote-ref" id="fnref7" role="doc-noteref"><sup>7</sup></a>.</p>
<h2 id="sec:performance"><span class="header-section-number">2.3</span> A note on performance</h2>
<p>A topic which this article has conveniently avoided thus far is that of performance. The reason is simple: one could write an entire article series only on that, as performance comparisons are very difficult to perform between systems that are designed in fundamentally different ways. There is however research on the topic, both comparing graph databases to other graph databases <span class="citation" data-cites="mccoll2014performance jouili2013empirical ciglan2012benchmarking">[<a href="#ref-mccoll2014performance" role="doc-biblioref">18</a>]–[<a href="#ref-ciglan2012benchmarking" role="doc-biblioref">20</a>]</span>, and comparing relational databases to graph databases <span class="citation" data-cites="vicknair2010comparison">[<a href="#ref-vicknair2010comparison" role="doc-biblioref">1</a>]</span>. The only result that I find relevant to mention for this article is that a graph database system such as Neo4j can perform on par with, or even outperform, a relational SQL database system in some cases, but also falls well behind in others <span class="citation" data-cites="vicknair2010comparison">[<a href="#ref-vicknair2010comparison" role="doc-biblioref">1</a>]</span>. This means that a graph database can be a viable alternative to a relational database even for performance critical applications, but it may not always be the right choice.</p>
<h1 id="sec:usage"><span class="header-section-number">3</span> Usage examples: SQL versus PG</h1>
<p>In this section, I present a simple movie dataset modelled with a property graph database (Neo4j) and a standard relational database (PostgreSQL). The dataset consists of the following:</p>
<ul>
<li>People</li>
<li>Movies</li>
<li>Which movies any given person has acted in
<ul>
<li>And which role he or she performed as</li>
</ul></li>
<li>Which movies any given person has directed</li>
</ul>
<p>Modeling this data represents a few common tasks database systems have to fulfill, namely representing concrete entities (here, movies and people) and their attributes (names and titles), as well as relationships between such entities (“person acted in movie” and “movie was directed by person”). The rest of this section is structured as follows. Section 3.1 presents how to define and populate a database with SQL, and Sec. 3.2 does the same for a property graph database. Section 3.3 then presents a series of queries on the databases.</p>
<h2 id="sec:sql-def"><span class="header-section-number">3.1</span> SQL database definition</h2>
<p>This is the part of the article that assumes some prior knowledge of relational databases, as concepts such as tables and foreign keys will not be explained. To model the data mentioned in Sec. 3, a typical SQL database will need four tables: two tables to represent the base entities <code>Person</code> and <code>Movie</code>, as well as two association tables to model the <code>ActedIn</code> and <code>DirectedBy</code> relationships between these. The reason that the two association tables are required is that both <code>ActedIn</code> and <code>DirectedBy</code> are many-to-many relationships, which cannot be expressed in a relational database with only the concrete entity tables. For example, an actor typically has acted in more than one movie, and most movies are acted in by more than one actor. Listing 1 shows an example of how the <code>Person</code> table could be defined, with the <code>Movie</code> table being almost identical. The <code>ActedIn</code> table could then be defined as shown in Listing 2, with the <code>DirectedBy</code> table being almost identical to that.</p>
<div id="lst:create-person-table" class="listing sql">
<p>Listing 1: DDL for the Person table</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode sql"><code class="sourceCode sql"><a class="sourceLine" id="cb1-1" title="1"><span class="kw">CREATE</span> <span class="kw">TABLE</span> Person (</a>
<a class="sourceLine" id="cb1-2" title="2">    <span class="kw">id</span> <span class="dt">INT</span> UNSIGNED <span class="kw">PRIMARY</span> <span class="kw">KEY</span> AUTO_INCREMENT,</a>
<a class="sourceLine" id="cb1-3" title="3">    name <span class="dt">VARCHAR</span>(<span class="dv">128</span>) <span class="kw">NOT</span> <span class="kw">NULL</span></a>
<a class="sourceLine" id="cb1-4" title="4">);</a></code></pre></div>
</div>
<div id="lst:create-actedin-table" class="listing sql">
<p>Listing 2: DDL for the ActedIn association table</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode sql"><code class="sourceCode sql"><a class="sourceLine" id="cb2-1" title="1"><span class="kw">CREATE</span> <span class="kw">TABLE</span> ActedIn (</a>
<a class="sourceLine" id="cb2-2" title="2">    <span class="kw">id</span> SERIAL <span class="kw">PRIMARY</span> <span class="kw">KEY</span>,</a>
<a class="sourceLine" id="cb2-3" title="3">    person_id <span class="dt">INT</span> <span class="kw">NOT</span> <span class="kw">NULL</span> <span class="kw">REFERENCES</span> Person(<span class="kw">id</span>),</a>
<a class="sourceLine" id="cb2-4" title="4">    movie_id <span class="dt">INT</span> <span class="kw">NOT</span> <span class="kw">NULL</span> <span class="kw">REFERENCES</span> Movie(<span class="kw">id</span>),</a>
<a class="sourceLine" id="cb2-5" title="5">    played_role <span class="dt">VARCHAR</span>(<span class="dv">128</span>) <span class="kw">NOT</span> <span class="kw">NULL</span></a>
<a class="sourceLine" id="cb2-6" title="6">);</a></code></pre></div>
</div>
<p>The whole database schema is presented schematically in Fig. 3. Note the multiplicities on the relations between the tables. For example, each <code>ActedIn</code> row is associated with precisely one <code>Person</code> row, while each <code>Person</code> row is associated with zero (because not every person is an actor) or more <code>ActedIn</code> rows.</p>
<figure>
<img src="images/sql-schema.png" alt="Figure 3: SQL schema for the movie database" id="fig:sql-schema" style="width:90.0%" /><figcaption>Figure 3: SQL schema for the movie database</figcaption>
</figure>
<p>With the schema defined, the database can be filled with data using queries like those shown in Listing 3. Note how the insertions into the association tables have nested SELECT queries to find the correct primary keys of the related tables. This is a bit cumbersome, but I know of no other standard way to achieve it. The full definition of the database, including data insertions, can be found in Sec. 6.1. It has been tested to work with PostgreSQL 9.6.</p>
<div id="lst:insert-sql" class="listing sql">
<p>Listing 3: Sample of value insertions into the SQL database</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode sql"><code class="sourceCode sql"><a class="sourceLine" id="cb3-1" title="1"><span class="kw">INSERT</span> <span class="kw">INTO</span> Movie(title) <span class="kw">VALUES</span></a>
<a class="sourceLine" id="cb3-2" title="2">    (<span class="st">&#39;The Town&#39;</span>);</a>
<a class="sourceLine" id="cb3-3" title="3"><span class="kw">INSERT</span> <span class="kw">INTO</span> Person(name) <span class="kw">VALUES</span></a>
<a class="sourceLine" id="cb3-4" title="4">   (<span class="st">&#39;Ben Affleck&#39;</span>);</a>
<a class="sourceLine" id="cb3-5" title="5"><span class="kw">INSERT</span> <span class="kw">INTO</span> ActedIn(person_id, movie_id, played_role) <span class="kw">VALUES</span></a>
<a class="sourceLine" id="cb3-6" title="6">    ((<span class="kw">SELECT</span> <span class="kw">id</span> <span class="kw">FROM</span> Person <span class="kw">WHERE</span> name<span class="op">=</span><span class="st">&#39;Ben Affleck&#39;</span>),</a>
<a class="sourceLine" id="cb3-7" title="7">     (<span class="kw">SELECT</span> <span class="kw">id</span> <span class="kw">FROM</span> Movie <span class="kw">WHERE</span> title<span class="op">=</span><span class="st">&#39;The Town&#39;</span>),</a>
<a class="sourceLine" id="cb3-8" title="8">     <span class="st">&#39;Doug MacRay&#39;</span>);</a>
<a class="sourceLine" id="cb3-9" title="9"><span class="kw">INSERT</span> <span class="kw">INTO</span> DirectedBy(person_id, movie_id) <span class="kw">VALUES</span></a>
<a class="sourceLine" id="cb3-10" title="10">    ((<span class="kw">SELECT</span> <span class="kw">id</span> <span class="kw">FROM</span> Person <span class="kw">WHERE</span> name<span class="op">=</span><span class="st">&#39;Ben Affleck&#39;</span>),</a>
<a class="sourceLine" id="cb3-11" title="11">     (<span class="kw">SELECT</span> <span class="kw">id</span> <span class="kw">FROM</span> Movie <span class="kw">WHERE</span> title<span class="op">=</span><span class="st">&#39;The Town&#39;</span>));</a></code></pre></div>
</div>
<h2 id="sec:neo4j-def"><span class="header-section-number">3.2</span> Property graph database definition</h2>
<p>For the property graph database, I use Neo4j and its query language Cypher. The reason is mostly that it is easy to get started with Neo4j, and Cypher is easy to briefly explain. Do however keep in mind that there is no one query language for property graphs, as described in Sec. 2.2, so this section is not representative of property graphs as a whole. I do however think that it illustrates the idea of graph-based queries well. As Neo4j is a schemaless database system, there is no need to first define the database, as was the case for the SQL database in Sec. 3.1. It is simply a matter of entering values into the database. Cypher is concise, so entering the same data about Ben Affleck that was entered in Sec. 3.1 is a matter of the four lines shown in Listing 4.</p>
<div id="lst:create-neo4j-values" class="listing sql">
<p>Listing 4: Sample CREATE statement for the Neo4j database</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode sql"><code class="sourceCode sql"><a class="sourceLine" id="cb4-1" title="1"><span class="kw">CREATE</span> (thetown<span class="ch">:Movie</span> {title: <span class="ot">&quot;The Town&quot;</span>})</a>
<a class="sourceLine" id="cb4-2" title="2"><span class="kw">CREATE</span> (ben<span class="ch">:Person</span> {name: <span class="ot">&quot;Ben Affleck&quot;</span>})</a>
<a class="sourceLine" id="cb4-3" title="3"><span class="kw">CREATE</span> (ben)<span class="op">-</span>[<span class="ch">:ACTED_IN</span> {<span class="kw">role</span>: <span class="ot">&quot;Doug MacRay&quot;</span>}]<span class="op">-&gt;</span>(thetown)</a>
<a class="sourceLine" id="cb4-4" title="4"><span class="kw">CREATE</span> (thetown)<span class="op">-</span>[<span class="ch">:DIRECTED_BY</span>]<span class="op">-&gt;</span>(ben)</a></code></pre></div>
</div>
<p>Listing 4 is technically one statement, and the three <code>CREATE</code>s following the first could be replaced with commas to make it even more concise (see the full database definition in Sec. 6.2 for an example). The first two lines create <code>Person</code> and <code>Movie</code> nodes, while the last two create <code>ACTED_IN</code> and <code>DIRECTED_BY</code> edges (or relations). The syntax for the <code>CREATE</code> statement is rather straightforward. Creating a node is as simple as <code>CREATE (&lt;NODE_DEFINITION&gt;)</code>. Looking specifically at the first line, <code>thetown:Movie</code> denotes that the label on this node is <code>Movie</code>, and that the node should be assigned to a variable called <code>thetown</code>. The variable can be used throughout the query to reference the node. Finally, everything within curly braces are simply properties on the form <code>key: value</code>. Neo4j has an excellent visualisation tool built-in to its web interface, and the visualisation of this particular database can be found in Fig. 4.</p>
<figure>
<img src="images/neo4j-db.png" alt="Figure 4: Graph visualisation of the example database. Orange nodes represent people, and blue nodes represent movies." id="fig:neo4j-visualisation" style="width:75.0%" /><figcaption>Figure 4: Graph visualisation of the example database. Orange nodes represent people, and blue nodes represent movies.</figcaption>
</figure>
<p>The definition of a relationship is similarly straightforward, and generally looks like <code>CREATE (&lt;NODE&gt;)-[&lt;EDGE_DEFINITION&gt;]-&gt;[&lt;NODE&gt;]</code>. <code>&lt;NODE&gt;</code> can be for example a variable or a node definition, and the <code>&lt;EDGE_DEFINITION&gt;</code> is written precisely the same as <code>&lt;NODE_DEFINITION&gt;</code>, including property declarations. Looking more closely at the last <code>CREATE</code> statement, it is plain to see how the variables <code>thetown</code> and <code>ben</code> are reused to denote the nodes which the edge connects. Note the arrow at one end of the edge defining its direction (<code>-&gt;</code>). All edges in a Neo4j database are directed, but Sec. 3.3.3 will show that queries can treat them as if they were undirected. Also note how no variable name is declared for the edge. There is no need for it, as it is not reused. The full database definition can be found in Sec. 6.2.</p>
<h2 id="sec:queries"><span class="header-section-number">3.3</span> Querying the databases</h2>
<p>This section presents a series of increasingly complex queries in SQL and Cypher. Keep in mind that these queries play to the strengths of a graph database. The idea is to show that use cases where graph databases may be preferable to relational databases <em>exist</em>, and not that they are preferable as a general rule. The expected results of all queries can be found in Sec. 6.3.</p>
<h3 id="sec:query1"><span class="header-section-number">3.3.1</span> Query #1: Find all actors and the roles they have played</h3>
<p>For the first query, we want to list all actors and the roles they have played, as well as in which movies. This is a straightforward three-way join with SQL, as shown in Listing 5.</p>
<div id="lst:sql-query-1" class="listing sql">
<p>Listing 5: SQL query #1</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode sql"><code class="sourceCode sql"><a class="sourceLine" id="cb5-1" title="1"><span class="kw">SELECT</span> Person.name, ActedIn.played_role, Movie.title </a>
<a class="sourceLine" id="cb5-2" title="2"><span class="kw">FROM</span> Person, Movie, ActedIn</a>
<a class="sourceLine" id="cb5-3" title="3"><span class="kw">WHERE</span></a>
<a class="sourceLine" id="cb5-4" title="4">  Person.<span class="kw">id</span> <span class="op">=</span> ActedIn.person_id <span class="kw">AND</span></a>
<a class="sourceLine" id="cb5-5" title="5">  Movie.<span class="kw">id</span> <span class="op">=</span> ActedIn.movie_id;</a></code></pre></div>
</div>
<p>With Cypher, it gets slightly simpler, using the <code>MATCH</code> statement shown in Listing 6. A <code>MATCH</code> statement looks much like a <code>CREATE</code> statement, but instead of declaring a structure to create, it declares a structure to search for. Here, that structure is any <code>Person</code> node connected to a <code>Movie</code> node via an <code>ACTED_IN</code> edge. Note that the edge is directed. Note how the nodes are assigned to variables <code>person</code> and <code>movie</code>, and the edge to <code>acted</code>, and that these variables are then used to select the specific results required in the <code>RETURN</code> statement. The results of the SQL and Cypher queries should be identical, apart from potentially different ordering of the results</p>
<div id="lst:cypher-query-1" class="listing sql">
<p>Listing 6: Cypher query #1</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode sql"><code class="sourceCode sql"><a class="sourceLine" id="cb6-1" title="1">MATCH (actor<span class="ch">:Person</span>)<span class="op">-</span>[acted<span class="ch">:ACTED_IN</span>]<span class="op">-&gt;</span>(movie<span class="ch">:Movie</span>)</a>
<a class="sourceLine" id="cb6-2" title="2"><span class="kw">RETURN</span> actor.name, acted.played_role, movie.title</a></code></pre></div>
</div>
<h3 id="sec:query2"><span class="header-section-number">3.3.2</span> Query #2: Find all self-directed actors</h3>
<p>This query is meant to find all actors that have acted in a movie that they have also directed. For SQL, this results in a slight extension of the three-way join in Sec. 3.3.1, making it the four-way join shown in Listing 7.</p>
<div id="lst:sql-query-2" class="listing sql">
<p>Listing 7: SQL query #2</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode sql"><code class="sourceCode sql"><a class="sourceLine" id="cb7-1" title="1"><span class="kw">SELECT</span> Person.name, ActedIn.played_role, Movie.title</a>
<a class="sourceLine" id="cb7-2" title="2"><span class="kw">FROM</span> Person, Movie, ActedIn, DirectedBy</a>
<a class="sourceLine" id="cb7-3" title="3"><span class="kw">WHERE</span></a>
<a class="sourceLine" id="cb7-4" title="4">  Person.<span class="kw">id</span> <span class="op">=</span> ActedIn.person_id <span class="kw">AND</span></a>
<a class="sourceLine" id="cb7-5" title="5">  Person.<span class="kw">id</span> <span class="op">=</span> DirectedBy.person_id <span class="kw">AND</span></a>
<a class="sourceLine" id="cb7-6" title="6">  Movie.<span class="kw">id</span> <span class="op">=</span> ActedIn.movie_id <span class="kw">AND</span></a>
<a class="sourceLine" id="cb7-7" title="7">  Movie.<span class="kw">id</span> <span class="op">=</span> DirectedBy.movie_id;</a></code></pre></div>
</div>
<p>The Cypher query also needs an extension, but it is done in a different way by simply adding another structure to match against. The query can be found in Listing 8, which clearly shows how convenient Cypher’s variables can be. Because the same variables appear in both structures, the comma can be viewed as a logical AND: only <code>Person</code> and <code>Movie</code> nodes connected by both an <code>ACTED_IN</code> edge and a <code>DIRECTED_BY</code> edge are matched. Again, both SQL and Cypher queries will yield identical results.</p>
<div id="lst:cypher-query-2" class="listing sql">
<p>Listing 8: Cypher query #2</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode sql"><code class="sourceCode sql"><a class="sourceLine" id="cb8-1" title="1">MATCH (actor<span class="ch">:Person</span>)<span class="op">-</span>[acted<span class="ch">:ACTED_IN</span>]<span class="op">-&gt;</span>(movie<span class="ch">:Movie</span>),</a>
<a class="sourceLine" id="cb8-2" title="2">      (movie)<span class="op">-</span>[<span class="ch">:DIRECTED_BY</span>]<span class="op">-&gt;</span>(actor)</a>
<a class="sourceLine" id="cb8-3" title="3"><span class="kw">RETURN</span> actor.name, acted.played_role, movie.title</a></code></pre></div>
</div>
<h3 id="sec:query3"><span class="header-section-number">3.3.3</span> Query #3: Rumors about Ben</h3>
<p>This is the final query, which is meant to clearly demonstrate the benefit of reasoning about data as a graph. The idea is to find any actor that may have heard a rumor about what it is like acting together with Ben Affleck. This includes any actor A who has acted in the same movie as Ben, or any actor B who has acted with actor A, or any actor C who has acted with actor B, and so on. The astute reader may have noticed that this is a slightly more complicated version of traversing a social graph to find a person’s friends, friends of friends, and so on<a href="#fn8" class="footnote-ref" id="fnref8" role="doc-noteref"><sup>8</sup></a>. The problem can be somewhat simplified by considering the <code>DIRECTED_BY</code> and <code>ACTED_IN</code> edges visualised in Fig. 4 as undirected edges. Then, it is simply a matter of finding every actor that can be reached from Ben’s node by traversing <code>ACTED_IN</code> edges. While it does not make much sense for a movie to have acted in an actor, it makes the problem easier to reason about. To solve such a graph traversal problem in SQL, we need to issue a so called <em>hierarchical query</em><a href="#fn9" class="footnote-ref" id="fnref9" role="doc-noteref"><sup>9</sup></a>, shown in Listing 9.</p>
<div id="lst:sql-query-3" class="listing sql">
<p>Listing 9: SQL query #3</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode sql"><code class="sourceCode sql"><a class="sourceLine" id="cb9-1" title="1"><span class="kw">WITH</span> RECURSIVE acted_in(person_id, movie_id) <span class="kw">AS</span> (</a>
<a class="sourceLine" id="cb9-2" title="2">  <span class="co">/* Initial start query */</span></a>
<a class="sourceLine" id="cb9-3" title="3">  <span class="kw">SELECT</span> person_id, movie_id</a>
<a class="sourceLine" id="cb9-4" title="4">  <span class="kw">FROM</span> ActedIn, Person</a>
<a class="sourceLine" id="cb9-5" title="5">  <span class="kw">WHERE</span> Person.<span class="kw">id</span> <span class="op">=</span> ActedIn.person_id <span class="kw">AND</span> </a>
<a class="sourceLine" id="cb9-6" title="6">        Person.name <span class="op">=</span> <span class="st">&#39;Ben Affleck&#39;</span></a>
<a class="sourceLine" id="cb9-7" title="7"><span class="kw">UNION</span></a>
<a class="sourceLine" id="cb9-8" title="8">  <span class="co">/* The recursive query */</span></a>
<a class="sourceLine" id="cb9-9" title="9">  <span class="kw">SELECT</span> ActedIn.person_id, ActedIn.movie_id</a>
<a class="sourceLine" id="cb9-10" title="10">  <span class="kw">FROM</span> acted_in, ActedIn</a>
<a class="sourceLine" id="cb9-11" title="11">  <span class="kw">WHERE</span> acted_in.movie_id <span class="op">=</span> ActedIn.movie_id <span class="kw">OR</span></a>
<a class="sourceLine" id="cb9-12" title="12">        acted_in.person_id <span class="op">=</span> ActedIn.person_id</a>
<a class="sourceLine" id="cb9-13" title="13">)</a>
<a class="sourceLine" id="cb9-14" title="14"><span class="co">/* selecting from the result */</span></a>
<a class="sourceLine" id="cb9-15" title="15"><span class="kw">SELECT</span> <span class="kw">DISTINCT</span> Person.name</a>
<a class="sourceLine" id="cb9-16" title="16"><span class="kw">FROM</span> acted_in, Person</a>
<a class="sourceLine" id="cb9-17" title="17"><span class="kw">WHERE</span> acted_in.person_id <span class="op">=</span> Person.<span class="kw">id</span></a>
<a class="sourceLine" id="cb9-18" title="18"><span class="kw">AND</span> Person.name <span class="op">!=</span> <span class="st">&#39;Ben Affleck&#39;</span></a></code></pre></div>
</div>
<p>I will briefly explain what is actually happening in the query. On the first line, the <code>acted_in</code> pseudo-entity is defined. Then, an initial “start” query is issued to find all of Ben’s <code>(person_id, movie_id)</code> tuples. What happens next is fairly unintuitive. The results of the “recursive” query is unioned with the initial query, the result of which is then unioned with the recursive query again, and again, until the result set is no longer expanding. It is essentially a breadth first search over the <code>ActedIn</code> relations, where the movies are discarded in the final result. The Cypher equivalent of the SQL query shown in Listing 10 is a good example of why representing data as graphs can be advantageous.</p>
<div id="lst:cypher-query-3" class="listing sql">
<p>Listing 10: Cypher query #3</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode sql"><code class="sourceCode sql"><a class="sourceLine" id="cb10-1" title="1">MATCH (ben<span class="ch">:Person</span> {name: <span class="ot">&quot;Ben Affleck&quot;</span>}),</a>
<a class="sourceLine" id="cb10-2" title="2">      (ben)<span class="op">-</span>[<span class="ch">:ACTED_IN</span><span class="op">*</span>]<span class="op">-</span>(movie<span class="ch">:Movie</span>),</a>
<a class="sourceLine" id="cb10-3" title="3">      (actor<span class="ch">:Person</span>)<span class="op">-</span>[<span class="ch">:ACTED_IN</span>]<span class="op">-&gt;</span>(movie)</a>
<a class="sourceLine" id="cb10-4" title="4"><span class="kw">RETURN</span> actor.name</a></code></pre></div>
</div>
<p>Fetching the Ben Affleck node and storing it in the <code>ben</code> variable is not strictly necessary, and could be done inline on the second line, but I found this more readable. Listing 10 can be broken down as follows.</p>
<ol type="1">
<li><code>MATCH (ben:Person {name: "Ben affleck"})</code>
<ul>
<li>Find the Ben Affleck node and store it in <code>ben</code></li>
</ul></li>
<li><code>(ben)-[:ACTED_IN*]-(movie:Movie)</code>
<ul>
<li>Find all <code>Movie</code> nodes reachable by traversing any amount of <code>ACTED_IN</code> edges, starting from <code>ben</code></li>
<li>Note the <code>*</code> for “any amount”</li>
<li>Note the lack of an arrowhead on the edge, which instructs Neo4j to consider the <code>ACTED_IN</code> edges as undirected</li>
</ul></li>
<li><code>(actor:Person)-[:ACTED_IN]-&gt;(movie)</code>
<ul>
<li>Find every actor who acted in any of the found <code>movie</code> nodes</li>
</ul></li>
<li><code>RETURN actor.name</code>
<ul>
<li>Return the name of every actor that matched the constraints</li>
</ul></li>
</ol>
<p>The results of SQL and Cypher queries should yet again be identical.</p>
<h1 id="sec:discussion"><span class="header-section-number">4</span> Discussion</h1>
<p>Property graph databases show some clear advantages over traditional relational databases. The queries in Cypher are shorter throughout, yet remain readable. The final query exemplified how a non-trivial but still realistic search query required use of advanced SQL constructs, with quite a lot of boilerplate, while the Cypher equivalent only made use of some of the most rudimentary features of the language and remained concise. While shorter is not always better, shorter <em>and</em> more readable surely has to count as better from a maintainability point of view. Another stark contrast between SQL and Cypher is the former’s reliance on a pre-defined schema, and the latter’s lack of such. A schemaless approach is a great boon to quick iteration development practices, as many minor alterations to the abstract schema of a schemaless database may not require any production database maintenance. On the other hand, <em>any</em> alteration in a SQL schema requires a database migration in production environments, which from personal experience can be a hassle even for relatively simple databases. This schemaless nature does however have the drawback that the data format is in not rigidly defined, which could lead to unexpected runtime behavior because some expected property was simply missing from a node or edge. It could be argued that the same can happen in a relational database by putting null values all over the place, so as with many other things, the advantages and disadvantages of either approach is not clear-cut.</p>
<p>There are some major caveats to these comparisons that should not go without mention. First, I specifically modelled the database and queries to play to the strengths of a graph representation. In other words, these are by no means general conclusions about graph databases being superior to relational databases, but rather that they can be given the right circumstances. Furthermore, Cypher is not <em>the</em> property graph database language, so results are not even generalizable over PG query languages as a whole. Time will tell if GQL ends up becoming a widely adopted standard, but as it stands, there is nothing resembling a standard for property graph databases. Adopting a database such as Neo4j may therefore lead to more lock-in than risk averse managers may be willing to accept. My closing thoughts on the matter are however that property graph databases are not here to replace relational databases, but definitely show promise as being superior in some circumstances. This is especially true for an environment where the data is easily modelled as a graph, where graph-like queries are common, or where rapid iteration on the related product may cause the model to be extended or changed over a relatively short amount of time. The fact that a relatively new database system such as Neo4j in some cases can rival the performance of relational database systems that have been developed and optimized for decades is also encouraging. I think that all of this makes it quite clear that relational databases as the one size fits all solution to persistent data storage is a thing of the past, and that there are now other solutions that sometimes provide a better fit.</p>

<h1 id="references"><span class="header-section-number">5</span> References</h1>
<div id="refs" role="doc-bibliography">
<div id="ref-vicknair2010comparison">
<p>[1] C. Vicknair, M. Macias, Z. Zhao, X. Nan, Y. Chen, and D. Wilkins, “A comparison of a graph database and a relational database: A data provenance perspective,” in <em>Proceedings of the 48th annual southeast regional conference</em>, 2010, p. 42.</p>
</div>
<div id="ref-selinger1979access">
<p>[2] P. G. Selinger, M. M. Astrahan, D. D. Chamberlin, R. A. Lorie, and T. G. Price, “Access path selection in a relational database management system,” in <em>Proceedings of the 1979 acm sigmod international conference on management of data</em>, 1979, pp. 23–34.</p>
</div>
<div id="ref-buerli2012current">
<p>[3] M. Buerli and C. Obispo, “The current state of graph databases,” <em>Department of Computer Science, Cal Poly San Luis Obispo, mbuerli@ calpoly. edu</em>, vol. 32, no. 3, pp. 67–83, 2012.</p>
</div>
<div id="ref-angles2008survey">
<p>[4] R. Angles and C. Gutierrez, “Survey of graph database models,” <em>ACM Computing Surveys (CSUR)</em>, vol. 40, no. 1, p. 1, 2008.</p>
</div>
<div id="ref-hartig2014reconciliation">
<p>[5] O. Hartig, “Reconciliation of rdf* and property graphs,” <em>arXiv preprint arXiv:1409.3288</em>, 2014.</p>
</div>
<div id="ref-angles2018g">
<p>[6] R. Angles, M. Arenas, P. Barceló, P. Boncz, G. Fletcher, C. Gutierrez, T. Lindaaker, M. Paradies, S. Plantikow, J. Sequeda, and others, “G-core: A core for future graph query languages,” in <em>Proceedings of the 2018 international conference on management of data</em>, 2018, pp. 1421–1432.</p>
</div>
<div id="ref-rdf">
<p>[7] R. Cyganiak, D. Wood, and M. Lanthaler, “RDF 1.1 concepts and abstract syntax,” 2014. [Online]. Available: <a href="https://www.w3.org/TR/rdf11-concepts/#section-rdf-graph">https://www.w3.org/TR/rdf11-concepts/#section-rdf-graph</a>. [Accessed: 04-Apr-2019].</p>
</div>
<div id="ref-semanticweb">
<p>[8] “Semantic web.” [Online]. Available: <a href="https://www.w3.org/standards/semanticweb/">https://www.w3.org/standards/semanticweb/</a>. [Accessed: 04-Apr-2019].</p>
</div>
<div id="ref-hayes2004bipartite">
<p>[9] J. Hayes and C. Gutierrez, “Bipartite graphs as intermediate model for rdf,” in <em>International semantic web conference</em>, 2004, pp. 47–61.</p>
</div>
<div id="ref-bornea2013building">
<p>[10] M. A. Bornea, J. Dolby, A. Kementsietsidis, K. Srinivas, P. Dantressangle, O. Udrea, and B. Bhattacharjee, “Building an efficient rdf store over a relational database,” in <em>Proceedings of the 2013 acm sigmod international conference on management of data</em>, 2013, pp. 121–132.</p>
</div>
<div id="ref-rodriguez2010constructions">
<p>[11] M. A. Rodriguez and P. Neubauer, “Constructions from dots and lines,” <em>Bulletin of the American Society for Information Science and Technology</em>, vol. 36, no. 6, pp. 35–41, 2010.</p>
</div>
<div id="ref-srinivasa2012data">
<p>[12] S. Srinivasa, “Data, storage and index models for graph databases,” in <em>Graph data management: Techniques and applications</em>, IGI Global, 2012, pp. 47–70.</p>
</div>
<div id="ref-barrasa2017rdfvslpg">
<p>[13] “RDF triple stores vs. Labeled property graphs: What’s the difference.” [Online]. Available: <a href="https://neo4j.com/blog/rdf-triple-store-vs-labeled-property-graph-difference/">https://neo4j.com/blog/rdf-triple-store-vs-labeled-property-graph-difference/</a>. [Accessed: 02-Apr-2019].</p>
</div>
<div id="ref-wiki2018graphdatabases">
<p>[14] “Graph database.” [Online]. Available: <a href="https://en.wikipedia.org/wiki/Graph_database">https://en.wikipedia.org/wiki/Graph_database</a>. [Accessed: 02-Apr-2019].</p>
</div>
<div id="ref-gqlstandard">
<p>[15] “GQL standrd,” 2018. [Online]. Available: <a href="https://www.gqlstandards.org/">https://www.gqlstandards.org/</a>. [Accessed: 04-Apr-2019].</p>
</div>
<div id="ref-gqlmanifesto">
<p>[16] “The gql manifesto,” 2018. [Online]. Available: <a href="https://gql.today/">https://gql.today/</a>. [Accessed: 04-Apr-2019].</p>
</div>
<div id="ref-w3c2019workshop">
<p>[17] D. Ragget, “W3C workshop on web standardization for graph data,” 2019. [Online]. Available: <a href="https://www.w3.org/Data/events/data-ws-2019/">https://www.w3.org/Data/events/data-ws-2019/</a>. [Accessed: 04-Apr-2019].</p>
</div>
<div id="ref-mccoll2014performance">
<p>[18] R. C. McColl, D. Ediger, J. Poovey, D. Campbell, and D. A. Bader, “A performance evaluation of open source graph databases,” in <em>Proceedings of the first workshop on parallel programming for analytics applications</em>, 2014, pp. 11–18.</p>
</div>
<div id="ref-jouili2013empirical">
<p>[19] S. Jouili and V. Vansteenberghe, “An empirical comparison of graph databases,” in <em>2013 international conference on social computing</em>, 2013, pp. 708–715.</p>
</div>
<div id="ref-ciglan2012benchmarking">
<p>[20] M. Ciglan, A. Averbuch, and L. Hluchy, “Benchmarking traversal operations over graph databases,” in <em>2012 ieee 28th international conference on data engineering workshops</em>, 2012, pp. 186–189.</p>
</div>
</div>

<h1 id="appendix"><span class="header-section-number">6</span> Appendix</h1>
<h2 id="sec:appendix-a"><span class="header-section-number">6.1</span> Appendix A</h2>
<div class="sourceCode" id="cb11"><pre class="sourceCode sql"><code class="sourceCode sql"><a class="sourceLine" id="cb11-1" title="1"><span class="kw">CREATE</span> <span class="kw">TABLE</span> Person (</a>
<a class="sourceLine" id="cb11-2" title="2">    <span class="kw">id</span> SERIAL <span class="kw">PRIMARY</span> <span class="kw">KEY</span>,</a>
<a class="sourceLine" id="cb11-3" title="3">    name <span class="dt">VARCHAR</span>(<span class="dv">128</span>) <span class="kw">NOT</span> <span class="kw">NULL</span></a>
<a class="sourceLine" id="cb11-4" title="4">);</a>
<a class="sourceLine" id="cb11-5" title="5"></a>
<a class="sourceLine" id="cb11-6" title="6"><span class="kw">CREATE</span> <span class="kw">TABLE</span> Movie (</a>
<a class="sourceLine" id="cb11-7" title="7">    <span class="kw">id</span> SERIAL <span class="kw">PRIMARY</span> <span class="kw">KEY</span>,</a>
<a class="sourceLine" id="cb11-8" title="8">    title <span class="dt">VARCHAR</span>(<span class="dv">128</span>) <span class="kw">NOT</span> <span class="kw">NULL</span></a>
<a class="sourceLine" id="cb11-9" title="9">);</a>
<a class="sourceLine" id="cb11-10" title="10"></a>
<a class="sourceLine" id="cb11-11" title="11"><span class="kw">CREATE</span> <span class="kw">TABLE</span> DirectedBy (</a>
<a class="sourceLine" id="cb11-12" title="12">    <span class="kw">id</span> SERIAL <span class="kw">PRIMARY</span> <span class="kw">KEY</span>,</a>
<a class="sourceLine" id="cb11-13" title="13">    person_id <span class="dt">INT</span> <span class="kw">NOT</span> <span class="kw">NULL</span> <span class="kw">REFERENCES</span> Person(<span class="kw">id</span>),</a>
<a class="sourceLine" id="cb11-14" title="14">    movie_id <span class="dt">INT</span> <span class="kw">NOT</span> <span class="kw">NULL</span> <span class="kw">REFERENCES</span> Movie(<span class="kw">id</span>)</a>
<a class="sourceLine" id="cb11-15" title="15">);</a>
<a class="sourceLine" id="cb11-16" title="16"></a>
<a class="sourceLine" id="cb11-17" title="17"><span class="kw">CREATE</span> <span class="kw">TABLE</span> ActedIn (</a>
<a class="sourceLine" id="cb11-18" title="18">    <span class="kw">id</span> SERIAL <span class="kw">PRIMARY</span> <span class="kw">KEY</span>,</a>
<a class="sourceLine" id="cb11-19" title="19">    person_id <span class="dt">INT</span> <span class="kw">NOT</span> <span class="kw">NULL</span> <span class="kw">REFERENCES</span> Person(<span class="kw">id</span>),</a>
<a class="sourceLine" id="cb11-20" title="20">    movie_id <span class="dt">INT</span> <span class="kw">NOT</span> <span class="kw">NULL</span> <span class="kw">REFERENCES</span> Movie(<span class="kw">id</span>),</a>
<a class="sourceLine" id="cb11-21" title="21">    played_role <span class="dt">VARCHAR</span>(<span class="dv">128</span>) <span class="kw">NOT</span> <span class="kw">NULL</span></a>
<a class="sourceLine" id="cb11-22" title="22">);</a>
<a class="sourceLine" id="cb11-23" title="23"></a>
<a class="sourceLine" id="cb11-24" title="24"><span class="kw">INSERT</span> <span class="kw">INTO</span> Movie(title) <span class="kw">VALUES</span> </a>
<a class="sourceLine" id="cb11-25" title="25">    (<span class="st">&#39;The Avengers&#39;</span>),</a>
<a class="sourceLine" id="cb11-26" title="26">    (<span class="st">&#39;The Town&#39;</span>),</a>
<a class="sourceLine" id="cb11-27" title="27">    (<span class="st">&#39;Justice League&#39;</span>),</a>
<a class="sourceLine" id="cb11-28" title="28">    (<span class="st">&#39;The Prestige&#39;</span>),</a>
<a class="sourceLine" id="cb11-29" title="29">    (<span class="st">&#39;The Dark Knight&#39;</span>);</a>
<a class="sourceLine" id="cb11-30" title="30"></a>
<a class="sourceLine" id="cb11-31" title="31"><span class="kw">INSERT</span> <span class="kw">INTO</span> Person(name) <span class="kw">VALUES</span> </a>
<a class="sourceLine" id="cb11-32" title="32">   (<span class="st">&#39;Amy Adams&#39;</span>),</a>
<a class="sourceLine" id="cb11-33" title="33">   (<span class="st">&#39;Ben Affleck&#39;</span>),</a>
<a class="sourceLine" id="cb11-34" title="34">   (<span class="st">&#39;Chris Hemsworth&#39;</span>),</a>
<a class="sourceLine" id="cb11-35" title="35">   (<span class="st">&#39;Scarlett Johansson&#39;</span>),</a>
<a class="sourceLine" id="cb11-36" title="36">   (<span class="st">&#39;Rebecca Hall&#39;</span>),</a>
<a class="sourceLine" id="cb11-37" title="37">   (<span class="st">&#39;Christian Bale&#39;</span>),</a>
<a class="sourceLine" id="cb11-38" title="38">   (<span class="st">&#39;Christopher Nolan&#39;</span>),</a>
<a class="sourceLine" id="cb11-39" title="39">   (<span class="st">&#39;Zack Snyder&#39;</span>),</a>
<a class="sourceLine" id="cb11-40" title="40">   (<span class="st">&#39;Joss Whedon&#39;</span>);</a>
<a class="sourceLine" id="cb11-41" title="41"></a>
<a class="sourceLine" id="cb11-42" title="42"><span class="kw">INSERT</span> <span class="kw">INTO</span> ActedIn(person_id, movie_id, played_role) <span class="kw">VALUES</span> </a>
<a class="sourceLine" id="cb11-43" title="43">    ((<span class="kw">SELECT</span> <span class="kw">id</span> <span class="kw">FROM</span> Person <span class="kw">WHERE</span> name<span class="op">=</span><span class="st">&#39;Amy Adams&#39;</span>),</a>
<a class="sourceLine" id="cb11-44" title="44">     (<span class="kw">SELECT</span> <span class="kw">id</span> <span class="kw">FROM</span> Movie <span class="kw">WHERE</span> title<span class="op">=</span><span class="st">&#39;Justice League&#39;</span>),</a>
<a class="sourceLine" id="cb11-45" title="45">     <span class="st">&#39;Lois Lane&#39;</span>),</a>
<a class="sourceLine" id="cb11-46" title="46">    ((<span class="kw">SELECT</span> <span class="kw">id</span> <span class="kw">FROM</span> Person <span class="kw">WHERE</span> name<span class="op">=</span><span class="st">&#39;Ben Affleck&#39;</span>),</a>
<a class="sourceLine" id="cb11-47" title="47">     (<span class="kw">SELECT</span> <span class="kw">id</span> <span class="kw">FROM</span> Movie <span class="kw">WHERE</span> title<span class="op">=</span><span class="st">&#39;The Town&#39;</span>),</a>
<a class="sourceLine" id="cb11-48" title="48">     <span class="st">&#39;Doug MacRay&#39;</span>),</a>
<a class="sourceLine" id="cb11-49" title="49">    ((<span class="kw">SELECT</span> <span class="kw">id</span> <span class="kw">FROM</span> Person <span class="kw">WHERE</span> name<span class="op">=</span><span class="st">&#39;Ben Affleck&#39;</span>),</a>
<a class="sourceLine" id="cb11-50" title="50">     (<span class="kw">SELECT</span> <span class="kw">id</span> <span class="kw">FROM</span> Movie <span class="kw">WHERE</span> title<span class="op">=</span><span class="st">&#39;Justice League&#39;</span>),</a>
<a class="sourceLine" id="cb11-51" title="51">     <span class="st">&#39;Batman&#39;</span>),</a>
<a class="sourceLine" id="cb11-52" title="52">    ((<span class="kw">SELECT</span> <span class="kw">id</span> <span class="kw">FROM</span> Person <span class="kw">WHERE</span> name<span class="op">=</span><span class="st">&#39;Chris Hemsworth&#39;</span>),</a>
<a class="sourceLine" id="cb11-53" title="53">     (<span class="kw">SELECT</span> <span class="kw">id</span> <span class="kw">FROM</span> Movie <span class="kw">WHERE</span> title<span class="op">=</span><span class="st">&#39;The Avengers&#39;</span>),</a>
<a class="sourceLine" id="cb11-54" title="54">     <span class="st">&#39;Thor&#39;</span>),</a>
<a class="sourceLine" id="cb11-55" title="55">    ((<span class="kw">SELECT</span> <span class="kw">id</span> <span class="kw">FROM</span> Person <span class="kw">WHERE</span> name<span class="op">=</span><span class="st">&#39;Christian Bale&#39;</span>),</a>
<a class="sourceLine" id="cb11-56" title="56">     (<span class="kw">SELECT</span> <span class="kw">id</span> <span class="kw">FROM</span> Movie <span class="kw">WHERE</span> title<span class="op">=</span><span class="st">&#39;The Prestige&#39;</span>),</a>
<a class="sourceLine" id="cb11-57" title="57">     <span class="st">&#39;Alfred Borden&#39;</span>),</a>
<a class="sourceLine" id="cb11-58" title="58">    ((<span class="kw">SELECT</span> <span class="kw">id</span> <span class="kw">FROM</span> Person <span class="kw">WHERE</span> name<span class="op">=</span><span class="st">&#39;Christian Bale&#39;</span>),</a>
<a class="sourceLine" id="cb11-59" title="59">     (<span class="kw">SELECT</span> <span class="kw">id</span> <span class="kw">FROM</span> Movie <span class="kw">WHERE</span> title<span class="op">=</span><span class="st">&#39;The Dark Knight&#39;</span>),</a>
<a class="sourceLine" id="cb11-60" title="60">     <span class="st">&#39;Batman&#39;</span>),</a>
<a class="sourceLine" id="cb11-61" title="61">    ((<span class="kw">SELECT</span> <span class="kw">id</span> <span class="kw">FROM</span> Person <span class="kw">WHERE</span> name<span class="op">=</span><span class="st">&#39;Rebecca Hall&#39;</span>),</a>
<a class="sourceLine" id="cb11-62" title="62">     (<span class="kw">SELECT</span> <span class="kw">id</span> <span class="kw">FROM</span> Movie <span class="kw">WHERE</span> title<span class="op">=</span><span class="st">&#39;The Prestige&#39;</span>),</a>
<a class="sourceLine" id="cb11-63" title="63">     <span class="st">&#39;Sarah&#39;</span>),</a>
<a class="sourceLine" id="cb11-64" title="64">    ((<span class="kw">SELECT</span> <span class="kw">id</span> <span class="kw">FROM</span> Person <span class="kw">WHERE</span> name<span class="op">=</span><span class="st">&#39;Rebecca Hall&#39;</span>),</a>
<a class="sourceLine" id="cb11-65" title="65">     (<span class="kw">SELECT</span> <span class="kw">id</span> <span class="kw">FROM</span> Movie <span class="kw">WHERE</span> title<span class="op">=</span><span class="st">&#39;The Town&#39;</span>),</a>
<a class="sourceLine" id="cb11-66" title="66">     <span class="st">&#39;Claire Keesey&#39;</span>),</a>
<a class="sourceLine" id="cb11-67" title="67">    ((<span class="kw">SELECT</span> <span class="kw">id</span> <span class="kw">FROM</span> Person <span class="kw">WHERE</span> name<span class="op">=</span><span class="st">&#39;Scarlett Johansson&#39;</span>),</a>
<a class="sourceLine" id="cb11-68" title="68">     (<span class="kw">SELECT</span> <span class="kw">id</span> <span class="kw">FROM</span> Movie <span class="kw">WHERE</span> title<span class="op">=</span><span class="st">&#39;The Avengers&#39;</span>),</a>
<a class="sourceLine" id="cb11-69" title="69">     <span class="st">&#39;Black Widow&#39;</span>);</a>
<a class="sourceLine" id="cb11-70" title="70"></a>
<a class="sourceLine" id="cb11-71" title="71"><span class="kw">INSERT</span> <span class="kw">INTO</span> DirectedBy(person_id, movie_id) <span class="kw">VALUES</span> </a>
<a class="sourceLine" id="cb11-72" title="72">    ((<span class="kw">SELECT</span> <span class="kw">id</span> <span class="kw">FROM</span> Person <span class="kw">WHERE</span> name<span class="op">=</span><span class="st">&#39;Ben Affleck&#39;</span>),</a>
<a class="sourceLine" id="cb11-73" title="73">     (<span class="kw">SELECT</span> <span class="kw">id</span> <span class="kw">FROM</span> Movie <span class="kw">WHERE</span> title<span class="op">=</span><span class="st">&#39;The Town&#39;</span>)),</a>
<a class="sourceLine" id="cb11-74" title="74">    ((<span class="kw">SELECT</span> <span class="kw">id</span> <span class="kw">FROM</span> Person <span class="kw">WHERE</span> name<span class="op">=</span><span class="st">&#39;Christopher Nolan&#39;</span>),</a>
<a class="sourceLine" id="cb11-75" title="75">     (<span class="kw">SELECT</span> <span class="kw">id</span> <span class="kw">FROM</span> Movie <span class="kw">WHERE</span> title<span class="op">=</span><span class="st">&#39;The Prestige&#39;</span>)),</a>
<a class="sourceLine" id="cb11-76" title="76">    ((<span class="kw">SELECT</span> <span class="kw">id</span> <span class="kw">FROM</span> Person <span class="kw">WHERE</span> name<span class="op">=</span><span class="st">&#39;Christopher Nolan&#39;</span>),</a>
<a class="sourceLine" id="cb11-77" title="77">     (<span class="kw">SELECT</span> <span class="kw">id</span> <span class="kw">FROM</span> Movie <span class="kw">WHERE</span> title<span class="op">=</span><span class="st">&#39;The Dark Knight&#39;</span>)),</a>
<a class="sourceLine" id="cb11-78" title="78">    ((<span class="kw">SELECT</span> <span class="kw">id</span> <span class="kw">FROM</span> Person <span class="kw">WHERE</span> name<span class="op">=</span><span class="st">&#39;Zack Snyder&#39;</span>),</a>
<a class="sourceLine" id="cb11-79" title="79">     (<span class="kw">SELECT</span> <span class="kw">id</span> <span class="kw">FROM</span> Movie <span class="kw">WHERE</span> title<span class="op">=</span><span class="st">&#39;Justice League&#39;</span>)),</a>
<a class="sourceLine" id="cb11-80" title="80">    ((<span class="kw">SELECT</span> <span class="kw">id</span> <span class="kw">FROM</span> Person <span class="kw">WHERE</span> name<span class="op">=</span><span class="st">&#39;Joss Whedon&#39;</span>),</a>
<a class="sourceLine" id="cb11-81" title="81">     (<span class="kw">SELECT</span> <span class="kw">id</span> <span class="kw">FROM</span> Movie <span class="kw">WHERE</span> title<span class="op">=</span><span class="st">&#39;The Avengers&#39;</span>));</a></code></pre></div>
<h2 id="sec:appendix-b"><span class="header-section-number">6.2</span> Appendix B</h2>
<div class="sourceCode" id="cb12"><pre class="sourceCode sql"><code class="sourceCode sql"><a class="sourceLine" id="cb12-1" title="1"><span class="op">//</span> Note that separating node<span class="op">/</span>edge definitions <span class="kw">with</span> <span class="st">&#39;,&#39;</span> <span class="kw">is</span> shorthand</a>
<a class="sourceLine" id="cb12-2" title="2"><span class="op">//</span> <span class="cf">for</span> multiple <span class="kw">CREATE</span></a>
<a class="sourceLine" id="cb12-3" title="3"><span class="kw">CREATE</span> (theavengers<span class="ch">:Movie</span> {title: <span class="ot">&quot;The Avengers&quot;</span>}),</a>
<a class="sourceLine" id="cb12-4" title="4">       (thetown<span class="ch">:Movie</span> {title: <span class="ot">&quot;The Town&quot;</span>}),</a>
<a class="sourceLine" id="cb12-5" title="5">       (justiceleague<span class="ch">:Movie</span> {title: <span class="ot">&quot;Justice League&quot;</span>}),</a>
<a class="sourceLine" id="cb12-6" title="6">       (theprestige<span class="ch">:Movie</span> {title: <span class="ot">&quot;The Prestige&quot;</span>}),</a>
<a class="sourceLine" id="cb12-7" title="7">       (thedarkknight<span class="ch">:Movie</span> {title: <span class="ot">&quot;The Dark Knight&quot;</span>}),</a>
<a class="sourceLine" id="cb12-8" title="8">       (amy<span class="ch">:Person</span> {name: <span class="ot">&quot;Amy Adams&quot;</span>}),</a>
<a class="sourceLine" id="cb12-9" title="9">       (ben<span class="ch">:Person</span> {name: <span class="ot">&quot;Ben Affleck&quot;</span>}),</a>
<a class="sourceLine" id="cb12-10" title="10">       (chris<span class="ch">:Person</span> {name: <span class="ot">&quot;Chris Hemsworth&quot;</span>}),</a>
<a class="sourceLine" id="cb12-11" title="11">       (scarlett<span class="ch">:Person</span> {name: <span class="ot">&quot;Scarlett Johansson&quot;</span>}),</a>
<a class="sourceLine" id="cb12-12" title="12">       (rebecca<span class="ch">:Person</span> {name: <span class="ot">&quot;Rebecca Hall&quot;</span>}),</a>
<a class="sourceLine" id="cb12-13" title="13">       (christian<span class="ch">:Person</span> {name: <span class="ot">&quot;Christian Bale&quot;</span>}),</a>
<a class="sourceLine" id="cb12-14" title="14">       (christopher<span class="ch">:Person</span> {name: <span class="ot">&quot;Christopher Nolan&quot;</span>}),</a>
<a class="sourceLine" id="cb12-15" title="15">       (zack<span class="ch">:Person</span> {name: <span class="ot">&quot;Zack Snyder&quot;</span>}),</a>
<a class="sourceLine" id="cb12-16" title="16">       (joss<span class="ch">:Person</span> {name: <span class="ot">&quot;Joss Whedon&quot;</span>}),</a>
<a class="sourceLine" id="cb12-17" title="17">       (amy)<span class="op">-</span>[<span class="ch">:ACTED_IN</span> {played_role: <span class="ot">&quot;Lois Lane&quot;</span>}]<span class="op">-&gt;</span>(justiceleague),</a>
<a class="sourceLine" id="cb12-18" title="18">       (ben)<span class="op">-</span>[<span class="ch">:ACTED_IN</span> {played_role: <span class="ot">&quot;Doug MacRay&quot;</span>}]<span class="op">-&gt;</span>(thetown),</a>
<a class="sourceLine" id="cb12-19" title="19">       (ben)<span class="op">-</span>[<span class="ch">:ACTED_IN</span> {played_role: <span class="ot">&quot;Batman&quot;</span>}]<span class="op">-&gt;</span>(justiceleague),</a>
<a class="sourceLine" id="cb12-20" title="20">       (chris)<span class="op">-</span>[<span class="ch">:ACTED_IN</span> {played_role: <span class="ot">&quot;Thor&quot;</span>}]<span class="op">-&gt;</span>(theavengers),</a>
<a class="sourceLine" id="cb12-21" title="21">       (christian)<span class="op">-</span>[<span class="ch">:ACTED_IN</span> {played_role: <span class="ot">&quot;Alfred Borden&quot;</span>}]<span class="op">-&gt;</span>(theprestige),</a>
<a class="sourceLine" id="cb12-22" title="22">       (christian)<span class="op">-</span>[<span class="ch">:ACTED_IN</span> {played_role: <span class="ot">&quot;Batman&quot;</span>}]<span class="op">-&gt;</span>(thedarkknight),</a>
<a class="sourceLine" id="cb12-23" title="23">       (rebecca)<span class="op">-</span>[<span class="ch">:ACTED_IN</span> {played_role: <span class="ot">&quot;Sarah&quot;</span>}]<span class="op">-&gt;</span>(theprestige),</a>
<a class="sourceLine" id="cb12-24" title="24">       (rebecca)<span class="op">-</span>[<span class="ch">:ACTED_IN</span> {played_role: <span class="ot">&quot;Claire Keesey&quot;</span>}]<span class="op">-&gt;</span>(thetown),</a>
<a class="sourceLine" id="cb12-25" title="25">       (scarlett)<span class="op">-</span>[<span class="ch">:ACTED_IN</span> {played_role: <span class="ot">&quot;Black Widow&quot;</span>}]<span class="op">-&gt;</span>(theavengers),</a>
<a class="sourceLine" id="cb12-26" title="26">       (thetown)<span class="op">-</span>[<span class="ch">:DIRECTED_BY</span>]<span class="op">-&gt;</span>(ben),</a>
<a class="sourceLine" id="cb12-27" title="27">       (theprestige)<span class="op">-</span>[<span class="ch">:DIRECTED_BY</span>]<span class="op">-&gt;</span>(christopher),</a>
<a class="sourceLine" id="cb12-28" title="28">       (thedarkknight)<span class="op">-</span>[<span class="ch">:DIRECTED_BY</span>]<span class="op">-&gt;</span>(christopher),</a>
<a class="sourceLine" id="cb12-29" title="29">       (justiceleague)<span class="op">-</span>[<span class="ch">:DIRECTED_BY</span>]<span class="op">-&gt;</span>(zack),</a>
<a class="sourceLine" id="cb12-30" title="30">       (theavengers)<span class="op">-</span>[<span class="ch">:DIRECTED_BY</span>]<span class="op">-&gt;</span>(joss)</a>
<a class="sourceLine" id="cb12-31" title="31"></a>
<a class="sourceLine" id="cb12-32" title="32"></a>
<a class="sourceLine" id="cb12-33" title="33"><span class="op">//</span> Typically, one would also <span class="kw">create</span> these indices <span class="kw">to</span> boost performance</a>
<a class="sourceLine" id="cb12-34" title="34"><span class="op">//</span> NOTE: One <span class="kw">query</span> per <span class="kw">CREATE</span> <span class="kw">INDEX</span> statement, <span class="kw">or</span> it will <span class="kw">not</span> <span class="kw">work</span></a>
<a class="sourceLine" id="cb12-35" title="35"></a>
<a class="sourceLine" id="cb12-36" title="36"><span class="op">//</span> <span class="kw">Index</span> <span class="kw">query</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb12-37" title="37"><span class="kw">CREATE</span> <span class="kw">INDEX</span> <span class="kw">ON</span> <span class="ch">:Person</span>(name)</a>
<a class="sourceLine" id="cb12-38" title="38"></a>
<a class="sourceLine" id="cb12-39" title="39"><span class="op">//</span> <span class="kw">Index</span> <span class="kw">query</span> <span class="dv">2</span></a>
<a class="sourceLine" id="cb12-40" title="40"><span class="kw">CREATE</span> <span class="kw">INDEX</span> <span class="kw">ON</span> <span class="ch">:Movie</span>(title)</a></code></pre></div>
<h2 id="sec:appendix-c"><span class="header-section-number">6.3</span> Appendix C</h2>
<div id="tbl:expected-results-1">
<table>
<caption>Table 2: Expected results for query #1</caption>
<thead>
<tr class="header">
<th>name</th>
<th>played_role</th>
<th>title</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Amy Adams</td>
<td>Lois Lane</td>
<td>Justice League</td>
</tr>
<tr class="even">
<td>Ben Affleck</td>
<td>Doug MacRay</td>
<td>The Town</td>
</tr>
<tr class="odd">
<td>Ben Affleck</td>
<td>Batman</td>
<td>Justice League</td>
</tr>
<tr class="even">
<td>Chris Hemsworth</td>
<td>Thor</td>
<td>The Avengers</td>
</tr>
<tr class="odd">
<td>Christian Bale</td>
<td>Alfred Borden</td>
<td>The Prestige</td>
</tr>
<tr class="even">
<td>Christian Bale</td>
<td>Batman</td>
<td>The Dark Knight</td>
</tr>
<tr class="odd">
<td>Rebecca Hall</td>
<td>Sarah</td>
<td>The Prestige</td>
</tr>
<tr class="even">
<td>Rebecca Hall</td>
<td>Claire Keesey</td>
<td>The Town</td>
</tr>
<tr class="odd">
<td>Scarlett Johansson</td>
<td>Black Widow</td>
<td>The Avengers</td>
</tr>
</tbody>
</table>
</div>
<div id="tbl:expected-results-2">
<table>
<caption>Table 3: Expected results for query #2</caption>
<thead>
<tr class="header">
<th>name</th>
<th>played_role</th>
<th>title</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Ben Affleck</td>
<td>Doug MacRay</td>
<td>The Town</td>
</tr>
</tbody>
</table>
</div>
<div id="tbl:expected-results-3">
<table>
<caption>Table 4: Expected results for query #3</caption>
<thead>
<tr class="header">
<th>name</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Rebecca Hall</td>
</tr>
<tr class="even">
<td>Christian Bale</td>
</tr>
<tr class="odd">
<td>Amy Adams</td>
</tr>
</tbody>
</table>
</div>
<section class="footnotes" role="doc-endnotes">
<hr />
<ol>
<li id="fn1" role="doc-endnote"><p><a href="https://franz.com/agraph/allegrograph/">https://franz.com/agraph/allegrograph/</a><a href="#fnref1" class="footnote-back" role="doc-backlink">↩</a></p></li>
<li id="fn2" role="doc-endnote"><p><a href="http://graphdb.ontotext.com/">http://graphdb.ontotext.com/</a><a href="#fnref2" class="footnote-back" role="doc-backlink">↩</a></p></li>
<li id="fn3" role="doc-endnote"><p><a href="https://neo4j.com">https://neo4j.com</a><a href="#fnref3" class="footnote-back" role="doc-backlink">↩</a></p></li>
<li id="fn4" role="doc-endnote"><p><a href="https://neo4j.com/developer/cypher/">https://neo4j.com/developer/cypher/</a><a href="#fnref4" class="footnote-back" role="doc-backlink">↩</a></p></li>
<li id="fn5" role="doc-endnote"><p><a href="http://www.opencypher.org/">http://www.opencypher.org/</a><a href="#fnref5" class="footnote-back" role="doc-backlink">↩</a></p></li>
<li id="fn6" role="doc-endnote"><p><a href="https://janusgraph.org/">https://janusgraph.org/</a><a href="#fnref6" class="footnote-back" role="doc-backlink">↩</a></p></li>
<li id="fn7" role="doc-endnote"><p><a href="https://docs.janusgraph.org/latest/gremlin.html">https://docs.janusgraph.org/latest/gremlin.html</a><a href="#fnref7" class="footnote-back" role="doc-backlink">↩</a></p></li>
<li id="fn8" role="doc-endnote"><p>This is closely related to the transitive closure of a binary relation R on some set S. Wikipedia has a nice page on the subject: <a href="https://en.wikipedia.org/wiki/Transitive_closure">https://en.wikipedia.org/wiki/Transitive_closure</a><a href="#fnref8" class="footnote-back" role="doc-backlink">↩</a></p></li>
<li id="fn9" role="doc-endnote"><p>Again, Wikipedia has a nice page on the subject: <a href="https://en.wikipedia.org/wiki/Hierarchical_and_recursive_queries_in_SQL">https://en.wikipedia.org/wiki/Hierarchical_and_recursive_queries_in_SQL</a><a href="#fnref9" class="footnote-back" role="doc-backlink">↩</a></p></li>
</ol>
</section>
</body>
</html>
